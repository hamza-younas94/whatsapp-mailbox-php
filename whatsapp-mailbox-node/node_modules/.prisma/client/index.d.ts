
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Reaction
 * 
 */
export type Reaction = $Result.DefaultSelection<Prisma.$ReactionPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model TagOnContact
 * 
 */
export type TagOnContact = $Result.DefaultSelection<Prisma.$TagOnContactPayload>
/**
 * Model Segment
 * 
 */
export type Segment = $Result.DefaultSelection<Prisma.$SegmentPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model QuickReply
 * 
 */
export type QuickReply = $Result.DefaultSelection<Prisma.$QuickReplyPayload>
/**
 * Model MessageTemplate
 * 
 */
export type MessageTemplate = $Result.DefaultSelection<Prisma.$MessageTemplatePayload>
/**
 * Model Automation
 * 
 */
export type Automation = $Result.DefaultSelection<Prisma.$AutomationPayload>
/**
 * Model AutoReply
 * 
 */
export type AutoReply = $Result.DefaultSelection<Prisma.$AutoReplyPayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model AppConfig
 * 
 */
export type AppConfig = $Result.DefaultSelection<Prisma.$AppConfigPayload>
/**
 * Model DripCampaign
 * 
 */
export type DripCampaign = $Result.DefaultSelection<Prisma.$DripCampaignPayload>
/**
 * Model DripCampaignStep
 * 
 */
export type DripCampaignStep = $Result.DefaultSelection<Prisma.$DripCampaignStepPayload>
/**
 * Model DripEnrollment
 * 
 */
export type DripEnrollment = $Result.DefaultSelection<Prisma.$DripEnrollmentPayload>
/**
 * Model DripScheduledMessage
 * 
 */
export type DripScheduledMessage = $Result.DefaultSelection<Prisma.$DripScheduledMessagePayload>
/**
 * Model WebhookLog
 * 
 */
export type WebhookLog = $Result.DefaultSelection<Prisma.$WebhookLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  AGENT: 'AGENT',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  DOCUMENT: 'DOCUMENT',
  BUTTON: 'BUTTON',
  LIST: 'LIST',
  INTERACTIVE: 'INTERACTIVE',
  LOCATION: 'LOCATION',
  CONTACT: 'CONTACT',
  TEMPLATE: 'TEMPLATE',
  REACTION: 'REACTION',
  STICKER: 'STICKER',
  POLL: 'POLL',
  GROUP_INVITE: 'GROUP_INVITE',
  STATUS: 'STATUS',
  CHANNEL_POST: 'CHANNEL_POST'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const MessageDirection: {
  INCOMING: 'INCOMING',
  OUTGOING: 'OUTGOING'
};

export type MessageDirection = (typeof MessageDirection)[keyof typeof MessageDirection]


export const MessageStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  READ: 'READ',
  FAILED: 'FAILED',
  RECEIVED: 'RECEIVED'
};

export type MessageStatus = (typeof MessageStatus)[keyof typeof MessageStatus]


export const CampaignType: {
  BROADCAST: 'BROADCAST',
  SCHEDULED: 'SCHEDULED',
  DRIP: 'DRIP',
  WORKFLOW: 'WORKFLOW'
};

export type CampaignType = (typeof CampaignType)[keyof typeof CampaignType]


export const CampaignStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  RUNNING: 'RUNNING',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]


export const ActivityType: {
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  MESSAGE_SENT: 'MESSAGE_SENT',
  MESSAGE_RECEIVED: 'MESSAGE_RECEIVED',
  CONTACT_CREATED: 'CONTACT_CREATED',
  CONTACT_UPDATED: 'CONTACT_UPDATED',
  TAG_CREATED: 'TAG_CREATED',
  TAG_DELETED: 'TAG_DELETED',
  AUTOMATION_TRIGGERED: 'AUTOMATION_TRIGGERED',
  CAMPAIGN_STARTED: 'CAMPAIGN_STARTED'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const ConfigType: {
  STRING: 'STRING',
  NUMBER: 'NUMBER',
  BOOLEAN: 'BOOLEAN',
  JSON: 'JSON'
};

export type ConfigType = (typeof ConfigType)[keyof typeof ConfigType]


export const DripTriggerType: {
  MANUAL: 'MANUAL',
  TAG_ADDED: 'TAG_ADDED',
  FORM_SUBMITTED: 'FORM_SUBMITTED'
};

export type DripTriggerType = (typeof DripTriggerType)[keyof typeof DripTriggerType]


export const DripEnrollmentStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type DripEnrollmentStatus = (typeof DripEnrollmentStatus)[keyof typeof DripEnrollmentStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type MessageDirection = $Enums.MessageDirection

export const MessageDirection: typeof $Enums.MessageDirection

export type MessageStatus = $Enums.MessageStatus

export const MessageStatus: typeof $Enums.MessageStatus

export type CampaignType = $Enums.CampaignType

export const CampaignType: typeof $Enums.CampaignType

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type ConfigType = $Enums.ConfigType

export const ConfigType: typeof $Enums.ConfigType

export type DripTriggerType = $Enums.DripTriggerType

export const DripTriggerType: typeof $Enums.DripTriggerType

export type DripEnrollmentStatus = $Enums.DripEnrollmentStatus

export const DripEnrollmentStatus: typeof $Enums.DripEnrollmentStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.reaction`: Exposes CRUD operations for the **Reaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reactions
    * const reactions = await prisma.reaction.findMany()
    * ```
    */
  get reaction(): Prisma.ReactionDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.tagOnContact`: Exposes CRUD operations for the **TagOnContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagOnContacts
    * const tagOnContacts = await prisma.tagOnContact.findMany()
    * ```
    */
  get tagOnContact(): Prisma.TagOnContactDelegate<ExtArgs>;

  /**
   * `prisma.segment`: Exposes CRUD operations for the **Segment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Segments
    * const segments = await prisma.segment.findMany()
    * ```
    */
  get segment(): Prisma.SegmentDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.quickReply`: Exposes CRUD operations for the **QuickReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuickReplies
    * const quickReplies = await prisma.quickReply.findMany()
    * ```
    */
  get quickReply(): Prisma.QuickReplyDelegate<ExtArgs>;

  /**
   * `prisma.messageTemplate`: Exposes CRUD operations for the **MessageTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageTemplates
    * const messageTemplates = await prisma.messageTemplate.findMany()
    * ```
    */
  get messageTemplate(): Prisma.MessageTemplateDelegate<ExtArgs>;

  /**
   * `prisma.automation`: Exposes CRUD operations for the **Automation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Automations
    * const automations = await prisma.automation.findMany()
    * ```
    */
  get automation(): Prisma.AutomationDelegate<ExtArgs>;

  /**
   * `prisma.autoReply`: Exposes CRUD operations for the **AutoReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoReplies
    * const autoReplies = await prisma.autoReply.findMany()
    * ```
    */
  get autoReply(): Prisma.AutoReplyDelegate<ExtArgs>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs>;

  /**
   * `prisma.appConfig`: Exposes CRUD operations for the **AppConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppConfigs
    * const appConfigs = await prisma.appConfig.findMany()
    * ```
    */
  get appConfig(): Prisma.AppConfigDelegate<ExtArgs>;

  /**
   * `prisma.dripCampaign`: Exposes CRUD operations for the **DripCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DripCampaigns
    * const dripCampaigns = await prisma.dripCampaign.findMany()
    * ```
    */
  get dripCampaign(): Prisma.DripCampaignDelegate<ExtArgs>;

  /**
   * `prisma.dripCampaignStep`: Exposes CRUD operations for the **DripCampaignStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DripCampaignSteps
    * const dripCampaignSteps = await prisma.dripCampaignStep.findMany()
    * ```
    */
  get dripCampaignStep(): Prisma.DripCampaignStepDelegate<ExtArgs>;

  /**
   * `prisma.dripEnrollment`: Exposes CRUD operations for the **DripEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DripEnrollments
    * const dripEnrollments = await prisma.dripEnrollment.findMany()
    * ```
    */
  get dripEnrollment(): Prisma.DripEnrollmentDelegate<ExtArgs>;

  /**
   * `prisma.dripScheduledMessage`: Exposes CRUD operations for the **DripScheduledMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DripScheduledMessages
    * const dripScheduledMessages = await prisma.dripScheduledMessage.findMany()
    * ```
    */
  get dripScheduledMessage(): Prisma.DripScheduledMessageDelegate<ExtArgs>;

  /**
   * `prisma.webhookLog`: Exposes CRUD operations for the **WebhookLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookLogs
    * const webhookLogs = await prisma.webhookLog.findMany()
    * ```
    */
  get webhookLog(): Prisma.WebhookLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Contact: 'Contact',
    Conversation: 'Conversation',
    Message: 'Message',
    Reaction: 'Reaction',
    Tag: 'Tag',
    TagOnContact: 'TagOnContact',
    Segment: 'Segment',
    Campaign: 'Campaign',
    QuickReply: 'QuickReply',
    MessageTemplate: 'MessageTemplate',
    Automation: 'Automation',
    AutoReply: 'AutoReply',
    Note: 'Note',
    ActivityLog: 'ActivityLog',
    AppConfig: 'AppConfig',
    DripCampaign: 'DripCampaign',
    DripCampaignStep: 'DripCampaignStep',
    DripEnrollment: 'DripEnrollment',
    DripScheduledMessage: 'DripScheduledMessage',
    WebhookLog: 'WebhookLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "contact" | "conversation" | "message" | "reaction" | "tag" | "tagOnContact" | "segment" | "campaign" | "quickReply" | "messageTemplate" | "automation" | "autoReply" | "note" | "activityLog" | "appConfig" | "dripCampaign" | "dripCampaignStep" | "dripEnrollment" | "dripScheduledMessage" | "webhookLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Reaction: {
        payload: Prisma.$ReactionPayload<ExtArgs>
        fields: Prisma.ReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findFirst: {
            args: Prisma.ReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findMany: {
            args: Prisma.ReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          create: {
            args: Prisma.ReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          createMany: {
            args: Prisma.ReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          update: {
            args: Prisma.ReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          deleteMany: {
            args: Prisma.ReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          aggregate: {
            args: Prisma.ReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReaction>
          }
          groupBy: {
            args: Prisma.ReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReactionCountArgs<ExtArgs>
            result: $Utils.Optional<ReactionCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      TagOnContact: {
        payload: Prisma.$TagOnContactPayload<ExtArgs>
        fields: Prisma.TagOnContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagOnContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagOnContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnContactPayload>
          }
          findFirst: {
            args: Prisma.TagOnContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagOnContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnContactPayload>
          }
          findMany: {
            args: Prisma.TagOnContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnContactPayload>[]
          }
          create: {
            args: Prisma.TagOnContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnContactPayload>
          }
          createMany: {
            args: Prisma.TagOnContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagOnContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnContactPayload>
          }
          update: {
            args: Prisma.TagOnContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnContactPayload>
          }
          deleteMany: {
            args: Prisma.TagOnContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagOnContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagOnContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnContactPayload>
          }
          aggregate: {
            args: Prisma.TagOnContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTagOnContact>
          }
          groupBy: {
            args: Prisma.TagOnContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagOnContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagOnContactCountArgs<ExtArgs>
            result: $Utils.Optional<TagOnContactCountAggregateOutputType> | number
          }
        }
      }
      Segment: {
        payload: Prisma.$SegmentPayload<ExtArgs>
        fields: Prisma.SegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          findFirst: {
            args: Prisma.SegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          findMany: {
            args: Prisma.SegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>[]
          }
          create: {
            args: Prisma.SegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          createMany: {
            args: Prisma.SegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          update: {
            args: Prisma.SegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          deleteMany: {
            args: Prisma.SegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          aggregate: {
            args: Prisma.SegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSegment>
          }
          groupBy: {
            args: Prisma.SegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SegmentCountArgs<ExtArgs>
            result: $Utils.Optional<SegmentCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      QuickReply: {
        payload: Prisma.$QuickReplyPayload<ExtArgs>
        fields: Prisma.QuickReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuickReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuickReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickReplyPayload>
          }
          findFirst: {
            args: Prisma.QuickReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuickReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickReplyPayload>
          }
          findMany: {
            args: Prisma.QuickReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickReplyPayload>[]
          }
          create: {
            args: Prisma.QuickReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickReplyPayload>
          }
          createMany: {
            args: Prisma.QuickReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuickReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickReplyPayload>
          }
          update: {
            args: Prisma.QuickReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickReplyPayload>
          }
          deleteMany: {
            args: Prisma.QuickReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuickReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuickReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickReplyPayload>
          }
          aggregate: {
            args: Prisma.QuickReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuickReply>
          }
          groupBy: {
            args: Prisma.QuickReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuickReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuickReplyCountArgs<ExtArgs>
            result: $Utils.Optional<QuickReplyCountAggregateOutputType> | number
          }
        }
      }
      MessageTemplate: {
        payload: Prisma.$MessageTemplatePayload<ExtArgs>
        fields: Prisma.MessageTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findFirst: {
            args: Prisma.MessageTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findMany: {
            args: Prisma.MessageTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          create: {
            args: Prisma.MessageTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          createMany: {
            args: Prisma.MessageTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          update: {
            args: Prisma.MessageTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          deleteMany: {
            args: Prisma.MessageTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          aggregate: {
            args: Prisma.MessageTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageTemplate>
          }
          groupBy: {
            args: Prisma.MessageTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateCountAggregateOutputType> | number
          }
        }
      }
      Automation: {
        payload: Prisma.$AutomationPayload<ExtArgs>
        fields: Prisma.AutomationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findFirst: {
            args: Prisma.AutomationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findMany: {
            args: Prisma.AutomationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          create: {
            args: Prisma.AutomationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          createMany: {
            args: Prisma.AutomationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutomationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          update: {
            args: Prisma.AutomationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          deleteMany: {
            args: Prisma.AutomationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          aggregate: {
            args: Prisma.AutomationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomation>
          }
          groupBy: {
            args: Prisma.AutomationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationCountAggregateOutputType> | number
          }
        }
      }
      AutoReply: {
        payload: Prisma.$AutoReplyPayload<ExtArgs>
        fields: Prisma.AutoReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReplyPayload>
          }
          findFirst: {
            args: Prisma.AutoReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReplyPayload>
          }
          findMany: {
            args: Prisma.AutoReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReplyPayload>[]
          }
          create: {
            args: Prisma.AutoReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReplyPayload>
          }
          createMany: {
            args: Prisma.AutoReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutoReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReplyPayload>
          }
          update: {
            args: Prisma.AutoReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReplyPayload>
          }
          deleteMany: {
            args: Prisma.AutoReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutoReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoReplyPayload>
          }
          aggregate: {
            args: Prisma.AutoReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoReply>
          }
          groupBy: {
            args: Prisma.AutoReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoReplyCountArgs<ExtArgs>
            result: $Utils.Optional<AutoReplyCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      AppConfig: {
        payload: Prisma.$AppConfigPayload<ExtArgs>
        fields: Prisma.AppConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          findFirst: {
            args: Prisma.AppConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          findMany: {
            args: Prisma.AppConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          create: {
            args: Prisma.AppConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          createMany: {
            args: Prisma.AppConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AppConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          update: {
            args: Prisma.AppConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          deleteMany: {
            args: Prisma.AppConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          aggregate: {
            args: Prisma.AppConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppConfig>
          }
          groupBy: {
            args: Prisma.AppConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppConfigCountArgs<ExtArgs>
            result: $Utils.Optional<AppConfigCountAggregateOutputType> | number
          }
        }
      }
      DripCampaign: {
        payload: Prisma.$DripCampaignPayload<ExtArgs>
        fields: Prisma.DripCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DripCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DripCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignPayload>
          }
          findFirst: {
            args: Prisma.DripCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DripCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignPayload>
          }
          findMany: {
            args: Prisma.DripCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignPayload>[]
          }
          create: {
            args: Prisma.DripCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignPayload>
          }
          createMany: {
            args: Prisma.DripCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DripCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignPayload>
          }
          update: {
            args: Prisma.DripCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignPayload>
          }
          deleteMany: {
            args: Prisma.DripCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DripCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DripCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignPayload>
          }
          aggregate: {
            args: Prisma.DripCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDripCampaign>
          }
          groupBy: {
            args: Prisma.DripCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<DripCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.DripCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<DripCampaignCountAggregateOutputType> | number
          }
        }
      }
      DripCampaignStep: {
        payload: Prisma.$DripCampaignStepPayload<ExtArgs>
        fields: Prisma.DripCampaignStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DripCampaignStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DripCampaignStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignStepPayload>
          }
          findFirst: {
            args: Prisma.DripCampaignStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DripCampaignStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignStepPayload>
          }
          findMany: {
            args: Prisma.DripCampaignStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignStepPayload>[]
          }
          create: {
            args: Prisma.DripCampaignStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignStepPayload>
          }
          createMany: {
            args: Prisma.DripCampaignStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DripCampaignStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignStepPayload>
          }
          update: {
            args: Prisma.DripCampaignStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignStepPayload>
          }
          deleteMany: {
            args: Prisma.DripCampaignStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DripCampaignStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DripCampaignStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripCampaignStepPayload>
          }
          aggregate: {
            args: Prisma.DripCampaignStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDripCampaignStep>
          }
          groupBy: {
            args: Prisma.DripCampaignStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<DripCampaignStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.DripCampaignStepCountArgs<ExtArgs>
            result: $Utils.Optional<DripCampaignStepCountAggregateOutputType> | number
          }
        }
      }
      DripEnrollment: {
        payload: Prisma.$DripEnrollmentPayload<ExtArgs>
        fields: Prisma.DripEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DripEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DripEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.DripEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DripEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripEnrollmentPayload>
          }
          findMany: {
            args: Prisma.DripEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripEnrollmentPayload>[]
          }
          create: {
            args: Prisma.DripEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripEnrollmentPayload>
          }
          createMany: {
            args: Prisma.DripEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DripEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripEnrollmentPayload>
          }
          update: {
            args: Prisma.DripEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.DripEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DripEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DripEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.DripEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDripEnrollment>
          }
          groupBy: {
            args: Prisma.DripEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DripEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DripEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<DripEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      DripScheduledMessage: {
        payload: Prisma.$DripScheduledMessagePayload<ExtArgs>
        fields: Prisma.DripScheduledMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DripScheduledMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripScheduledMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DripScheduledMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripScheduledMessagePayload>
          }
          findFirst: {
            args: Prisma.DripScheduledMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripScheduledMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DripScheduledMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripScheduledMessagePayload>
          }
          findMany: {
            args: Prisma.DripScheduledMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripScheduledMessagePayload>[]
          }
          create: {
            args: Prisma.DripScheduledMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripScheduledMessagePayload>
          }
          createMany: {
            args: Prisma.DripScheduledMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DripScheduledMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripScheduledMessagePayload>
          }
          update: {
            args: Prisma.DripScheduledMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripScheduledMessagePayload>
          }
          deleteMany: {
            args: Prisma.DripScheduledMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DripScheduledMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DripScheduledMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DripScheduledMessagePayload>
          }
          aggregate: {
            args: Prisma.DripScheduledMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDripScheduledMessage>
          }
          groupBy: {
            args: Prisma.DripScheduledMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DripScheduledMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DripScheduledMessageCountArgs<ExtArgs>
            result: $Utils.Optional<DripScheduledMessageCountAggregateOutputType> | number
          }
        }
      }
      WebhookLog: {
        payload: Prisma.$WebhookLogPayload<ExtArgs>
        fields: Prisma.WebhookLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          findFirst: {
            args: Prisma.WebhookLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          findMany: {
            args: Prisma.WebhookLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          create: {
            args: Prisma.WebhookLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          createMany: {
            args: Prisma.WebhookLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WebhookLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          update: {
            args: Prisma.WebhookLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          deleteMany: {
            args: Prisma.WebhookLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          aggregate: {
            args: Prisma.WebhookLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookLog>
          }
          groupBy: {
            args: Prisma.WebhookLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookLogCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    conversations: number
    messages: number
    contacts: number
    tags: number
    segments: number
    quickReplies: number
    automations: number
    notes: number
    activityLogs: number
    dripCampaigns: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    contacts?: boolean | UserCountOutputTypeCountContactsArgs
    tags?: boolean | UserCountOutputTypeCountTagsArgs
    segments?: boolean | UserCountOutputTypeCountSegmentsArgs
    quickReplies?: boolean | UserCountOutputTypeCountQuickRepliesArgs
    automations?: boolean | UserCountOutputTypeCountAutomationsArgs
    notes?: boolean | UserCountOutputTypeCountNotesArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    dripCampaigns?: boolean | UserCountOutputTypeCountDripCampaignsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuickRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuickReplyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDripCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DripCampaignWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    conversations: number
    messages: number
    tags: number
    notes: number
    dripEnrollments: number
    dripScheduled: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | ContactCountOutputTypeCountConversationsArgs
    messages?: boolean | ContactCountOutputTypeCountMessagesArgs
    tags?: boolean | ContactCountOutputTypeCountTagsArgs
    notes?: boolean | ContactCountOutputTypeCountNotesArgs
    dripEnrollments?: boolean | ContactCountOutputTypeCountDripEnrollmentsArgs
    dripScheduled?: boolean | ContactCountOutputTypeCountDripScheduledArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagOnContactWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountDripEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DripEnrollmentWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountDripScheduledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DripScheduledMessageWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    reactions: number
    notes: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reactions?: boolean | MessageCountOutputTypeCountReactionsArgs
    notes?: boolean | MessageCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    contacts: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | TagCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagOnContactWhereInput
  }


  /**
   * Count Type DripCampaignCountOutputType
   */

  export type DripCampaignCountOutputType = {
    steps: number
    enrollments: number
    scheduled: number
  }

  export type DripCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | DripCampaignCountOutputTypeCountStepsArgs
    enrollments?: boolean | DripCampaignCountOutputTypeCountEnrollmentsArgs
    scheduled?: boolean | DripCampaignCountOutputTypeCountScheduledArgs
  }

  // Custom InputTypes
  /**
   * DripCampaignCountOutputType without action
   */
  export type DripCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignCountOutputType
     */
    select?: DripCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DripCampaignCountOutputType without action
   */
  export type DripCampaignCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DripCampaignStepWhereInput
  }

  /**
   * DripCampaignCountOutputType without action
   */
  export type DripCampaignCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DripEnrollmentWhereInput
  }

  /**
   * DripCampaignCountOutputType without action
   */
  export type DripCampaignCountOutputTypeCountScheduledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DripScheduledMessageWhereInput
  }


  /**
   * Count Type DripCampaignStepCountOutputType
   */

  export type DripCampaignStepCountOutputType = {
    scheduled: number
  }

  export type DripCampaignStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduled?: boolean | DripCampaignStepCountOutputTypeCountScheduledArgs
  }

  // Custom InputTypes
  /**
   * DripCampaignStepCountOutputType without action
   */
  export type DripCampaignStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStepCountOutputType
     */
    select?: DripCampaignStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DripCampaignStepCountOutputType without action
   */
  export type DripCampaignStepCountOutputTypeCountScheduledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DripScheduledMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    name: string | null
    avatarUrl: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    name: string | null
    avatarUrl: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    name: number
    avatarUrl: number
    role: number
    isActive: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    name?: true
    avatarUrl?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    name?: true
    avatarUrl?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    name?: true
    avatarUrl?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string
    name: string | null
    avatarUrl: string | null
    role: $Enums.UserRole
    isActive: boolean
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    name?: boolean
    avatarUrl?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    tags?: boolean | User$tagsArgs<ExtArgs>
    segments?: boolean | User$segmentsArgs<ExtArgs>
    quickReplies?: boolean | User$quickRepliesArgs<ExtArgs>
    automations?: boolean | User$automationsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    dripCampaigns?: boolean | User$dripCampaignsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    name?: boolean
    avatarUrl?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    tags?: boolean | User$tagsArgs<ExtArgs>
    segments?: boolean | User$segmentsArgs<ExtArgs>
    quickReplies?: boolean | User$quickRepliesArgs<ExtArgs>
    automations?: boolean | User$automationsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    dripCampaigns?: boolean | User$dripCampaignsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      segments: Prisma.$SegmentPayload<ExtArgs>[]
      quickReplies: Prisma.$QuickReplyPayload<ExtArgs>[]
      automations: Prisma.$AutomationPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      dripCampaigns: Prisma.$DripCampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string
      name: string | null
      avatarUrl: string | null
      role: $Enums.UserRole
      isActive: boolean
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    contacts<T extends User$contactsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends User$tagsArgs<ExtArgs> = {}>(args?: Subset<T, User$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    segments<T extends User$segmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$segmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findMany"> | Null>
    quickReplies<T extends User$quickRepliesArgs<ExtArgs> = {}>(args?: Subset<T, User$quickRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickReplyPayload<ExtArgs>, T, "findMany"> | Null>
    automations<T extends User$automationsArgs<ExtArgs> = {}>(args?: Subset<T, User$automationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends User$notesArgs<ExtArgs> = {}>(args?: Subset<T, User$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    dripCampaigns<T extends User$dripCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$dripCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.contacts
   */
  export type User$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * User.tags
   */
  export type User$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * User.segments
   */
  export type User$segmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    where?: SegmentWhereInput
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    cursor?: SegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * User.quickReplies
   */
  export type User$quickRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickReply
     */
    select?: QuickReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickReplyInclude<ExtArgs> | null
    where?: QuickReplyWhereInput
    orderBy?: QuickReplyOrderByWithRelationInput | QuickReplyOrderByWithRelationInput[]
    cursor?: QuickReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuickReplyScalarFieldEnum | QuickReplyScalarFieldEnum[]
  }

  /**
   * User.automations
   */
  export type User$automationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    cursor?: AutomationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * User.notes
   */
  export type User$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.dripCampaigns
   */
  export type User$dripCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaign
     */
    select?: DripCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignInclude<ExtArgs> | null
    where?: DripCampaignWhereInput
    orderBy?: DripCampaignOrderByWithRelationInput | DripCampaignOrderByWithRelationInput[]
    cursor?: DripCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DripCampaignScalarFieldEnum | DripCampaignScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    engagementScore: number | null
    messageCount: number | null
    totalInteractions: number | null
  }

  export type ContactSumAggregateOutputType = {
    engagementScore: number | null
    messageCount: number | null
    totalInteractions: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    phoneNumber: string | null
    name: string | null
    pushName: string | null
    businessName: string | null
    email: string | null
    avatarUrl: string | null
    profilePhotoUrl: string | null
    company: string | null
    department: string | null
    contactType: string | null
    timezone: string | null
    lastMessageAt: Date | null
    lastActiveAt: Date | null
    engagementScore: number | null
    engagementLevel: string | null
    messageCount: number | null
    totalInteractions: number | null
    isBlocked: boolean | null
    isBusiness: boolean | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    phoneNumber: string | null
    name: string | null
    pushName: string | null
    businessName: string | null
    email: string | null
    avatarUrl: string | null
    profilePhotoUrl: string | null
    company: string | null
    department: string | null
    contactType: string | null
    timezone: string | null
    lastMessageAt: Date | null
    lastActiveAt: Date | null
    engagementScore: number | null
    engagementLevel: string | null
    messageCount: number | null
    totalInteractions: number | null
    isBlocked: boolean | null
    isBusiness: boolean | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    userId: number
    phoneNumber: number
    name: number
    pushName: number
    businessName: number
    email: number
    avatarUrl: number
    profilePhotoUrl: number
    company: number
    department: number
    contactType: number
    timezone: number
    lastMessageAt: number
    lastActiveAt: number
    engagementScore: number
    engagementLevel: number
    messageCount: number
    totalInteractions: number
    isBlocked: number
    isBusiness: number
    isVerified: number
    customFields: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    engagementScore?: true
    messageCount?: true
    totalInteractions?: true
  }

  export type ContactSumAggregateInputType = {
    engagementScore?: true
    messageCount?: true
    totalInteractions?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    name?: true
    pushName?: true
    businessName?: true
    email?: true
    avatarUrl?: true
    profilePhotoUrl?: true
    company?: true
    department?: true
    contactType?: true
    timezone?: true
    lastMessageAt?: true
    lastActiveAt?: true
    engagementScore?: true
    engagementLevel?: true
    messageCount?: true
    totalInteractions?: true
    isBlocked?: true
    isBusiness?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    name?: true
    pushName?: true
    businessName?: true
    email?: true
    avatarUrl?: true
    profilePhotoUrl?: true
    company?: true
    department?: true
    contactType?: true
    timezone?: true
    lastMessageAt?: true
    lastActiveAt?: true
    engagementScore?: true
    engagementLevel?: true
    messageCount?: true
    totalInteractions?: true
    isBlocked?: true
    isBusiness?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    name?: true
    pushName?: true
    businessName?: true
    email?: true
    avatarUrl?: true
    profilePhotoUrl?: true
    company?: true
    department?: true
    contactType?: true
    timezone?: true
    lastMessageAt?: true
    lastActiveAt?: true
    engagementScore?: true
    engagementLevel?: true
    messageCount?: true
    totalInteractions?: true
    isBlocked?: true
    isBusiness?: true
    isVerified?: true
    customFields?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    userId: string
    phoneNumber: string
    name: string | null
    pushName: string | null
    businessName: string | null
    email: string | null
    avatarUrl: string | null
    profilePhotoUrl: string | null
    company: string | null
    department: string | null
    contactType: string
    timezone: string | null
    lastMessageAt: Date | null
    lastActiveAt: Date | null
    engagementScore: number
    engagementLevel: string
    messageCount: number
    totalInteractions: number
    isBlocked: boolean
    isBusiness: boolean
    isVerified: boolean
    customFields: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    name?: boolean
    pushName?: boolean
    businessName?: boolean
    email?: boolean
    avatarUrl?: boolean
    profilePhotoUrl?: boolean
    company?: boolean
    department?: boolean
    contactType?: boolean
    timezone?: boolean
    lastMessageAt?: boolean
    lastActiveAt?: boolean
    engagementScore?: boolean
    engagementLevel?: boolean
    messageCount?: boolean
    totalInteractions?: boolean
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversations?: boolean | Contact$conversationsArgs<ExtArgs>
    messages?: boolean | Contact$messagesArgs<ExtArgs>
    tags?: boolean | Contact$tagsArgs<ExtArgs>
    notes?: boolean | Contact$notesArgs<ExtArgs>
    dripEnrollments?: boolean | Contact$dripEnrollmentsArgs<ExtArgs>
    dripScheduled?: boolean | Contact$dripScheduledArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>


  export type ContactSelectScalar = {
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    name?: boolean
    pushName?: boolean
    businessName?: boolean
    email?: boolean
    avatarUrl?: boolean
    profilePhotoUrl?: boolean
    company?: boolean
    department?: boolean
    contactType?: boolean
    timezone?: boolean
    lastMessageAt?: boolean
    lastActiveAt?: boolean
    engagementScore?: boolean
    engagementLevel?: boolean
    messageCount?: boolean
    totalInteractions?: boolean
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversations?: boolean | Contact$conversationsArgs<ExtArgs>
    messages?: boolean | Contact$messagesArgs<ExtArgs>
    tags?: boolean | Contact$tagsArgs<ExtArgs>
    notes?: boolean | Contact$notesArgs<ExtArgs>
    dripEnrollments?: boolean | Contact$dripEnrollmentsArgs<ExtArgs>
    dripScheduled?: boolean | Contact$dripScheduledArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      tags: Prisma.$TagOnContactPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      dripEnrollments: Prisma.$DripEnrollmentPayload<ExtArgs>[]
      dripScheduled: Prisma.$DripScheduledMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      phoneNumber: string
      name: string | null
      pushName: string | null
      businessName: string | null
      email: string | null
      avatarUrl: string | null
      profilePhotoUrl: string | null
      company: string | null
      department: string | null
      contactType: string
      timezone: string | null
      lastMessageAt: Date | null
      lastActiveAt: Date | null
      engagementScore: number
      engagementLevel: string
      messageCount: number
      totalInteractions: number
      isBlocked: boolean
      isBusiness: boolean
      isVerified: boolean
      customFields: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    conversations<T extends Contact$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Contact$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends Contact$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagOnContactPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends Contact$notesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    dripEnrollments<T extends Contact$dripEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$dripEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DripEnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    dripScheduled<T extends Contact$dripScheduledArgs<ExtArgs> = {}>(args?: Subset<T, Contact$dripScheduledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly userId: FieldRef<"Contact", 'String'>
    readonly phoneNumber: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly pushName: FieldRef<"Contact", 'String'>
    readonly businessName: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly avatarUrl: FieldRef<"Contact", 'String'>
    readonly profilePhotoUrl: FieldRef<"Contact", 'String'>
    readonly company: FieldRef<"Contact", 'String'>
    readonly department: FieldRef<"Contact", 'String'>
    readonly contactType: FieldRef<"Contact", 'String'>
    readonly timezone: FieldRef<"Contact", 'String'>
    readonly lastMessageAt: FieldRef<"Contact", 'DateTime'>
    readonly lastActiveAt: FieldRef<"Contact", 'DateTime'>
    readonly engagementScore: FieldRef<"Contact", 'Float'>
    readonly engagementLevel: FieldRef<"Contact", 'String'>
    readonly messageCount: FieldRef<"Contact", 'Int'>
    readonly totalInteractions: FieldRef<"Contact", 'Int'>
    readonly isBlocked: FieldRef<"Contact", 'Boolean'>
    readonly isBusiness: FieldRef<"Contact", 'Boolean'>
    readonly isVerified: FieldRef<"Contact", 'Boolean'>
    readonly customFields: FieldRef<"Contact", 'Json'>
    readonly metadata: FieldRef<"Contact", 'Json'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact.conversations
   */
  export type Contact$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Contact.messages
   */
  export type Contact$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Contact.tags
   */
  export type Contact$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
    where?: TagOnContactWhereInput
    orderBy?: TagOnContactOrderByWithRelationInput | TagOnContactOrderByWithRelationInput[]
    cursor?: TagOnContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagOnContactScalarFieldEnum | TagOnContactScalarFieldEnum[]
  }

  /**
   * Contact.notes
   */
  export type Contact$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Contact.dripEnrollments
   */
  export type Contact$dripEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
    where?: DripEnrollmentWhereInput
    orderBy?: DripEnrollmentOrderByWithRelationInput | DripEnrollmentOrderByWithRelationInput[]
    cursor?: DripEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DripEnrollmentScalarFieldEnum | DripEnrollmentScalarFieldEnum[]
  }

  /**
   * Contact.dripScheduled
   */
  export type Contact$dripScheduledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    where?: DripScheduledMessageWhereInput
    orderBy?: DripScheduledMessageOrderByWithRelationInput | DripScheduledMessageOrderByWithRelationInput[]
    cursor?: DripScheduledMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DripScheduledMessageScalarFieldEnum | DripScheduledMessageScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationAvgAggregateOutputType = {
    unreadCount: number | null
  }

  export type ConversationSumAggregateOutputType = {
    unreadCount: number | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    contactId: string | null
    isActive: boolean | null
    unreadCount: number | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    contactId: string | null
    isActive: boolean | null
    unreadCount: number | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    userId: number
    contactId: number
    isActive: number
    unreadCount: number
    lastMessageAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationAvgAggregateInputType = {
    unreadCount?: true
  }

  export type ConversationSumAggregateInputType = {
    unreadCount?: true
  }

  export type ConversationMinAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    isActive?: true
    unreadCount?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    isActive?: true
    unreadCount?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    isActive?: true
    unreadCount?: true
    lastMessageAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _avg?: ConversationAvgAggregateInputType
    _sum?: ConversationSumAggregateInputType
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    userId: string
    contactId: string
    isActive: boolean
    unreadCount: number
    lastMessageAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contactId?: boolean
    isActive?: boolean
    unreadCount?: boolean
    lastMessageAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>


  export type ConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    contactId?: boolean
    isActive?: boolean
    unreadCount?: boolean
    lastMessageAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      contactId: string
      isActive: boolean
      unreadCount: number
      lastMessageAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly userId: FieldRef<"Conversation", 'String'>
    readonly contactId: FieldRef<"Conversation", 'String'>
    readonly isActive: FieldRef<"Conversation", 'Boolean'>
    readonly unreadCount: FieldRef<"Conversation", 'Int'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
    readonly metadata: FieldRef<"Conversation", 'Json'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    contactId: string | null
    conversationId: string | null
    waMessageId: string | null
    content: string | null
    messageType: $Enums.MessageType | null
    direction: $Enums.MessageDirection | null
    status: $Enums.MessageStatus | null
    mediaUrl: string | null
    mediaType: string | null
    mediaFileName: string | null
    quotedMessageId: string | null
    isGroupMessage: boolean | null
    groupId: string | null
    groupName: string | null
    isStatusUpdate: boolean | null
    isChannelMessage: boolean | null
    channelId: string | null
    senderName: string | null
    templateId: string | null
    quickReplyId: string | null
    scheduledAt: Date | null
    sendAt: Date | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    contactId: string | null
    conversationId: string | null
    waMessageId: string | null
    content: string | null
    messageType: $Enums.MessageType | null
    direction: $Enums.MessageDirection | null
    status: $Enums.MessageStatus | null
    mediaUrl: string | null
    mediaType: string | null
    mediaFileName: string | null
    quotedMessageId: string | null
    isGroupMessage: boolean | null
    groupId: string | null
    groupName: string | null
    isStatusUpdate: boolean | null
    isChannelMessage: boolean | null
    channelId: string | null
    senderName: string | null
    templateId: string | null
    quickReplyId: string | null
    scheduledAt: Date | null
    sendAt: Date | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    userId: number
    contactId: number
    conversationId: number
    waMessageId: number
    content: number
    messageType: number
    direction: number
    status: number
    mediaUrl: number
    mediaType: number
    mediaFileName: number
    quotedMessageId: number
    isGroupMessage: number
    groupId: number
    groupName: number
    isStatusUpdate: number
    isChannelMessage: number
    channelId: number
    senderName: number
    templateId: number
    quickReplyId: number
    tagIds: number
    metadata: number
    scheduledAt: number
    sendAt: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    conversationId?: true
    waMessageId?: true
    content?: true
    messageType?: true
    direction?: true
    status?: true
    mediaUrl?: true
    mediaType?: true
    mediaFileName?: true
    quotedMessageId?: true
    isGroupMessage?: true
    groupId?: true
    groupName?: true
    isStatusUpdate?: true
    isChannelMessage?: true
    channelId?: true
    senderName?: true
    templateId?: true
    quickReplyId?: true
    scheduledAt?: true
    sendAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    conversationId?: true
    waMessageId?: true
    content?: true
    messageType?: true
    direction?: true
    status?: true
    mediaUrl?: true
    mediaType?: true
    mediaFileName?: true
    quotedMessageId?: true
    isGroupMessage?: true
    groupId?: true
    groupName?: true
    isStatusUpdate?: true
    isChannelMessage?: true
    channelId?: true
    senderName?: true
    templateId?: true
    quickReplyId?: true
    scheduledAt?: true
    sendAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    conversationId?: true
    waMessageId?: true
    content?: true
    messageType?: true
    direction?: true
    status?: true
    mediaUrl?: true
    mediaType?: true
    mediaFileName?: true
    quotedMessageId?: true
    isGroupMessage?: true
    groupId?: true
    groupName?: true
    isStatusUpdate?: true
    isChannelMessage?: true
    channelId?: true
    senderName?: true
    templateId?: true
    quickReplyId?: true
    tagIds?: true
    metadata?: true
    scheduledAt?: true
    sendAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    userId: string
    contactId: string
    conversationId: string
    waMessageId: string | null
    content: string | null
    messageType: $Enums.MessageType
    direction: $Enums.MessageDirection
    status: $Enums.MessageStatus
    mediaUrl: string | null
    mediaType: string | null
    mediaFileName: string | null
    quotedMessageId: string | null
    isGroupMessage: boolean
    groupId: string | null
    groupName: string | null
    isStatusUpdate: boolean
    isChannelMessage: boolean
    channelId: string | null
    senderName: string | null
    templateId: string | null
    quickReplyId: string | null
    tagIds: JsonValue | null
    metadata: JsonValue | null
    scheduledAt: Date | null
    sendAt: Date | null
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contactId?: boolean
    conversationId?: boolean
    waMessageId?: boolean
    content?: boolean
    messageType?: boolean
    direction?: boolean
    status?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    mediaFileName?: boolean
    quotedMessageId?: boolean
    isGroupMessage?: boolean
    groupId?: boolean
    groupName?: boolean
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: boolean
    senderName?: boolean
    templateId?: boolean
    quickReplyId?: boolean
    tagIds?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    sendAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    reactions?: boolean | Message$reactionsArgs<ExtArgs>
    notes?: boolean | Message$notesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>


  export type MessageSelectScalar = {
    id?: boolean
    userId?: boolean
    contactId?: boolean
    conversationId?: boolean
    waMessageId?: boolean
    content?: boolean
    messageType?: boolean
    direction?: boolean
    status?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    mediaFileName?: boolean
    quotedMessageId?: boolean
    isGroupMessage?: boolean
    groupId?: boolean
    groupName?: boolean
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: boolean
    senderName?: boolean
    templateId?: boolean
    quickReplyId?: boolean
    tagIds?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    sendAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    reactions?: boolean | Message$reactionsArgs<ExtArgs>
    notes?: boolean | Message$notesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
      conversation: Prisma.$ConversationPayload<ExtArgs>
      reactions: Prisma.$ReactionPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      contactId: string
      conversationId: string
      waMessageId: string | null
      content: string | null
      messageType: $Enums.MessageType
      direction: $Enums.MessageDirection
      status: $Enums.MessageStatus
      mediaUrl: string | null
      mediaType: string | null
      mediaFileName: string | null
      quotedMessageId: string | null
      isGroupMessage: boolean
      groupId: string | null
      groupName: string | null
      isStatusUpdate: boolean
      isChannelMessage: boolean
      channelId: string | null
      senderName: string | null
      templateId: string | null
      quickReplyId: string | null
      tagIds: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      scheduledAt: Date | null
      sendAt: Date | null
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reactions<T extends Message$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Message$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends Message$notesArgs<ExtArgs> = {}>(args?: Subset<T, Message$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly userId: FieldRef<"Message", 'String'>
    readonly contactId: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly waMessageId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly messageType: FieldRef<"Message", 'MessageType'>
    readonly direction: FieldRef<"Message", 'MessageDirection'>
    readonly status: FieldRef<"Message", 'MessageStatus'>
    readonly mediaUrl: FieldRef<"Message", 'String'>
    readonly mediaType: FieldRef<"Message", 'String'>
    readonly mediaFileName: FieldRef<"Message", 'String'>
    readonly quotedMessageId: FieldRef<"Message", 'String'>
    readonly isGroupMessage: FieldRef<"Message", 'Boolean'>
    readonly groupId: FieldRef<"Message", 'String'>
    readonly groupName: FieldRef<"Message", 'String'>
    readonly isStatusUpdate: FieldRef<"Message", 'Boolean'>
    readonly isChannelMessage: FieldRef<"Message", 'Boolean'>
    readonly channelId: FieldRef<"Message", 'String'>
    readonly senderName: FieldRef<"Message", 'String'>
    readonly templateId: FieldRef<"Message", 'String'>
    readonly quickReplyId: FieldRef<"Message", 'String'>
    readonly tagIds: FieldRef<"Message", 'Json'>
    readonly metadata: FieldRef<"Message", 'Json'>
    readonly scheduledAt: FieldRef<"Message", 'DateTime'>
    readonly sendAt: FieldRef<"Message", 'DateTime'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.reactions
   */
  export type Message$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Message.notes
   */
  export type Message$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Reaction
   */

  export type AggregateReaction = {
    _count: ReactionCountAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  export type ReactionMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    emoji: string | null
    createdAt: Date | null
  }

  export type ReactionMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    emoji: string | null
    createdAt: Date | null
  }

  export type ReactionCountAggregateOutputType = {
    id: number
    messageId: number
    emoji: number
    createdAt: number
    _all: number
  }


  export type ReactionMinAggregateInputType = {
    id?: true
    messageId?: true
    emoji?: true
    createdAt?: true
  }

  export type ReactionMaxAggregateInputType = {
    id?: true
    messageId?: true
    emoji?: true
    createdAt?: true
  }

  export type ReactionCountAggregateInputType = {
    id?: true
    messageId?: true
    emoji?: true
    createdAt?: true
    _all?: true
  }

  export type ReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reaction to aggregate.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reactions
    **/
    _count?: true | ReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReactionMaxAggregateInputType
  }

  export type GetReactionAggregateType<T extends ReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReaction[P]>
      : GetScalarType<T[P], AggregateReaction[P]>
  }




  export type ReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithAggregationInput | ReactionOrderByWithAggregationInput[]
    by: ReactionScalarFieldEnum[] | ReactionScalarFieldEnum
    having?: ReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReactionCountAggregateInputType | true
    _min?: ReactionMinAggregateInputType
    _max?: ReactionMaxAggregateInputType
  }

  export type ReactionGroupByOutputType = {
    id: string
    messageId: string
    emoji: string
    createdAt: Date
    _count: ReactionCountAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  type GetReactionGroupByPayload<T extends ReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReactionGroupByOutputType[P]>
            : GetScalarType<T[P], ReactionGroupByOutputType[P]>
        }
      >
    >


  export type ReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    emoji?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>


  export type ReactionSelectScalar = {
    id?: boolean
    messageId?: boolean
    emoji?: boolean
    createdAt?: boolean
  }

  export type ReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $ReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reaction"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      emoji: string
      createdAt: Date
    }, ExtArgs["result"]["reaction"]>
    composites: {}
  }

  type ReactionGetPayload<S extends boolean | null | undefined | ReactionDefaultArgs> = $Result.GetResult<Prisma.$ReactionPayload, S>

  type ReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReactionCountAggregateInputType | true
    }

  export interface ReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reaction'], meta: { name: 'Reaction' } }
    /**
     * Find zero or one Reaction that matches the filter.
     * @param {ReactionFindUniqueArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReactionFindUniqueArgs>(args: SelectSubset<T, ReactionFindUniqueArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReactionFindUniqueOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReactionFindFirstArgs>(args?: SelectSubset<T, ReactionFindFirstArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reactions
     * const reactions = await prisma.reaction.findMany()
     * 
     * // Get first 10 Reactions
     * const reactions = await prisma.reaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reactionWithIdOnly = await prisma.reaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReactionFindManyArgs>(args?: SelectSubset<T, ReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reaction.
     * @param {ReactionCreateArgs} args - Arguments to create a Reaction.
     * @example
     * // Create one Reaction
     * const Reaction = await prisma.reaction.create({
     *   data: {
     *     // ... data to create a Reaction
     *   }
     * })
     * 
     */
    create<T extends ReactionCreateArgs>(args: SelectSubset<T, ReactionCreateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reactions.
     * @param {ReactionCreateManyArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReactionCreateManyArgs>(args?: SelectSubset<T, ReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reaction.
     * @param {ReactionDeleteArgs} args - Arguments to delete one Reaction.
     * @example
     * // Delete one Reaction
     * const Reaction = await prisma.reaction.delete({
     *   where: {
     *     // ... filter to delete one Reaction
     *   }
     * })
     * 
     */
    delete<T extends ReactionDeleteArgs>(args: SelectSubset<T, ReactionDeleteArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reaction.
     * @param {ReactionUpdateArgs} args - Arguments to update one Reaction.
     * @example
     * // Update one Reaction
     * const reaction = await prisma.reaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReactionUpdateArgs>(args: SelectSubset<T, ReactionUpdateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reactions.
     * @param {ReactionDeleteManyArgs} args - Arguments to filter Reactions to delete.
     * @example
     * // Delete a few Reactions
     * const { count } = await prisma.reaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReactionDeleteManyArgs>(args?: SelectSubset<T, ReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reactions
     * const reaction = await prisma.reaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReactionUpdateManyArgs>(args: SelectSubset<T, ReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reaction.
     * @param {ReactionUpsertArgs} args - Arguments to update or create a Reaction.
     * @example
     * // Update or create a Reaction
     * const reaction = await prisma.reaction.upsert({
     *   create: {
     *     // ... data to create a Reaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reaction we want to update
     *   }
     * })
     */
    upsert<T extends ReactionUpsertArgs>(args: SelectSubset<T, ReactionUpsertArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionCountArgs} args - Arguments to filter Reactions to count.
     * @example
     * // Count the number of Reactions
     * const count = await prisma.reaction.count({
     *   where: {
     *     // ... the filter for the Reactions we want to count
     *   }
     * })
    **/
    count<T extends ReactionCountArgs>(
      args?: Subset<T, ReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReactionAggregateArgs>(args: Subset<T, ReactionAggregateArgs>): Prisma.PrismaPromise<GetReactionAggregateType<T>>

    /**
     * Group by Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReactionGroupByArgs['orderBy'] }
        : { orderBy?: ReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reaction model
   */
  readonly fields: ReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reaction model
   */ 
  interface ReactionFieldRefs {
    readonly id: FieldRef<"Reaction", 'String'>
    readonly messageId: FieldRef<"Reaction", 'String'>
    readonly emoji: FieldRef<"Reaction", 'String'>
    readonly createdAt: FieldRef<"Reaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reaction findUnique
   */
  export type ReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findUniqueOrThrow
   */
  export type ReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findFirst
   */
  export type ReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findFirstOrThrow
   */
  export type ReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findMany
   */
  export type ReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reactions to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction create
   */
  export type ReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Reaction.
     */
    data: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
  }

  /**
   * Reaction createMany
   */
  export type ReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reaction update
   */
  export type ReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Reaction.
     */
    data: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
    /**
     * Choose, which Reaction to update.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction updateMany
   */
  export type ReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reactions.
     */
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyInput>
    /**
     * Filter which Reactions to update
     */
    where?: ReactionWhereInput
  }

  /**
   * Reaction upsert
   */
  export type ReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Reaction to update in case it exists.
     */
    where: ReactionWhereUniqueInput
    /**
     * In case the Reaction found by the `where` argument doesn't exist, create a new Reaction with this data.
     */
    create: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
    /**
     * In case the Reaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
  }

  /**
   * Reaction delete
   */
  export type ReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter which Reaction to delete.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction deleteMany
   */
  export type ReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reactions to delete
     */
    where?: ReactionWhereInput
  }

  /**
   * Reaction without action
   */
  export type ReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    color: number
    createdAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    color?: true
    createdAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    color?: true
    createdAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    color?: true
    createdAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    userId: string
    name: string
    color: string | null
    createdAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contacts?: boolean | Tag$contactsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>


  export type TagSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contacts?: boolean | Tag$contactsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contacts: Prisma.$TagOnContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      color: string | null
      createdAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contacts<T extends Tag$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagOnContactPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly userId: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }

  /**
   * Tag.contacts
   */
  export type Tag$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
    where?: TagOnContactWhereInput
    orderBy?: TagOnContactOrderByWithRelationInput | TagOnContactOrderByWithRelationInput[]
    cursor?: TagOnContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagOnContactScalarFieldEnum | TagOnContactScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model TagOnContact
   */

  export type AggregateTagOnContact = {
    _count: TagOnContactCountAggregateOutputType | null
    _min: TagOnContactMinAggregateOutputType | null
    _max: TagOnContactMaxAggregateOutputType | null
  }

  export type TagOnContactMinAggregateOutputType = {
    contactId: string | null
    tagId: string | null
    assignedAt: Date | null
  }

  export type TagOnContactMaxAggregateOutputType = {
    contactId: string | null
    tagId: string | null
    assignedAt: Date | null
  }

  export type TagOnContactCountAggregateOutputType = {
    contactId: number
    tagId: number
    assignedAt: number
    _all: number
  }


  export type TagOnContactMinAggregateInputType = {
    contactId?: true
    tagId?: true
    assignedAt?: true
  }

  export type TagOnContactMaxAggregateInputType = {
    contactId?: true
    tagId?: true
    assignedAt?: true
  }

  export type TagOnContactCountAggregateInputType = {
    contactId?: true
    tagId?: true
    assignedAt?: true
    _all?: true
  }

  export type TagOnContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagOnContact to aggregate.
     */
    where?: TagOnContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagOnContacts to fetch.
     */
    orderBy?: TagOnContactOrderByWithRelationInput | TagOnContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagOnContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagOnContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagOnContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagOnContacts
    **/
    _count?: true | TagOnContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagOnContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagOnContactMaxAggregateInputType
  }

  export type GetTagOnContactAggregateType<T extends TagOnContactAggregateArgs> = {
        [P in keyof T & keyof AggregateTagOnContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagOnContact[P]>
      : GetScalarType<T[P], AggregateTagOnContact[P]>
  }




  export type TagOnContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagOnContactWhereInput
    orderBy?: TagOnContactOrderByWithAggregationInput | TagOnContactOrderByWithAggregationInput[]
    by: TagOnContactScalarFieldEnum[] | TagOnContactScalarFieldEnum
    having?: TagOnContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagOnContactCountAggregateInputType | true
    _min?: TagOnContactMinAggregateInputType
    _max?: TagOnContactMaxAggregateInputType
  }

  export type TagOnContactGroupByOutputType = {
    contactId: string
    tagId: string
    assignedAt: Date
    _count: TagOnContactCountAggregateOutputType | null
    _min: TagOnContactMinAggregateOutputType | null
    _max: TagOnContactMaxAggregateOutputType | null
  }

  type GetTagOnContactGroupByPayload<T extends TagOnContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagOnContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagOnContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagOnContactGroupByOutputType[P]>
            : GetScalarType<T[P], TagOnContactGroupByOutputType[P]>
        }
      >
    >


  export type TagOnContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    tagId?: boolean
    assignedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagOnContact"]>


  export type TagOnContactSelectScalar = {
    contactId?: boolean
    tagId?: boolean
    assignedAt?: boolean
  }

  export type TagOnContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $TagOnContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TagOnContact"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contactId: string
      tagId: string
      assignedAt: Date
    }, ExtArgs["result"]["tagOnContact"]>
    composites: {}
  }

  type TagOnContactGetPayload<S extends boolean | null | undefined | TagOnContactDefaultArgs> = $Result.GetResult<Prisma.$TagOnContactPayload, S>

  type TagOnContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagOnContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagOnContactCountAggregateInputType | true
    }

  export interface TagOnContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TagOnContact'], meta: { name: 'TagOnContact' } }
    /**
     * Find zero or one TagOnContact that matches the filter.
     * @param {TagOnContactFindUniqueArgs} args - Arguments to find a TagOnContact
     * @example
     * // Get one TagOnContact
     * const tagOnContact = await prisma.tagOnContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagOnContactFindUniqueArgs>(args: SelectSubset<T, TagOnContactFindUniqueArgs<ExtArgs>>): Prisma__TagOnContactClient<$Result.GetResult<Prisma.$TagOnContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TagOnContact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagOnContactFindUniqueOrThrowArgs} args - Arguments to find a TagOnContact
     * @example
     * // Get one TagOnContact
     * const tagOnContact = await prisma.tagOnContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagOnContactFindUniqueOrThrowArgs>(args: SelectSubset<T, TagOnContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagOnContactClient<$Result.GetResult<Prisma.$TagOnContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TagOnContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnContactFindFirstArgs} args - Arguments to find a TagOnContact
     * @example
     * // Get one TagOnContact
     * const tagOnContact = await prisma.tagOnContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagOnContactFindFirstArgs>(args?: SelectSubset<T, TagOnContactFindFirstArgs<ExtArgs>>): Prisma__TagOnContactClient<$Result.GetResult<Prisma.$TagOnContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TagOnContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnContactFindFirstOrThrowArgs} args - Arguments to find a TagOnContact
     * @example
     * // Get one TagOnContact
     * const tagOnContact = await prisma.tagOnContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagOnContactFindFirstOrThrowArgs>(args?: SelectSubset<T, TagOnContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagOnContactClient<$Result.GetResult<Prisma.$TagOnContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TagOnContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagOnContacts
     * const tagOnContacts = await prisma.tagOnContact.findMany()
     * 
     * // Get first 10 TagOnContacts
     * const tagOnContacts = await prisma.tagOnContact.findMany({ take: 10 })
     * 
     * // Only select the `contactId`
     * const tagOnContactWithContactIdOnly = await prisma.tagOnContact.findMany({ select: { contactId: true } })
     * 
     */
    findMany<T extends TagOnContactFindManyArgs>(args?: SelectSubset<T, TagOnContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagOnContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TagOnContact.
     * @param {TagOnContactCreateArgs} args - Arguments to create a TagOnContact.
     * @example
     * // Create one TagOnContact
     * const TagOnContact = await prisma.tagOnContact.create({
     *   data: {
     *     // ... data to create a TagOnContact
     *   }
     * })
     * 
     */
    create<T extends TagOnContactCreateArgs>(args: SelectSubset<T, TagOnContactCreateArgs<ExtArgs>>): Prisma__TagOnContactClient<$Result.GetResult<Prisma.$TagOnContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TagOnContacts.
     * @param {TagOnContactCreateManyArgs} args - Arguments to create many TagOnContacts.
     * @example
     * // Create many TagOnContacts
     * const tagOnContact = await prisma.tagOnContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagOnContactCreateManyArgs>(args?: SelectSubset<T, TagOnContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TagOnContact.
     * @param {TagOnContactDeleteArgs} args - Arguments to delete one TagOnContact.
     * @example
     * // Delete one TagOnContact
     * const TagOnContact = await prisma.tagOnContact.delete({
     *   where: {
     *     // ... filter to delete one TagOnContact
     *   }
     * })
     * 
     */
    delete<T extends TagOnContactDeleteArgs>(args: SelectSubset<T, TagOnContactDeleteArgs<ExtArgs>>): Prisma__TagOnContactClient<$Result.GetResult<Prisma.$TagOnContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TagOnContact.
     * @param {TagOnContactUpdateArgs} args - Arguments to update one TagOnContact.
     * @example
     * // Update one TagOnContact
     * const tagOnContact = await prisma.tagOnContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagOnContactUpdateArgs>(args: SelectSubset<T, TagOnContactUpdateArgs<ExtArgs>>): Prisma__TagOnContactClient<$Result.GetResult<Prisma.$TagOnContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TagOnContacts.
     * @param {TagOnContactDeleteManyArgs} args - Arguments to filter TagOnContacts to delete.
     * @example
     * // Delete a few TagOnContacts
     * const { count } = await prisma.tagOnContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagOnContactDeleteManyArgs>(args?: SelectSubset<T, TagOnContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagOnContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagOnContacts
     * const tagOnContact = await prisma.tagOnContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagOnContactUpdateManyArgs>(args: SelectSubset<T, TagOnContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TagOnContact.
     * @param {TagOnContactUpsertArgs} args - Arguments to update or create a TagOnContact.
     * @example
     * // Update or create a TagOnContact
     * const tagOnContact = await prisma.tagOnContact.upsert({
     *   create: {
     *     // ... data to create a TagOnContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagOnContact we want to update
     *   }
     * })
     */
    upsert<T extends TagOnContactUpsertArgs>(args: SelectSubset<T, TagOnContactUpsertArgs<ExtArgs>>): Prisma__TagOnContactClient<$Result.GetResult<Prisma.$TagOnContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TagOnContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnContactCountArgs} args - Arguments to filter TagOnContacts to count.
     * @example
     * // Count the number of TagOnContacts
     * const count = await prisma.tagOnContact.count({
     *   where: {
     *     // ... the filter for the TagOnContacts we want to count
     *   }
     * })
    **/
    count<T extends TagOnContactCountArgs>(
      args?: Subset<T, TagOnContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagOnContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagOnContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagOnContactAggregateArgs>(args: Subset<T, TagOnContactAggregateArgs>): Prisma.PrismaPromise<GetTagOnContactAggregateType<T>>

    /**
     * Group by TagOnContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagOnContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagOnContactGroupByArgs['orderBy'] }
        : { orderBy?: TagOnContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagOnContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagOnContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TagOnContact model
   */
  readonly fields: TagOnContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TagOnContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagOnContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TagOnContact model
   */ 
  interface TagOnContactFieldRefs {
    readonly contactId: FieldRef<"TagOnContact", 'String'>
    readonly tagId: FieldRef<"TagOnContact", 'String'>
    readonly assignedAt: FieldRef<"TagOnContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TagOnContact findUnique
   */
  export type TagOnContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
    /**
     * Filter, which TagOnContact to fetch.
     */
    where: TagOnContactWhereUniqueInput
  }

  /**
   * TagOnContact findUniqueOrThrow
   */
  export type TagOnContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
    /**
     * Filter, which TagOnContact to fetch.
     */
    where: TagOnContactWhereUniqueInput
  }

  /**
   * TagOnContact findFirst
   */
  export type TagOnContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
    /**
     * Filter, which TagOnContact to fetch.
     */
    where?: TagOnContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagOnContacts to fetch.
     */
    orderBy?: TagOnContactOrderByWithRelationInput | TagOnContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagOnContacts.
     */
    cursor?: TagOnContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagOnContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagOnContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagOnContacts.
     */
    distinct?: TagOnContactScalarFieldEnum | TagOnContactScalarFieldEnum[]
  }

  /**
   * TagOnContact findFirstOrThrow
   */
  export type TagOnContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
    /**
     * Filter, which TagOnContact to fetch.
     */
    where?: TagOnContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagOnContacts to fetch.
     */
    orderBy?: TagOnContactOrderByWithRelationInput | TagOnContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagOnContacts.
     */
    cursor?: TagOnContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagOnContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagOnContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagOnContacts.
     */
    distinct?: TagOnContactScalarFieldEnum | TagOnContactScalarFieldEnum[]
  }

  /**
   * TagOnContact findMany
   */
  export type TagOnContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
    /**
     * Filter, which TagOnContacts to fetch.
     */
    where?: TagOnContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagOnContacts to fetch.
     */
    orderBy?: TagOnContactOrderByWithRelationInput | TagOnContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagOnContacts.
     */
    cursor?: TagOnContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagOnContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagOnContacts.
     */
    skip?: number
    distinct?: TagOnContactScalarFieldEnum | TagOnContactScalarFieldEnum[]
  }

  /**
   * TagOnContact create
   */
  export type TagOnContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
    /**
     * The data needed to create a TagOnContact.
     */
    data: XOR<TagOnContactCreateInput, TagOnContactUncheckedCreateInput>
  }

  /**
   * TagOnContact createMany
   */
  export type TagOnContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TagOnContacts.
     */
    data: TagOnContactCreateManyInput | TagOnContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TagOnContact update
   */
  export type TagOnContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
    /**
     * The data needed to update a TagOnContact.
     */
    data: XOR<TagOnContactUpdateInput, TagOnContactUncheckedUpdateInput>
    /**
     * Choose, which TagOnContact to update.
     */
    where: TagOnContactWhereUniqueInput
  }

  /**
   * TagOnContact updateMany
   */
  export type TagOnContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TagOnContacts.
     */
    data: XOR<TagOnContactUpdateManyMutationInput, TagOnContactUncheckedUpdateManyInput>
    /**
     * Filter which TagOnContacts to update
     */
    where?: TagOnContactWhereInput
  }

  /**
   * TagOnContact upsert
   */
  export type TagOnContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
    /**
     * The filter to search for the TagOnContact to update in case it exists.
     */
    where: TagOnContactWhereUniqueInput
    /**
     * In case the TagOnContact found by the `where` argument doesn't exist, create a new TagOnContact with this data.
     */
    create: XOR<TagOnContactCreateInput, TagOnContactUncheckedCreateInput>
    /**
     * In case the TagOnContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagOnContactUpdateInput, TagOnContactUncheckedUpdateInput>
  }

  /**
   * TagOnContact delete
   */
  export type TagOnContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
    /**
     * Filter which TagOnContact to delete.
     */
    where: TagOnContactWhereUniqueInput
  }

  /**
   * TagOnContact deleteMany
   */
  export type TagOnContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagOnContacts to delete
     */
    where?: TagOnContactWhereInput
  }

  /**
   * TagOnContact without action
   */
  export type TagOnContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnContact
     */
    select?: TagOnContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnContactInclude<ExtArgs> | null
  }


  /**
   * Model Segment
   */

  export type AggregateSegment = {
    _count: SegmentCountAggregateOutputType | null
    _min: SegmentMinAggregateOutputType | null
    _max: SegmentMaxAggregateOutputType | null
  }

  export type SegmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SegmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SegmentCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    criteria: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SegmentMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SegmentMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SegmentCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    criteria?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Segment to aggregate.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Segments
    **/
    _count?: true | SegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SegmentMaxAggregateInputType
  }

  export type GetSegmentAggregateType<T extends SegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSegment[P]>
      : GetScalarType<T[P], AggregateSegment[P]>
  }




  export type SegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentWhereInput
    orderBy?: SegmentOrderByWithAggregationInput | SegmentOrderByWithAggregationInput[]
    by: SegmentScalarFieldEnum[] | SegmentScalarFieldEnum
    having?: SegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SegmentCountAggregateInputType | true
    _min?: SegmentMinAggregateInputType
    _max?: SegmentMaxAggregateInputType
  }

  export type SegmentGroupByOutputType = {
    id: string
    userId: string
    name: string
    criteria: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SegmentCountAggregateOutputType | null
    _min: SegmentMinAggregateOutputType | null
    _max: SegmentMaxAggregateOutputType | null
  }

  type GetSegmentGroupByPayload<T extends SegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SegmentGroupByOutputType[P]>
            : GetScalarType<T[P], SegmentGroupByOutputType[P]>
        }
      >
    >


  export type SegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    criteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segment"]>


  export type SegmentSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    criteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Segment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      criteria: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["segment"]>
    composites: {}
  }

  type SegmentGetPayload<S extends boolean | null | undefined | SegmentDefaultArgs> = $Result.GetResult<Prisma.$SegmentPayload, S>

  type SegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SegmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SegmentCountAggregateInputType | true
    }

  export interface SegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Segment'], meta: { name: 'Segment' } }
    /**
     * Find zero or one Segment that matches the filter.
     * @param {SegmentFindUniqueArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SegmentFindUniqueArgs>(args: SelectSubset<T, SegmentFindUniqueArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Segment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SegmentFindUniqueOrThrowArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, SegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Segment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindFirstArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SegmentFindFirstArgs>(args?: SelectSubset<T, SegmentFindFirstArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Segment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindFirstOrThrowArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, SegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Segments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Segments
     * const segments = await prisma.segment.findMany()
     * 
     * // Get first 10 Segments
     * const segments = await prisma.segment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const segmentWithIdOnly = await prisma.segment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SegmentFindManyArgs>(args?: SelectSubset<T, SegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Segment.
     * @param {SegmentCreateArgs} args - Arguments to create a Segment.
     * @example
     * // Create one Segment
     * const Segment = await prisma.segment.create({
     *   data: {
     *     // ... data to create a Segment
     *   }
     * })
     * 
     */
    create<T extends SegmentCreateArgs>(args: SelectSubset<T, SegmentCreateArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Segments.
     * @param {SegmentCreateManyArgs} args - Arguments to create many Segments.
     * @example
     * // Create many Segments
     * const segment = await prisma.segment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SegmentCreateManyArgs>(args?: SelectSubset<T, SegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Segment.
     * @param {SegmentDeleteArgs} args - Arguments to delete one Segment.
     * @example
     * // Delete one Segment
     * const Segment = await prisma.segment.delete({
     *   where: {
     *     // ... filter to delete one Segment
     *   }
     * })
     * 
     */
    delete<T extends SegmentDeleteArgs>(args: SelectSubset<T, SegmentDeleteArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Segment.
     * @param {SegmentUpdateArgs} args - Arguments to update one Segment.
     * @example
     * // Update one Segment
     * const segment = await prisma.segment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SegmentUpdateArgs>(args: SelectSubset<T, SegmentUpdateArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Segments.
     * @param {SegmentDeleteManyArgs} args - Arguments to filter Segments to delete.
     * @example
     * // Delete a few Segments
     * const { count } = await prisma.segment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SegmentDeleteManyArgs>(args?: SelectSubset<T, SegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Segments
     * const segment = await prisma.segment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SegmentUpdateManyArgs>(args: SelectSubset<T, SegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Segment.
     * @param {SegmentUpsertArgs} args - Arguments to update or create a Segment.
     * @example
     * // Update or create a Segment
     * const segment = await prisma.segment.upsert({
     *   create: {
     *     // ... data to create a Segment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Segment we want to update
     *   }
     * })
     */
    upsert<T extends SegmentUpsertArgs>(args: SelectSubset<T, SegmentUpsertArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentCountArgs} args - Arguments to filter Segments to count.
     * @example
     * // Count the number of Segments
     * const count = await prisma.segment.count({
     *   where: {
     *     // ... the filter for the Segments we want to count
     *   }
     * })
    **/
    count<T extends SegmentCountArgs>(
      args?: Subset<T, SegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Segment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SegmentAggregateArgs>(args: Subset<T, SegmentAggregateArgs>): Prisma.PrismaPromise<GetSegmentAggregateType<T>>

    /**
     * Group by Segment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SegmentGroupByArgs['orderBy'] }
        : { orderBy?: SegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Segment model
   */
  readonly fields: SegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Segment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Segment model
   */ 
  interface SegmentFieldRefs {
    readonly id: FieldRef<"Segment", 'String'>
    readonly userId: FieldRef<"Segment", 'String'>
    readonly name: FieldRef<"Segment", 'String'>
    readonly criteria: FieldRef<"Segment", 'Json'>
    readonly createdAt: FieldRef<"Segment", 'DateTime'>
    readonly updatedAt: FieldRef<"Segment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Segment findUnique
   */
  export type SegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment findUniqueOrThrow
   */
  export type SegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment findFirst
   */
  export type SegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Segments.
     */
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment findFirstOrThrow
   */
  export type SegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Segments.
     */
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment findMany
   */
  export type SegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segments to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment create
   */
  export type SegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Segment.
     */
    data: XOR<SegmentCreateInput, SegmentUncheckedCreateInput>
  }

  /**
   * Segment createMany
   */
  export type SegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Segments.
     */
    data: SegmentCreateManyInput | SegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Segment update
   */
  export type SegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Segment.
     */
    data: XOR<SegmentUpdateInput, SegmentUncheckedUpdateInput>
    /**
     * Choose, which Segment to update.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment updateMany
   */
  export type SegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Segments.
     */
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyInput>
    /**
     * Filter which Segments to update
     */
    where?: SegmentWhereInput
  }

  /**
   * Segment upsert
   */
  export type SegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Segment to update in case it exists.
     */
    where: SegmentWhereUniqueInput
    /**
     * In case the Segment found by the `where` argument doesn't exist, create a new Segment with this data.
     */
    create: XOR<SegmentCreateInput, SegmentUncheckedCreateInput>
    /**
     * In case the Segment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SegmentUpdateInput, SegmentUncheckedUpdateInput>
  }

  /**
   * Segment delete
   */
  export type SegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter which Segment to delete.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment deleteMany
   */
  export type SegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Segments to delete
     */
    where?: SegmentWhereInput
  }

  /**
   * Segment without action
   */
  export type SegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    recipientCount: number | null
    sentCount: number | null
    failedCount: number | null
  }

  export type CampaignSumAggregateOutputType = {
    recipientCount: number | null
    sentCount: number | null
    failedCount: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.CampaignType | null
    status: $Enums.CampaignStatus | null
    templateId: string | null
    content: string | null
    mediaUrl: string | null
    scheduleTime: Date | null
    sentAt: Date | null
    completedAt: Date | null
    recipientCount: number | null
    sentCount: number | null
    failedCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.CampaignType | null
    status: $Enums.CampaignStatus | null
    templateId: string | null
    content: string | null
    mediaUrl: string | null
    scheduleTime: Date | null
    sentAt: Date | null
    completedAt: Date | null
    recipientCount: number | null
    sentCount: number | null
    failedCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    templateId: number
    content: number
    mediaUrl: number
    scheduleTime: number
    sentAt: number
    completedAt: number
    recipientCount: number
    sentCount: number
    failedCount: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    recipientCount?: true
    sentCount?: true
    failedCount?: true
  }

  export type CampaignSumAggregateInputType = {
    recipientCount?: true
    sentCount?: true
    failedCount?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    templateId?: true
    content?: true
    mediaUrl?: true
    scheduleTime?: true
    sentAt?: true
    completedAt?: true
    recipientCount?: true
    sentCount?: true
    failedCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    templateId?: true
    content?: true
    mediaUrl?: true
    scheduleTime?: true
    sentAt?: true
    completedAt?: true
    recipientCount?: true
    sentCount?: true
    failedCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    templateId?: true
    content?: true
    mediaUrl?: true
    scheduleTime?: true
    sentAt?: true
    completedAt?: true
    recipientCount?: true
    sentCount?: true
    failedCount?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    type: $Enums.CampaignType
    status: $Enums.CampaignStatus
    templateId: string | null
    content: string | null
    mediaUrl: string | null
    scheduleTime: Date | null
    sentAt: Date | null
    completedAt: Date | null
    recipientCount: number
    sentCount: number
    failedCount: number
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    templateId?: boolean
    content?: boolean
    mediaUrl?: boolean
    scheduleTime?: boolean
    sentAt?: boolean
    completedAt?: boolean
    recipientCount?: boolean
    sentCount?: boolean
    failedCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["campaign"]>


  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    templateId?: boolean
    content?: boolean
    mediaUrl?: boolean
    scheduleTime?: boolean
    sentAt?: boolean
    completedAt?: boolean
    recipientCount?: boolean
    sentCount?: boolean
    failedCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.CampaignType
      status: $Enums.CampaignStatus
      templateId: string | null
      content: string | null
      mediaUrl: string | null
      scheduleTime: Date | null
      sentAt: Date | null
      completedAt: Date | null
      recipientCount: number
      sentCount: number
      failedCount: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly type: FieldRef<"Campaign", 'CampaignType'>
    readonly status: FieldRef<"Campaign", 'CampaignStatus'>
    readonly templateId: FieldRef<"Campaign", 'String'>
    readonly content: FieldRef<"Campaign", 'String'>
    readonly mediaUrl: FieldRef<"Campaign", 'String'>
    readonly scheduleTime: FieldRef<"Campaign", 'DateTime'>
    readonly sentAt: FieldRef<"Campaign", 'DateTime'>
    readonly completedAt: FieldRef<"Campaign", 'DateTime'>
    readonly recipientCount: FieldRef<"Campaign", 'Int'>
    readonly sentCount: FieldRef<"Campaign", 'Int'>
    readonly failedCount: FieldRef<"Campaign", 'Int'>
    readonly metadata: FieldRef<"Campaign", 'Json'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
  }


  /**
   * Model QuickReply
   */

  export type AggregateQuickReply = {
    _count: QuickReplyCountAggregateOutputType | null
    _avg: QuickReplyAvgAggregateOutputType | null
    _sum: QuickReplySumAggregateOutputType | null
    _min: QuickReplyMinAggregateOutputType | null
    _max: QuickReplyMaxAggregateOutputType | null
  }

  export type QuickReplyAvgAggregateOutputType = {
    usageCount: number | null
    usageTodayCount: number | null
  }

  export type QuickReplySumAggregateOutputType = {
    usageCount: number | null
    usageTodayCount: number | null
  }

  export type QuickReplyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    category: string | null
    shortcut: string | null
    isActive: boolean | null
    usageCount: number | null
    usageTodayCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuickReplyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    category: string | null
    shortcut: string | null
    isActive: boolean | null
    usageCount: number | null
    usageTodayCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuickReplyCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    category: number
    shortcut: number
    isActive: number
    usageCount: number
    usageTodayCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuickReplyAvgAggregateInputType = {
    usageCount?: true
    usageTodayCount?: true
  }

  export type QuickReplySumAggregateInputType = {
    usageCount?: true
    usageTodayCount?: true
  }

  export type QuickReplyMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    shortcut?: true
    isActive?: true
    usageCount?: true
    usageTodayCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuickReplyMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    shortcut?: true
    isActive?: true
    usageCount?: true
    usageTodayCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuickReplyCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    shortcut?: true
    isActive?: true
    usageCount?: true
    usageTodayCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuickReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuickReply to aggregate.
     */
    where?: QuickReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickReplies to fetch.
     */
    orderBy?: QuickReplyOrderByWithRelationInput | QuickReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuickReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuickReplies
    **/
    _count?: true | QuickReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuickReplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuickReplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuickReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuickReplyMaxAggregateInputType
  }

  export type GetQuickReplyAggregateType<T extends QuickReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateQuickReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuickReply[P]>
      : GetScalarType<T[P], AggregateQuickReply[P]>
  }




  export type QuickReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuickReplyWhereInput
    orderBy?: QuickReplyOrderByWithAggregationInput | QuickReplyOrderByWithAggregationInput[]
    by: QuickReplyScalarFieldEnum[] | QuickReplyScalarFieldEnum
    having?: QuickReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuickReplyCountAggregateInputType | true
    _avg?: QuickReplyAvgAggregateInputType
    _sum?: QuickReplySumAggregateInputType
    _min?: QuickReplyMinAggregateInputType
    _max?: QuickReplyMaxAggregateInputType
  }

  export type QuickReplyGroupByOutputType = {
    id: string
    userId: string
    title: string
    content: string
    category: string | null
    shortcut: string | null
    isActive: boolean
    usageCount: number
    usageTodayCount: number
    createdAt: Date
    updatedAt: Date
    _count: QuickReplyCountAggregateOutputType | null
    _avg: QuickReplyAvgAggregateOutputType | null
    _sum: QuickReplySumAggregateOutputType | null
    _min: QuickReplyMinAggregateOutputType | null
    _max: QuickReplyMaxAggregateOutputType | null
  }

  type GetQuickReplyGroupByPayload<T extends QuickReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuickReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuickReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuickReplyGroupByOutputType[P]>
            : GetScalarType<T[P], QuickReplyGroupByOutputType[P]>
        }
      >
    >


  export type QuickReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    shortcut?: boolean
    isActive?: boolean
    usageCount?: boolean
    usageTodayCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quickReply"]>


  export type QuickReplySelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    shortcut?: boolean
    isActive?: boolean
    usageCount?: boolean
    usageTodayCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuickReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuickReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuickReply"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      content: string
      category: string | null
      shortcut: string | null
      isActive: boolean
      usageCount: number
      usageTodayCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quickReply"]>
    composites: {}
  }

  type QuickReplyGetPayload<S extends boolean | null | undefined | QuickReplyDefaultArgs> = $Result.GetResult<Prisma.$QuickReplyPayload, S>

  type QuickReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuickReplyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuickReplyCountAggregateInputType | true
    }

  export interface QuickReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuickReply'], meta: { name: 'QuickReply' } }
    /**
     * Find zero or one QuickReply that matches the filter.
     * @param {QuickReplyFindUniqueArgs} args - Arguments to find a QuickReply
     * @example
     * // Get one QuickReply
     * const quickReply = await prisma.quickReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuickReplyFindUniqueArgs>(args: SelectSubset<T, QuickReplyFindUniqueArgs<ExtArgs>>): Prisma__QuickReplyClient<$Result.GetResult<Prisma.$QuickReplyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuickReply that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuickReplyFindUniqueOrThrowArgs} args - Arguments to find a QuickReply
     * @example
     * // Get one QuickReply
     * const quickReply = await prisma.quickReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuickReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, QuickReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuickReplyClient<$Result.GetResult<Prisma.$QuickReplyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuickReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickReplyFindFirstArgs} args - Arguments to find a QuickReply
     * @example
     * // Get one QuickReply
     * const quickReply = await prisma.quickReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuickReplyFindFirstArgs>(args?: SelectSubset<T, QuickReplyFindFirstArgs<ExtArgs>>): Prisma__QuickReplyClient<$Result.GetResult<Prisma.$QuickReplyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuickReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickReplyFindFirstOrThrowArgs} args - Arguments to find a QuickReply
     * @example
     * // Get one QuickReply
     * const quickReply = await prisma.quickReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuickReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, QuickReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuickReplyClient<$Result.GetResult<Prisma.$QuickReplyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuickReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuickReplies
     * const quickReplies = await prisma.quickReply.findMany()
     * 
     * // Get first 10 QuickReplies
     * const quickReplies = await prisma.quickReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quickReplyWithIdOnly = await prisma.quickReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuickReplyFindManyArgs>(args?: SelectSubset<T, QuickReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickReplyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuickReply.
     * @param {QuickReplyCreateArgs} args - Arguments to create a QuickReply.
     * @example
     * // Create one QuickReply
     * const QuickReply = await prisma.quickReply.create({
     *   data: {
     *     // ... data to create a QuickReply
     *   }
     * })
     * 
     */
    create<T extends QuickReplyCreateArgs>(args: SelectSubset<T, QuickReplyCreateArgs<ExtArgs>>): Prisma__QuickReplyClient<$Result.GetResult<Prisma.$QuickReplyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuickReplies.
     * @param {QuickReplyCreateManyArgs} args - Arguments to create many QuickReplies.
     * @example
     * // Create many QuickReplies
     * const quickReply = await prisma.quickReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuickReplyCreateManyArgs>(args?: SelectSubset<T, QuickReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuickReply.
     * @param {QuickReplyDeleteArgs} args - Arguments to delete one QuickReply.
     * @example
     * // Delete one QuickReply
     * const QuickReply = await prisma.quickReply.delete({
     *   where: {
     *     // ... filter to delete one QuickReply
     *   }
     * })
     * 
     */
    delete<T extends QuickReplyDeleteArgs>(args: SelectSubset<T, QuickReplyDeleteArgs<ExtArgs>>): Prisma__QuickReplyClient<$Result.GetResult<Prisma.$QuickReplyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuickReply.
     * @param {QuickReplyUpdateArgs} args - Arguments to update one QuickReply.
     * @example
     * // Update one QuickReply
     * const quickReply = await prisma.quickReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuickReplyUpdateArgs>(args: SelectSubset<T, QuickReplyUpdateArgs<ExtArgs>>): Prisma__QuickReplyClient<$Result.GetResult<Prisma.$QuickReplyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuickReplies.
     * @param {QuickReplyDeleteManyArgs} args - Arguments to filter QuickReplies to delete.
     * @example
     * // Delete a few QuickReplies
     * const { count } = await prisma.quickReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuickReplyDeleteManyArgs>(args?: SelectSubset<T, QuickReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuickReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuickReplies
     * const quickReply = await prisma.quickReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuickReplyUpdateManyArgs>(args: SelectSubset<T, QuickReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuickReply.
     * @param {QuickReplyUpsertArgs} args - Arguments to update or create a QuickReply.
     * @example
     * // Update or create a QuickReply
     * const quickReply = await prisma.quickReply.upsert({
     *   create: {
     *     // ... data to create a QuickReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuickReply we want to update
     *   }
     * })
     */
    upsert<T extends QuickReplyUpsertArgs>(args: SelectSubset<T, QuickReplyUpsertArgs<ExtArgs>>): Prisma__QuickReplyClient<$Result.GetResult<Prisma.$QuickReplyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuickReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickReplyCountArgs} args - Arguments to filter QuickReplies to count.
     * @example
     * // Count the number of QuickReplies
     * const count = await prisma.quickReply.count({
     *   where: {
     *     // ... the filter for the QuickReplies we want to count
     *   }
     * })
    **/
    count<T extends QuickReplyCountArgs>(
      args?: Subset<T, QuickReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuickReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuickReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuickReplyAggregateArgs>(args: Subset<T, QuickReplyAggregateArgs>): Prisma.PrismaPromise<GetQuickReplyAggregateType<T>>

    /**
     * Group by QuickReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuickReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuickReplyGroupByArgs['orderBy'] }
        : { orderBy?: QuickReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuickReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuickReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuickReply model
   */
  readonly fields: QuickReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuickReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuickReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuickReply model
   */ 
  interface QuickReplyFieldRefs {
    readonly id: FieldRef<"QuickReply", 'String'>
    readonly userId: FieldRef<"QuickReply", 'String'>
    readonly title: FieldRef<"QuickReply", 'String'>
    readonly content: FieldRef<"QuickReply", 'String'>
    readonly category: FieldRef<"QuickReply", 'String'>
    readonly shortcut: FieldRef<"QuickReply", 'String'>
    readonly isActive: FieldRef<"QuickReply", 'Boolean'>
    readonly usageCount: FieldRef<"QuickReply", 'Int'>
    readonly usageTodayCount: FieldRef<"QuickReply", 'Int'>
    readonly createdAt: FieldRef<"QuickReply", 'DateTime'>
    readonly updatedAt: FieldRef<"QuickReply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuickReply findUnique
   */
  export type QuickReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickReply
     */
    select?: QuickReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickReplyInclude<ExtArgs> | null
    /**
     * Filter, which QuickReply to fetch.
     */
    where: QuickReplyWhereUniqueInput
  }

  /**
   * QuickReply findUniqueOrThrow
   */
  export type QuickReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickReply
     */
    select?: QuickReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickReplyInclude<ExtArgs> | null
    /**
     * Filter, which QuickReply to fetch.
     */
    where: QuickReplyWhereUniqueInput
  }

  /**
   * QuickReply findFirst
   */
  export type QuickReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickReply
     */
    select?: QuickReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickReplyInclude<ExtArgs> | null
    /**
     * Filter, which QuickReply to fetch.
     */
    where?: QuickReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickReplies to fetch.
     */
    orderBy?: QuickReplyOrderByWithRelationInput | QuickReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuickReplies.
     */
    cursor?: QuickReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuickReplies.
     */
    distinct?: QuickReplyScalarFieldEnum | QuickReplyScalarFieldEnum[]
  }

  /**
   * QuickReply findFirstOrThrow
   */
  export type QuickReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickReply
     */
    select?: QuickReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickReplyInclude<ExtArgs> | null
    /**
     * Filter, which QuickReply to fetch.
     */
    where?: QuickReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickReplies to fetch.
     */
    orderBy?: QuickReplyOrderByWithRelationInput | QuickReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuickReplies.
     */
    cursor?: QuickReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuickReplies.
     */
    distinct?: QuickReplyScalarFieldEnum | QuickReplyScalarFieldEnum[]
  }

  /**
   * QuickReply findMany
   */
  export type QuickReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickReply
     */
    select?: QuickReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickReplyInclude<ExtArgs> | null
    /**
     * Filter, which QuickReplies to fetch.
     */
    where?: QuickReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickReplies to fetch.
     */
    orderBy?: QuickReplyOrderByWithRelationInput | QuickReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuickReplies.
     */
    cursor?: QuickReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickReplies.
     */
    skip?: number
    distinct?: QuickReplyScalarFieldEnum | QuickReplyScalarFieldEnum[]
  }

  /**
   * QuickReply create
   */
  export type QuickReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickReply
     */
    select?: QuickReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a QuickReply.
     */
    data: XOR<QuickReplyCreateInput, QuickReplyUncheckedCreateInput>
  }

  /**
   * QuickReply createMany
   */
  export type QuickReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuickReplies.
     */
    data: QuickReplyCreateManyInput | QuickReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuickReply update
   */
  export type QuickReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickReply
     */
    select?: QuickReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a QuickReply.
     */
    data: XOR<QuickReplyUpdateInput, QuickReplyUncheckedUpdateInput>
    /**
     * Choose, which QuickReply to update.
     */
    where: QuickReplyWhereUniqueInput
  }

  /**
   * QuickReply updateMany
   */
  export type QuickReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuickReplies.
     */
    data: XOR<QuickReplyUpdateManyMutationInput, QuickReplyUncheckedUpdateManyInput>
    /**
     * Filter which QuickReplies to update
     */
    where?: QuickReplyWhereInput
  }

  /**
   * QuickReply upsert
   */
  export type QuickReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickReply
     */
    select?: QuickReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the QuickReply to update in case it exists.
     */
    where: QuickReplyWhereUniqueInput
    /**
     * In case the QuickReply found by the `where` argument doesn't exist, create a new QuickReply with this data.
     */
    create: XOR<QuickReplyCreateInput, QuickReplyUncheckedCreateInput>
    /**
     * In case the QuickReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuickReplyUpdateInput, QuickReplyUncheckedUpdateInput>
  }

  /**
   * QuickReply delete
   */
  export type QuickReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickReply
     */
    select?: QuickReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickReplyInclude<ExtArgs> | null
    /**
     * Filter which QuickReply to delete.
     */
    where: QuickReplyWhereUniqueInput
  }

  /**
   * QuickReply deleteMany
   */
  export type QuickReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuickReplies to delete
     */
    where?: QuickReplyWhereInput
  }

  /**
   * QuickReply without action
   */
  export type QuickReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickReply
     */
    select?: QuickReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickReplyInclude<ExtArgs> | null
  }


  /**
   * Model MessageTemplate
   */

  export type AggregateMessageTemplate = {
    _count: MessageTemplateCountAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  export type MessageTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    language: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    language: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageTemplateCountAggregateOutputType = {
    id: number
    name: number
    category: number
    language: number
    content: number
    variables: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type MessageTemplateMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    language?: true
    content?: true
    createdAt?: true
  }

  export type MessageTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    language?: true
    content?: true
    createdAt?: true
  }

  export type MessageTemplateCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    language?: true
    content?: true
    variables?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type MessageTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplate to aggregate.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageTemplates
    **/
    _count?: true | MessageTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type GetMessageTemplateAggregateType<T extends MessageTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageTemplate[P]>
      : GetScalarType<T[P], AggregateMessageTemplate[P]>
  }




  export type MessageTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplateWhereInput
    orderBy?: MessageTemplateOrderByWithAggregationInput | MessageTemplateOrderByWithAggregationInput[]
    by: MessageTemplateScalarFieldEnum[] | MessageTemplateScalarFieldEnum
    having?: MessageTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageTemplateCountAggregateInputType | true
    _min?: MessageTemplateMinAggregateInputType
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type MessageTemplateGroupByOutputType = {
    id: string
    name: string
    category: string
    language: string
    content: string
    variables: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    _count: MessageTemplateCountAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  type GetMessageTemplateGroupByPayload<T extends MessageTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
        }
      >
    >


  export type MessageTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    language?: boolean
    content?: boolean
    variables?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["messageTemplate"]>


  export type MessageTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    language?: boolean
    content?: boolean
    variables?: boolean
    metadata?: boolean
    createdAt?: boolean
  }


  export type $MessageTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      language: string
      content: string
      variables: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["messageTemplate"]>
    composites: {}
  }

  type MessageTemplateGetPayload<S extends boolean | null | undefined | MessageTemplateDefaultArgs> = $Result.GetResult<Prisma.$MessageTemplatePayload, S>

  type MessageTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageTemplateCountAggregateInputType | true
    }

  export interface MessageTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageTemplate'], meta: { name: 'MessageTemplate' } }
    /**
     * Find zero or one MessageTemplate that matches the filter.
     * @param {MessageTemplateFindUniqueArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageTemplateFindUniqueArgs>(args: SelectSubset<T, MessageTemplateFindUniqueArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageTemplateFindUniqueOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageTemplateFindFirstArgs>(args?: SelectSubset<T, MessageTemplateFindFirstArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany()
     * 
     * // Get first 10 MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageTemplateFindManyArgs>(args?: SelectSubset<T, MessageTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageTemplate.
     * @param {MessageTemplateCreateArgs} args - Arguments to create a MessageTemplate.
     * @example
     * // Create one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.create({
     *   data: {
     *     // ... data to create a MessageTemplate
     *   }
     * })
     * 
     */
    create<T extends MessageTemplateCreateArgs>(args: SelectSubset<T, MessageTemplateCreateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageTemplates.
     * @param {MessageTemplateCreateManyArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageTemplateCreateManyArgs>(args?: SelectSubset<T, MessageTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageTemplate.
     * @param {MessageTemplateDeleteArgs} args - Arguments to delete one MessageTemplate.
     * @example
     * // Delete one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.delete({
     *   where: {
     *     // ... filter to delete one MessageTemplate
     *   }
     * })
     * 
     */
    delete<T extends MessageTemplateDeleteArgs>(args: SelectSubset<T, MessageTemplateDeleteArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageTemplate.
     * @param {MessageTemplateUpdateArgs} args - Arguments to update one MessageTemplate.
     * @example
     * // Update one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageTemplateUpdateArgs>(args: SelectSubset<T, MessageTemplateUpdateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageTemplates.
     * @param {MessageTemplateDeleteManyArgs} args - Arguments to filter MessageTemplates to delete.
     * @example
     * // Delete a few MessageTemplates
     * const { count } = await prisma.messageTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageTemplateDeleteManyArgs>(args?: SelectSubset<T, MessageTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageTemplateUpdateManyArgs>(args: SelectSubset<T, MessageTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageTemplate.
     * @param {MessageTemplateUpsertArgs} args - Arguments to update or create a MessageTemplate.
     * @example
     * // Update or create a MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.upsert({
     *   create: {
     *     // ... data to create a MessageTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageTemplate we want to update
     *   }
     * })
     */
    upsert<T extends MessageTemplateUpsertArgs>(args: SelectSubset<T, MessageTemplateUpsertArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateCountArgs} args - Arguments to filter MessageTemplates to count.
     * @example
     * // Count the number of MessageTemplates
     * const count = await prisma.messageTemplate.count({
     *   where: {
     *     // ... the filter for the MessageTemplates we want to count
     *   }
     * })
    **/
    count<T extends MessageTemplateCountArgs>(
      args?: Subset<T, MessageTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageTemplateAggregateArgs>(args: Subset<T, MessageTemplateAggregateArgs>): Prisma.PrismaPromise<GetMessageTemplateAggregateType<T>>

    /**
     * Group by MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageTemplateGroupByArgs['orderBy'] }
        : { orderBy?: MessageTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageTemplate model
   */
  readonly fields: MessageTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageTemplate model
   */ 
  interface MessageTemplateFieldRefs {
    readonly id: FieldRef<"MessageTemplate", 'String'>
    readonly name: FieldRef<"MessageTemplate", 'String'>
    readonly category: FieldRef<"MessageTemplate", 'String'>
    readonly language: FieldRef<"MessageTemplate", 'String'>
    readonly content: FieldRef<"MessageTemplate", 'String'>
    readonly variables: FieldRef<"MessageTemplate", 'Json'>
    readonly metadata: FieldRef<"MessageTemplate", 'Json'>
    readonly createdAt: FieldRef<"MessageTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageTemplate findUnique
   */
  export type MessageTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findUniqueOrThrow
   */
  export type MessageTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findFirst
   */
  export type MessageTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findFirstOrThrow
   */
  export type MessageTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findMany
   */
  export type MessageTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter, which MessageTemplates to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate create
   */
  export type MessageTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a MessageTemplate.
     */
    data: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
  }

  /**
   * MessageTemplate createMany
   */
  export type MessageTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplateCreateManyInput | MessageTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageTemplate update
   */
  export type MessageTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a MessageTemplate.
     */
    data: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
    /**
     * Choose, which MessageTemplate to update.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate updateMany
   */
  export type MessageTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageTemplates.
     */
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyInput>
    /**
     * Filter which MessageTemplates to update
     */
    where?: MessageTemplateWhereInput
  }

  /**
   * MessageTemplate upsert
   */
  export type MessageTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the MessageTemplate to update in case it exists.
     */
    where: MessageTemplateWhereUniqueInput
    /**
     * In case the MessageTemplate found by the `where` argument doesn't exist, create a new MessageTemplate with this data.
     */
    create: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
    /**
     * In case the MessageTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
  }

  /**
   * MessageTemplate delete
   */
  export type MessageTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter which MessageTemplate to delete.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate deleteMany
   */
  export type MessageTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplates to delete
     */
    where?: MessageTemplateWhereInput
  }

  /**
   * MessageTemplate without action
   */
  export type MessageTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
  }


  /**
   * Model Automation
   */

  export type AggregateAutomation = {
    _count: AutomationCountAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  export type AutomationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    trigger: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    trigger: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    trigger: number
    actions: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutomationMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    trigger?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    trigger?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    trigger?: true
    actions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutomationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automation to aggregate.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Automations
    **/
    _count?: true | AutomationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationMaxAggregateInputType
  }

  export type GetAutomationAggregateType<T extends AutomationAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomation[P]>
      : GetScalarType<T[P], AggregateAutomation[P]>
  }




  export type AutomationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithAggregationInput | AutomationOrderByWithAggregationInput[]
    by: AutomationScalarFieldEnum[] | AutomationScalarFieldEnum
    having?: AutomationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationCountAggregateInputType | true
    _min?: AutomationMinAggregateInputType
    _max?: AutomationMaxAggregateInputType
  }

  export type AutomationGroupByOutputType = {
    id: string
    userId: string
    name: string
    trigger: string
    actions: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AutomationCountAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  type GetAutomationGroupByPayload<T extends AutomationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationGroupByOutputType[P]>
        }
      >
    >


  export type AutomationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    trigger?: boolean
    actions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automation"]>


  export type AutomationSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    trigger?: boolean
    actions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AutomationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AutomationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Automation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      trigger: string
      actions: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["automation"]>
    composites: {}
  }

  type AutomationGetPayload<S extends boolean | null | undefined | AutomationDefaultArgs> = $Result.GetResult<Prisma.$AutomationPayload, S>

  type AutomationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutomationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomationCountAggregateInputType | true
    }

  export interface AutomationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Automation'], meta: { name: 'Automation' } }
    /**
     * Find zero or one Automation that matches the filter.
     * @param {AutomationFindUniqueArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationFindUniqueArgs>(args: SelectSubset<T, AutomationFindUniqueArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Automation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutomationFindUniqueOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Automation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationFindFirstArgs>(args?: SelectSubset<T, AutomationFindFirstArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Automation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Automations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Automations
     * const automations = await prisma.automation.findMany()
     * 
     * // Get first 10 Automations
     * const automations = await prisma.automation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationWithIdOnly = await prisma.automation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationFindManyArgs>(args?: SelectSubset<T, AutomationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Automation.
     * @param {AutomationCreateArgs} args - Arguments to create a Automation.
     * @example
     * // Create one Automation
     * const Automation = await prisma.automation.create({
     *   data: {
     *     // ... data to create a Automation
     *   }
     * })
     * 
     */
    create<T extends AutomationCreateArgs>(args: SelectSubset<T, AutomationCreateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Automations.
     * @param {AutomationCreateManyArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationCreateManyArgs>(args?: SelectSubset<T, AutomationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Automation.
     * @param {AutomationDeleteArgs} args - Arguments to delete one Automation.
     * @example
     * // Delete one Automation
     * const Automation = await prisma.automation.delete({
     *   where: {
     *     // ... filter to delete one Automation
     *   }
     * })
     * 
     */
    delete<T extends AutomationDeleteArgs>(args: SelectSubset<T, AutomationDeleteArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Automation.
     * @param {AutomationUpdateArgs} args - Arguments to update one Automation.
     * @example
     * // Update one Automation
     * const automation = await prisma.automation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationUpdateArgs>(args: SelectSubset<T, AutomationUpdateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Automations.
     * @param {AutomationDeleteManyArgs} args - Arguments to filter Automations to delete.
     * @example
     * // Delete a few Automations
     * const { count } = await prisma.automation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationDeleteManyArgs>(args?: SelectSubset<T, AutomationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Automations
     * const automation = await prisma.automation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationUpdateManyArgs>(args: SelectSubset<T, AutomationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Automation.
     * @param {AutomationUpsertArgs} args - Arguments to update or create a Automation.
     * @example
     * // Update or create a Automation
     * const automation = await prisma.automation.upsert({
     *   create: {
     *     // ... data to create a Automation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Automation we want to update
     *   }
     * })
     */
    upsert<T extends AutomationUpsertArgs>(args: SelectSubset<T, AutomationUpsertArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationCountArgs} args - Arguments to filter Automations to count.
     * @example
     * // Count the number of Automations
     * const count = await prisma.automation.count({
     *   where: {
     *     // ... the filter for the Automations we want to count
     *   }
     * })
    **/
    count<T extends AutomationCountArgs>(
      args?: Subset<T, AutomationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationAggregateArgs>(args: Subset<T, AutomationAggregateArgs>): Prisma.PrismaPromise<GetAutomationAggregateType<T>>

    /**
     * Group by Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationGroupByArgs['orderBy'] }
        : { orderBy?: AutomationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Automation model
   */
  readonly fields: AutomationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Automation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Automation model
   */ 
  interface AutomationFieldRefs {
    readonly id: FieldRef<"Automation", 'String'>
    readonly userId: FieldRef<"Automation", 'String'>
    readonly name: FieldRef<"Automation", 'String'>
    readonly trigger: FieldRef<"Automation", 'String'>
    readonly actions: FieldRef<"Automation", 'Json'>
    readonly isActive: FieldRef<"Automation", 'Boolean'>
    readonly createdAt: FieldRef<"Automation", 'DateTime'>
    readonly updatedAt: FieldRef<"Automation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Automation findUnique
   */
  export type AutomationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findUniqueOrThrow
   */
  export type AutomationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findFirst
   */
  export type AutomationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findFirstOrThrow
   */
  export type AutomationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findMany
   */
  export type AutomationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation create
   */
  export type AutomationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to create a Automation.
     */
    data: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
  }

  /**
   * Automation createMany
   */
  export type AutomationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Automation update
   */
  export type AutomationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to update a Automation.
     */
    data: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
    /**
     * Choose, which Automation to update.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation updateMany
   */
  export type AutomationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Automations.
     */
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyInput>
    /**
     * Filter which Automations to update
     */
    where?: AutomationWhereInput
  }

  /**
   * Automation upsert
   */
  export type AutomationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The filter to search for the Automation to update in case it exists.
     */
    where: AutomationWhereUniqueInput
    /**
     * In case the Automation found by the `where` argument doesn't exist, create a new Automation with this data.
     */
    create: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
    /**
     * In case the Automation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
  }

  /**
   * Automation delete
   */
  export type AutomationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter which Automation to delete.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation deleteMany
   */
  export type AutomationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automations to delete
     */
    where?: AutomationWhereInput
  }

  /**
   * Automation without action
   */
  export type AutomationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
  }


  /**
   * Model AutoReply
   */

  export type AggregateAutoReply = {
    _count: AutoReplyCountAggregateOutputType | null
    _min: AutoReplyMinAggregateOutputType | null
    _max: AutoReplyMaxAggregateOutputType | null
  }

  export type AutoReplyMinAggregateOutputType = {
    id: string | null
    isActive: boolean | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutoReplyMaxAggregateOutputType = {
    id: string | null
    isActive: boolean | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutoReplyCountAggregateOutputType = {
    id: number
    isActive: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutoReplyMinAggregateInputType = {
    id?: true
    isActive?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutoReplyMaxAggregateInputType = {
    id?: true
    isActive?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutoReplyCountAggregateInputType = {
    id?: true
    isActive?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutoReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoReply to aggregate.
     */
    where?: AutoReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoReplies to fetch.
     */
    orderBy?: AutoReplyOrderByWithRelationInput | AutoReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoReplies
    **/
    _count?: true | AutoReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoReplyMaxAggregateInputType
  }

  export type GetAutoReplyAggregateType<T extends AutoReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoReply[P]>
      : GetScalarType<T[P], AggregateAutoReply[P]>
  }




  export type AutoReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoReplyWhereInput
    orderBy?: AutoReplyOrderByWithAggregationInput | AutoReplyOrderByWithAggregationInput[]
    by: AutoReplyScalarFieldEnum[] | AutoReplyScalarFieldEnum
    having?: AutoReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoReplyCountAggregateInputType | true
    _min?: AutoReplyMinAggregateInputType
    _max?: AutoReplyMaxAggregateInputType
  }

  export type AutoReplyGroupByOutputType = {
    id: string
    isActive: boolean
    message: string
    createdAt: Date
    updatedAt: Date
    _count: AutoReplyCountAggregateOutputType | null
    _min: AutoReplyMinAggregateOutputType | null
    _max: AutoReplyMaxAggregateOutputType | null
  }

  type GetAutoReplyGroupByPayload<T extends AutoReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoReplyGroupByOutputType[P]>
            : GetScalarType<T[P], AutoReplyGroupByOutputType[P]>
        }
      >
    >


  export type AutoReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isActive?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["autoReply"]>


  export type AutoReplySelectScalar = {
    id?: boolean
    isActive?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $AutoReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoReply"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isActive: boolean
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["autoReply"]>
    composites: {}
  }

  type AutoReplyGetPayload<S extends boolean | null | undefined | AutoReplyDefaultArgs> = $Result.GetResult<Prisma.$AutoReplyPayload, S>

  type AutoReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutoReplyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutoReplyCountAggregateInputType | true
    }

  export interface AutoReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoReply'], meta: { name: 'AutoReply' } }
    /**
     * Find zero or one AutoReply that matches the filter.
     * @param {AutoReplyFindUniqueArgs} args - Arguments to find a AutoReply
     * @example
     * // Get one AutoReply
     * const autoReply = await prisma.autoReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoReplyFindUniqueArgs>(args: SelectSubset<T, AutoReplyFindUniqueArgs<ExtArgs>>): Prisma__AutoReplyClient<$Result.GetResult<Prisma.$AutoReplyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutoReply that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutoReplyFindUniqueOrThrowArgs} args - Arguments to find a AutoReply
     * @example
     * // Get one AutoReply
     * const autoReply = await prisma.autoReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoReplyClient<$Result.GetResult<Prisma.$AutoReplyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutoReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReplyFindFirstArgs} args - Arguments to find a AutoReply
     * @example
     * // Get one AutoReply
     * const autoReply = await prisma.autoReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoReplyFindFirstArgs>(args?: SelectSubset<T, AutoReplyFindFirstArgs<ExtArgs>>): Prisma__AutoReplyClient<$Result.GetResult<Prisma.$AutoReplyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutoReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReplyFindFirstOrThrowArgs} args - Arguments to find a AutoReply
     * @example
     * // Get one AutoReply
     * const autoReply = await prisma.autoReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoReplyClient<$Result.GetResult<Prisma.$AutoReplyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutoReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoReplies
     * const autoReplies = await prisma.autoReply.findMany()
     * 
     * // Get first 10 AutoReplies
     * const autoReplies = await prisma.autoReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoReplyWithIdOnly = await prisma.autoReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoReplyFindManyArgs>(args?: SelectSubset<T, AutoReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoReplyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutoReply.
     * @param {AutoReplyCreateArgs} args - Arguments to create a AutoReply.
     * @example
     * // Create one AutoReply
     * const AutoReply = await prisma.autoReply.create({
     *   data: {
     *     // ... data to create a AutoReply
     *   }
     * })
     * 
     */
    create<T extends AutoReplyCreateArgs>(args: SelectSubset<T, AutoReplyCreateArgs<ExtArgs>>): Prisma__AutoReplyClient<$Result.GetResult<Prisma.$AutoReplyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutoReplies.
     * @param {AutoReplyCreateManyArgs} args - Arguments to create many AutoReplies.
     * @example
     * // Create many AutoReplies
     * const autoReply = await prisma.autoReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoReplyCreateManyArgs>(args?: SelectSubset<T, AutoReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutoReply.
     * @param {AutoReplyDeleteArgs} args - Arguments to delete one AutoReply.
     * @example
     * // Delete one AutoReply
     * const AutoReply = await prisma.autoReply.delete({
     *   where: {
     *     // ... filter to delete one AutoReply
     *   }
     * })
     * 
     */
    delete<T extends AutoReplyDeleteArgs>(args: SelectSubset<T, AutoReplyDeleteArgs<ExtArgs>>): Prisma__AutoReplyClient<$Result.GetResult<Prisma.$AutoReplyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutoReply.
     * @param {AutoReplyUpdateArgs} args - Arguments to update one AutoReply.
     * @example
     * // Update one AutoReply
     * const autoReply = await prisma.autoReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoReplyUpdateArgs>(args: SelectSubset<T, AutoReplyUpdateArgs<ExtArgs>>): Prisma__AutoReplyClient<$Result.GetResult<Prisma.$AutoReplyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutoReplies.
     * @param {AutoReplyDeleteManyArgs} args - Arguments to filter AutoReplies to delete.
     * @example
     * // Delete a few AutoReplies
     * const { count } = await prisma.autoReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoReplyDeleteManyArgs>(args?: SelectSubset<T, AutoReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoReplies
     * const autoReply = await prisma.autoReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoReplyUpdateManyArgs>(args: SelectSubset<T, AutoReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoReply.
     * @param {AutoReplyUpsertArgs} args - Arguments to update or create a AutoReply.
     * @example
     * // Update or create a AutoReply
     * const autoReply = await prisma.autoReply.upsert({
     *   create: {
     *     // ... data to create a AutoReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoReply we want to update
     *   }
     * })
     */
    upsert<T extends AutoReplyUpsertArgs>(args: SelectSubset<T, AutoReplyUpsertArgs<ExtArgs>>): Prisma__AutoReplyClient<$Result.GetResult<Prisma.$AutoReplyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutoReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReplyCountArgs} args - Arguments to filter AutoReplies to count.
     * @example
     * // Count the number of AutoReplies
     * const count = await prisma.autoReply.count({
     *   where: {
     *     // ... the filter for the AutoReplies we want to count
     *   }
     * })
    **/
    count<T extends AutoReplyCountArgs>(
      args?: Subset<T, AutoReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoReplyAggregateArgs>(args: Subset<T, AutoReplyAggregateArgs>): Prisma.PrismaPromise<GetAutoReplyAggregateType<T>>

    /**
     * Group by AutoReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoReplyGroupByArgs['orderBy'] }
        : { orderBy?: AutoReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoReply model
   */
  readonly fields: AutoReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoReply model
   */ 
  interface AutoReplyFieldRefs {
    readonly id: FieldRef<"AutoReply", 'String'>
    readonly isActive: FieldRef<"AutoReply", 'Boolean'>
    readonly message: FieldRef<"AutoReply", 'String'>
    readonly createdAt: FieldRef<"AutoReply", 'DateTime'>
    readonly updatedAt: FieldRef<"AutoReply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutoReply findUnique
   */
  export type AutoReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReply
     */
    select?: AutoReplySelect<ExtArgs> | null
    /**
     * Filter, which AutoReply to fetch.
     */
    where: AutoReplyWhereUniqueInput
  }

  /**
   * AutoReply findUniqueOrThrow
   */
  export type AutoReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReply
     */
    select?: AutoReplySelect<ExtArgs> | null
    /**
     * Filter, which AutoReply to fetch.
     */
    where: AutoReplyWhereUniqueInput
  }

  /**
   * AutoReply findFirst
   */
  export type AutoReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReply
     */
    select?: AutoReplySelect<ExtArgs> | null
    /**
     * Filter, which AutoReply to fetch.
     */
    where?: AutoReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoReplies to fetch.
     */
    orderBy?: AutoReplyOrderByWithRelationInput | AutoReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoReplies.
     */
    cursor?: AutoReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoReplies.
     */
    distinct?: AutoReplyScalarFieldEnum | AutoReplyScalarFieldEnum[]
  }

  /**
   * AutoReply findFirstOrThrow
   */
  export type AutoReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReply
     */
    select?: AutoReplySelect<ExtArgs> | null
    /**
     * Filter, which AutoReply to fetch.
     */
    where?: AutoReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoReplies to fetch.
     */
    orderBy?: AutoReplyOrderByWithRelationInput | AutoReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoReplies.
     */
    cursor?: AutoReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoReplies.
     */
    distinct?: AutoReplyScalarFieldEnum | AutoReplyScalarFieldEnum[]
  }

  /**
   * AutoReply findMany
   */
  export type AutoReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReply
     */
    select?: AutoReplySelect<ExtArgs> | null
    /**
     * Filter, which AutoReplies to fetch.
     */
    where?: AutoReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoReplies to fetch.
     */
    orderBy?: AutoReplyOrderByWithRelationInput | AutoReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoReplies.
     */
    cursor?: AutoReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoReplies.
     */
    skip?: number
    distinct?: AutoReplyScalarFieldEnum | AutoReplyScalarFieldEnum[]
  }

  /**
   * AutoReply create
   */
  export type AutoReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReply
     */
    select?: AutoReplySelect<ExtArgs> | null
    /**
     * The data needed to create a AutoReply.
     */
    data: XOR<AutoReplyCreateInput, AutoReplyUncheckedCreateInput>
  }

  /**
   * AutoReply createMany
   */
  export type AutoReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoReplies.
     */
    data: AutoReplyCreateManyInput | AutoReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutoReply update
   */
  export type AutoReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReply
     */
    select?: AutoReplySelect<ExtArgs> | null
    /**
     * The data needed to update a AutoReply.
     */
    data: XOR<AutoReplyUpdateInput, AutoReplyUncheckedUpdateInput>
    /**
     * Choose, which AutoReply to update.
     */
    where: AutoReplyWhereUniqueInput
  }

  /**
   * AutoReply updateMany
   */
  export type AutoReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoReplies.
     */
    data: XOR<AutoReplyUpdateManyMutationInput, AutoReplyUncheckedUpdateManyInput>
    /**
     * Filter which AutoReplies to update
     */
    where?: AutoReplyWhereInput
  }

  /**
   * AutoReply upsert
   */
  export type AutoReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReply
     */
    select?: AutoReplySelect<ExtArgs> | null
    /**
     * The filter to search for the AutoReply to update in case it exists.
     */
    where: AutoReplyWhereUniqueInput
    /**
     * In case the AutoReply found by the `where` argument doesn't exist, create a new AutoReply with this data.
     */
    create: XOR<AutoReplyCreateInput, AutoReplyUncheckedCreateInput>
    /**
     * In case the AutoReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoReplyUpdateInput, AutoReplyUncheckedUpdateInput>
  }

  /**
   * AutoReply delete
   */
  export type AutoReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReply
     */
    select?: AutoReplySelect<ExtArgs> | null
    /**
     * Filter which AutoReply to delete.
     */
    where: AutoReplyWhereUniqueInput
  }

  /**
   * AutoReply deleteMany
   */
  export type AutoReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoReplies to delete
     */
    where?: AutoReplyWhereInput
  }

  /**
   * AutoReply without action
   */
  export type AutoReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoReply
     */
    select?: AutoReplySelect<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    contactId: string | null
    messageId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    contactId: string | null
    messageId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    userId: number
    contactId: number
    messageId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NoteMinAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    messageId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    messageId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    messageId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: string
    userId: string
    contactId: string | null
    messageId: string | null
    content: string
    createdAt: Date
    updatedAt: Date
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contactId?: boolean
    messageId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | Note$contactArgs<ExtArgs>
    message?: boolean | Note$messageArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>


  export type NoteSelectScalar = {
    id?: boolean
    userId?: boolean
    contactId?: boolean
    messageId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | Note$contactArgs<ExtArgs>
    message?: boolean | Note$messageArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs> | null
      message: Prisma.$MessagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      contactId: string | null
      messageId: string | null
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contact<T extends Note$contactArgs<ExtArgs> = {}>(args?: Subset<T, Note$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    message<T extends Note$messageArgs<ExtArgs> = {}>(args?: Subset<T, Note$messageArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */ 
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'String'>
    readonly userId: FieldRef<"Note", 'String'>
    readonly contactId: FieldRef<"Note", 'String'>
    readonly messageId: FieldRef<"Note", 'String'>
    readonly content: FieldRef<"Note", 'String'>
    readonly createdAt: FieldRef<"Note", 'DateTime'>
    readonly updatedAt: FieldRef<"Note", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
  }

  /**
   * Note.contact
   */
  export type Note$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Note.message
   */
  export type Note$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: $Enums.ActivityType | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: $Enums.ActivityType | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resourceType: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    userId: string
    action: $Enums.ActivityType
    resourceType: string | null
    resourceId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>


  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: $Enums.ActivityType
      resourceType: string | null
      resourceId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */ 
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'ActivityType'>
    readonly resourceType: FieldRef<"ActivityLog", 'String'>
    readonly resourceId: FieldRef<"ActivityLog", 'String'>
    readonly details: FieldRef<"ActivityLog", 'Json'>
    readonly ipAddress: FieldRef<"ActivityLog", 'String'>
    readonly userAgent: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model AppConfig
   */

  export type AggregateAppConfig = {
    _count: AppConfigCountAggregateOutputType | null
    _min: AppConfigMinAggregateOutputType | null
    _max: AppConfigMaxAggregateOutputType | null
  }

  export type AppConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: $Enums.ConfigType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: $Enums.ConfigType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppConfig to aggregate.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppConfigs
    **/
    _count?: true | AppConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppConfigMaxAggregateInputType
  }

  export type GetAppConfigAggregateType<T extends AppConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateAppConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppConfig[P]>
      : GetScalarType<T[P], AggregateAppConfig[P]>
  }




  export type AppConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppConfigWhereInput
    orderBy?: AppConfigOrderByWithAggregationInput | AppConfigOrderByWithAggregationInput[]
    by: AppConfigScalarFieldEnum[] | AppConfigScalarFieldEnum
    having?: AppConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppConfigCountAggregateInputType | true
    _min?: AppConfigMinAggregateInputType
    _max?: AppConfigMaxAggregateInputType
  }

  export type AppConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    type: $Enums.ConfigType
    createdAt: Date
    updatedAt: Date
    _count: AppConfigCountAggregateOutputType | null
    _min: AppConfigMinAggregateOutputType | null
    _max: AppConfigMaxAggregateOutputType | null
  }

  type GetAppConfigGroupByPayload<T extends AppConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppConfigGroupByOutputType[P]>
            : GetScalarType<T[P], AppConfigGroupByOutputType[P]>
        }
      >
    >


  export type AppConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["appConfig"]>


  export type AppConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $AppConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      type: $Enums.ConfigType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appConfig"]>
    composites: {}
  }

  type AppConfigGetPayload<S extends boolean | null | undefined | AppConfigDefaultArgs> = $Result.GetResult<Prisma.$AppConfigPayload, S>

  type AppConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppConfigCountAggregateInputType | true
    }

  export interface AppConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppConfig'], meta: { name: 'AppConfig' } }
    /**
     * Find zero or one AppConfig that matches the filter.
     * @param {AppConfigFindUniqueArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppConfigFindUniqueArgs>(args: SelectSubset<T, AppConfigFindUniqueArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AppConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppConfigFindUniqueOrThrowArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, AppConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AppConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindFirstArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppConfigFindFirstArgs>(args?: SelectSubset<T, AppConfigFindFirstArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AppConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindFirstOrThrowArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, AppConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AppConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppConfigs
     * const appConfigs = await prisma.appConfig.findMany()
     * 
     * // Get first 10 AppConfigs
     * const appConfigs = await prisma.appConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appConfigWithIdOnly = await prisma.appConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppConfigFindManyArgs>(args?: SelectSubset<T, AppConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AppConfig.
     * @param {AppConfigCreateArgs} args - Arguments to create a AppConfig.
     * @example
     * // Create one AppConfig
     * const AppConfig = await prisma.appConfig.create({
     *   data: {
     *     // ... data to create a AppConfig
     *   }
     * })
     * 
     */
    create<T extends AppConfigCreateArgs>(args: SelectSubset<T, AppConfigCreateArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AppConfigs.
     * @param {AppConfigCreateManyArgs} args - Arguments to create many AppConfigs.
     * @example
     * // Create many AppConfigs
     * const appConfig = await prisma.appConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppConfigCreateManyArgs>(args?: SelectSubset<T, AppConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AppConfig.
     * @param {AppConfigDeleteArgs} args - Arguments to delete one AppConfig.
     * @example
     * // Delete one AppConfig
     * const AppConfig = await prisma.appConfig.delete({
     *   where: {
     *     // ... filter to delete one AppConfig
     *   }
     * })
     * 
     */
    delete<T extends AppConfigDeleteArgs>(args: SelectSubset<T, AppConfigDeleteArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AppConfig.
     * @param {AppConfigUpdateArgs} args - Arguments to update one AppConfig.
     * @example
     * // Update one AppConfig
     * const appConfig = await prisma.appConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppConfigUpdateArgs>(args: SelectSubset<T, AppConfigUpdateArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AppConfigs.
     * @param {AppConfigDeleteManyArgs} args - Arguments to filter AppConfigs to delete.
     * @example
     * // Delete a few AppConfigs
     * const { count } = await prisma.appConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppConfigDeleteManyArgs>(args?: SelectSubset<T, AppConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppConfigs
     * const appConfig = await prisma.appConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppConfigUpdateManyArgs>(args: SelectSubset<T, AppConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AppConfig.
     * @param {AppConfigUpsertArgs} args - Arguments to update or create a AppConfig.
     * @example
     * // Update or create a AppConfig
     * const appConfig = await prisma.appConfig.upsert({
     *   create: {
     *     // ... data to create a AppConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppConfig we want to update
     *   }
     * })
     */
    upsert<T extends AppConfigUpsertArgs>(args: SelectSubset<T, AppConfigUpsertArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AppConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigCountArgs} args - Arguments to filter AppConfigs to count.
     * @example
     * // Count the number of AppConfigs
     * const count = await prisma.appConfig.count({
     *   where: {
     *     // ... the filter for the AppConfigs we want to count
     *   }
     * })
    **/
    count<T extends AppConfigCountArgs>(
      args?: Subset<T, AppConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppConfigAggregateArgs>(args: Subset<T, AppConfigAggregateArgs>): Prisma.PrismaPromise<GetAppConfigAggregateType<T>>

    /**
     * Group by AppConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppConfigGroupByArgs['orderBy'] }
        : { orderBy?: AppConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppConfig model
   */
  readonly fields: AppConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppConfig model
   */ 
  interface AppConfigFieldRefs {
    readonly id: FieldRef<"AppConfig", 'String'>
    readonly key: FieldRef<"AppConfig", 'String'>
    readonly value: FieldRef<"AppConfig", 'String'>
    readonly type: FieldRef<"AppConfig", 'ConfigType'>
    readonly createdAt: FieldRef<"AppConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"AppConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppConfig findUnique
   */
  export type AppConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig findUniqueOrThrow
   */
  export type AppConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig findFirst
   */
  export type AppConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppConfigs.
     */
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig findFirstOrThrow
   */
  export type AppConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppConfigs.
     */
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig findMany
   */
  export type AppConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter, which AppConfigs to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig create
   */
  export type AppConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a AppConfig.
     */
    data: XOR<AppConfigCreateInput, AppConfigUncheckedCreateInput>
  }

  /**
   * AppConfig createMany
   */
  export type AppConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppConfigs.
     */
    data: AppConfigCreateManyInput | AppConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppConfig update
   */
  export type AppConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a AppConfig.
     */
    data: XOR<AppConfigUpdateInput, AppConfigUncheckedUpdateInput>
    /**
     * Choose, which AppConfig to update.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig updateMany
   */
  export type AppConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppConfigs.
     */
    data: XOR<AppConfigUpdateManyMutationInput, AppConfigUncheckedUpdateManyInput>
    /**
     * Filter which AppConfigs to update
     */
    where?: AppConfigWhereInput
  }

  /**
   * AppConfig upsert
   */
  export type AppConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the AppConfig to update in case it exists.
     */
    where: AppConfigWhereUniqueInput
    /**
     * In case the AppConfig found by the `where` argument doesn't exist, create a new AppConfig with this data.
     */
    create: XOR<AppConfigCreateInput, AppConfigUncheckedCreateInput>
    /**
     * In case the AppConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppConfigUpdateInput, AppConfigUncheckedUpdateInput>
  }

  /**
   * AppConfig delete
   */
  export type AppConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter which AppConfig to delete.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig deleteMany
   */
  export type AppConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppConfigs to delete
     */
    where?: AppConfigWhereInput
  }

  /**
   * AppConfig without action
   */
  export type AppConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
  }


  /**
   * Model DripCampaign
   */

  export type AggregateDripCampaign = {
    _count: DripCampaignCountAggregateOutputType | null
    _min: DripCampaignMinAggregateOutputType | null
    _max: DripCampaignMaxAggregateOutputType | null
  }

  export type DripCampaignMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    triggerType: $Enums.DripTriggerType | null
    triggerValue: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DripCampaignMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    triggerType: $Enums.DripTriggerType | null
    triggerValue: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DripCampaignCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    triggerType: number
    triggerValue: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DripCampaignMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    triggerType?: true
    triggerValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DripCampaignMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    triggerType?: true
    triggerValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DripCampaignCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    triggerType?: true
    triggerValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DripCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DripCampaign to aggregate.
     */
    where?: DripCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripCampaigns to fetch.
     */
    orderBy?: DripCampaignOrderByWithRelationInput | DripCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DripCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DripCampaigns
    **/
    _count?: true | DripCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DripCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DripCampaignMaxAggregateInputType
  }

  export type GetDripCampaignAggregateType<T extends DripCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateDripCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDripCampaign[P]>
      : GetScalarType<T[P], AggregateDripCampaign[P]>
  }




  export type DripCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DripCampaignWhereInput
    orderBy?: DripCampaignOrderByWithAggregationInput | DripCampaignOrderByWithAggregationInput[]
    by: DripCampaignScalarFieldEnum[] | DripCampaignScalarFieldEnum
    having?: DripCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DripCampaignCountAggregateInputType | true
    _min?: DripCampaignMinAggregateInputType
    _max?: DripCampaignMaxAggregateInputType
  }

  export type DripCampaignGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DripCampaignCountAggregateOutputType | null
    _min: DripCampaignMinAggregateOutputType | null
    _max: DripCampaignMaxAggregateOutputType | null
  }

  type GetDripCampaignGroupByPayload<T extends DripCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DripCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DripCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DripCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], DripCampaignGroupByOutputType[P]>
        }
      >
    >


  export type DripCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | DripCampaign$stepsArgs<ExtArgs>
    enrollments?: boolean | DripCampaign$enrollmentsArgs<ExtArgs>
    scheduled?: boolean | DripCampaign$scheduledArgs<ExtArgs>
    _count?: boolean | DripCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dripCampaign"]>


  export type DripCampaignSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DripCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | DripCampaign$stepsArgs<ExtArgs>
    enrollments?: boolean | DripCampaign$enrollmentsArgs<ExtArgs>
    scheduled?: boolean | DripCampaign$scheduledArgs<ExtArgs>
    _count?: boolean | DripCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DripCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DripCampaign"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      steps: Prisma.$DripCampaignStepPayload<ExtArgs>[]
      enrollments: Prisma.$DripEnrollmentPayload<ExtArgs>[]
      scheduled: Prisma.$DripScheduledMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      triggerType: $Enums.DripTriggerType
      triggerValue: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dripCampaign"]>
    composites: {}
  }

  type DripCampaignGetPayload<S extends boolean | null | undefined | DripCampaignDefaultArgs> = $Result.GetResult<Prisma.$DripCampaignPayload, S>

  type DripCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DripCampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DripCampaignCountAggregateInputType | true
    }

  export interface DripCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DripCampaign'], meta: { name: 'DripCampaign' } }
    /**
     * Find zero or one DripCampaign that matches the filter.
     * @param {DripCampaignFindUniqueArgs} args - Arguments to find a DripCampaign
     * @example
     * // Get one DripCampaign
     * const dripCampaign = await prisma.dripCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DripCampaignFindUniqueArgs>(args: SelectSubset<T, DripCampaignFindUniqueArgs<ExtArgs>>): Prisma__DripCampaignClient<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DripCampaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DripCampaignFindUniqueOrThrowArgs} args - Arguments to find a DripCampaign
     * @example
     * // Get one DripCampaign
     * const dripCampaign = await prisma.dripCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DripCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, DripCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DripCampaignClient<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DripCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignFindFirstArgs} args - Arguments to find a DripCampaign
     * @example
     * // Get one DripCampaign
     * const dripCampaign = await prisma.dripCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DripCampaignFindFirstArgs>(args?: SelectSubset<T, DripCampaignFindFirstArgs<ExtArgs>>): Prisma__DripCampaignClient<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DripCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignFindFirstOrThrowArgs} args - Arguments to find a DripCampaign
     * @example
     * // Get one DripCampaign
     * const dripCampaign = await prisma.dripCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DripCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, DripCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__DripCampaignClient<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DripCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DripCampaigns
     * const dripCampaigns = await prisma.dripCampaign.findMany()
     * 
     * // Get first 10 DripCampaigns
     * const dripCampaigns = await prisma.dripCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dripCampaignWithIdOnly = await prisma.dripCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DripCampaignFindManyArgs>(args?: SelectSubset<T, DripCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DripCampaign.
     * @param {DripCampaignCreateArgs} args - Arguments to create a DripCampaign.
     * @example
     * // Create one DripCampaign
     * const DripCampaign = await prisma.dripCampaign.create({
     *   data: {
     *     // ... data to create a DripCampaign
     *   }
     * })
     * 
     */
    create<T extends DripCampaignCreateArgs>(args: SelectSubset<T, DripCampaignCreateArgs<ExtArgs>>): Prisma__DripCampaignClient<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DripCampaigns.
     * @param {DripCampaignCreateManyArgs} args - Arguments to create many DripCampaigns.
     * @example
     * // Create many DripCampaigns
     * const dripCampaign = await prisma.dripCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DripCampaignCreateManyArgs>(args?: SelectSubset<T, DripCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DripCampaign.
     * @param {DripCampaignDeleteArgs} args - Arguments to delete one DripCampaign.
     * @example
     * // Delete one DripCampaign
     * const DripCampaign = await prisma.dripCampaign.delete({
     *   where: {
     *     // ... filter to delete one DripCampaign
     *   }
     * })
     * 
     */
    delete<T extends DripCampaignDeleteArgs>(args: SelectSubset<T, DripCampaignDeleteArgs<ExtArgs>>): Prisma__DripCampaignClient<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DripCampaign.
     * @param {DripCampaignUpdateArgs} args - Arguments to update one DripCampaign.
     * @example
     * // Update one DripCampaign
     * const dripCampaign = await prisma.dripCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DripCampaignUpdateArgs>(args: SelectSubset<T, DripCampaignUpdateArgs<ExtArgs>>): Prisma__DripCampaignClient<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DripCampaigns.
     * @param {DripCampaignDeleteManyArgs} args - Arguments to filter DripCampaigns to delete.
     * @example
     * // Delete a few DripCampaigns
     * const { count } = await prisma.dripCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DripCampaignDeleteManyArgs>(args?: SelectSubset<T, DripCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DripCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DripCampaigns
     * const dripCampaign = await prisma.dripCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DripCampaignUpdateManyArgs>(args: SelectSubset<T, DripCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DripCampaign.
     * @param {DripCampaignUpsertArgs} args - Arguments to update or create a DripCampaign.
     * @example
     * // Update or create a DripCampaign
     * const dripCampaign = await prisma.dripCampaign.upsert({
     *   create: {
     *     // ... data to create a DripCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DripCampaign we want to update
     *   }
     * })
     */
    upsert<T extends DripCampaignUpsertArgs>(args: SelectSubset<T, DripCampaignUpsertArgs<ExtArgs>>): Prisma__DripCampaignClient<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DripCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignCountArgs} args - Arguments to filter DripCampaigns to count.
     * @example
     * // Count the number of DripCampaigns
     * const count = await prisma.dripCampaign.count({
     *   where: {
     *     // ... the filter for the DripCampaigns we want to count
     *   }
     * })
    **/
    count<T extends DripCampaignCountArgs>(
      args?: Subset<T, DripCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DripCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DripCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DripCampaignAggregateArgs>(args: Subset<T, DripCampaignAggregateArgs>): Prisma.PrismaPromise<GetDripCampaignAggregateType<T>>

    /**
     * Group by DripCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DripCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DripCampaignGroupByArgs['orderBy'] }
        : { orderBy?: DripCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DripCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDripCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DripCampaign model
   */
  readonly fields: DripCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DripCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DripCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    steps<T extends DripCampaign$stepsArgs<ExtArgs> = {}>(args?: Subset<T, DripCampaign$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DripCampaignStepPayload<ExtArgs>, T, "findMany"> | Null>
    enrollments<T extends DripCampaign$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, DripCampaign$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DripEnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    scheduled<T extends DripCampaign$scheduledArgs<ExtArgs> = {}>(args?: Subset<T, DripCampaign$scheduledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DripCampaign model
   */ 
  interface DripCampaignFieldRefs {
    readonly id: FieldRef<"DripCampaign", 'String'>
    readonly userId: FieldRef<"DripCampaign", 'String'>
    readonly name: FieldRef<"DripCampaign", 'String'>
    readonly description: FieldRef<"DripCampaign", 'String'>
    readonly triggerType: FieldRef<"DripCampaign", 'DripTriggerType'>
    readonly triggerValue: FieldRef<"DripCampaign", 'String'>
    readonly isActive: FieldRef<"DripCampaign", 'Boolean'>
    readonly createdAt: FieldRef<"DripCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"DripCampaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DripCampaign findUnique
   */
  export type DripCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaign
     */
    select?: DripCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignInclude<ExtArgs> | null
    /**
     * Filter, which DripCampaign to fetch.
     */
    where: DripCampaignWhereUniqueInput
  }

  /**
   * DripCampaign findUniqueOrThrow
   */
  export type DripCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaign
     */
    select?: DripCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignInclude<ExtArgs> | null
    /**
     * Filter, which DripCampaign to fetch.
     */
    where: DripCampaignWhereUniqueInput
  }

  /**
   * DripCampaign findFirst
   */
  export type DripCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaign
     */
    select?: DripCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignInclude<ExtArgs> | null
    /**
     * Filter, which DripCampaign to fetch.
     */
    where?: DripCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripCampaigns to fetch.
     */
    orderBy?: DripCampaignOrderByWithRelationInput | DripCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DripCampaigns.
     */
    cursor?: DripCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DripCampaigns.
     */
    distinct?: DripCampaignScalarFieldEnum | DripCampaignScalarFieldEnum[]
  }

  /**
   * DripCampaign findFirstOrThrow
   */
  export type DripCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaign
     */
    select?: DripCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignInclude<ExtArgs> | null
    /**
     * Filter, which DripCampaign to fetch.
     */
    where?: DripCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripCampaigns to fetch.
     */
    orderBy?: DripCampaignOrderByWithRelationInput | DripCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DripCampaigns.
     */
    cursor?: DripCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DripCampaigns.
     */
    distinct?: DripCampaignScalarFieldEnum | DripCampaignScalarFieldEnum[]
  }

  /**
   * DripCampaign findMany
   */
  export type DripCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaign
     */
    select?: DripCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignInclude<ExtArgs> | null
    /**
     * Filter, which DripCampaigns to fetch.
     */
    where?: DripCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripCampaigns to fetch.
     */
    orderBy?: DripCampaignOrderByWithRelationInput | DripCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DripCampaigns.
     */
    cursor?: DripCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripCampaigns.
     */
    skip?: number
    distinct?: DripCampaignScalarFieldEnum | DripCampaignScalarFieldEnum[]
  }

  /**
   * DripCampaign create
   */
  export type DripCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaign
     */
    select?: DripCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a DripCampaign.
     */
    data: XOR<DripCampaignCreateInput, DripCampaignUncheckedCreateInput>
  }

  /**
   * DripCampaign createMany
   */
  export type DripCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DripCampaigns.
     */
    data: DripCampaignCreateManyInput | DripCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DripCampaign update
   */
  export type DripCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaign
     */
    select?: DripCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a DripCampaign.
     */
    data: XOR<DripCampaignUpdateInput, DripCampaignUncheckedUpdateInput>
    /**
     * Choose, which DripCampaign to update.
     */
    where: DripCampaignWhereUniqueInput
  }

  /**
   * DripCampaign updateMany
   */
  export type DripCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DripCampaigns.
     */
    data: XOR<DripCampaignUpdateManyMutationInput, DripCampaignUncheckedUpdateManyInput>
    /**
     * Filter which DripCampaigns to update
     */
    where?: DripCampaignWhereInput
  }

  /**
   * DripCampaign upsert
   */
  export type DripCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaign
     */
    select?: DripCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the DripCampaign to update in case it exists.
     */
    where: DripCampaignWhereUniqueInput
    /**
     * In case the DripCampaign found by the `where` argument doesn't exist, create a new DripCampaign with this data.
     */
    create: XOR<DripCampaignCreateInput, DripCampaignUncheckedCreateInput>
    /**
     * In case the DripCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DripCampaignUpdateInput, DripCampaignUncheckedUpdateInput>
  }

  /**
   * DripCampaign delete
   */
  export type DripCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaign
     */
    select?: DripCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignInclude<ExtArgs> | null
    /**
     * Filter which DripCampaign to delete.
     */
    where: DripCampaignWhereUniqueInput
  }

  /**
   * DripCampaign deleteMany
   */
  export type DripCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DripCampaigns to delete
     */
    where?: DripCampaignWhereInput
  }

  /**
   * DripCampaign.steps
   */
  export type DripCampaign$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStep
     */
    select?: DripCampaignStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignStepInclude<ExtArgs> | null
    where?: DripCampaignStepWhereInput
    orderBy?: DripCampaignStepOrderByWithRelationInput | DripCampaignStepOrderByWithRelationInput[]
    cursor?: DripCampaignStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DripCampaignStepScalarFieldEnum | DripCampaignStepScalarFieldEnum[]
  }

  /**
   * DripCampaign.enrollments
   */
  export type DripCampaign$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
    where?: DripEnrollmentWhereInput
    orderBy?: DripEnrollmentOrderByWithRelationInput | DripEnrollmentOrderByWithRelationInput[]
    cursor?: DripEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DripEnrollmentScalarFieldEnum | DripEnrollmentScalarFieldEnum[]
  }

  /**
   * DripCampaign.scheduled
   */
  export type DripCampaign$scheduledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    where?: DripScheduledMessageWhereInput
    orderBy?: DripScheduledMessageOrderByWithRelationInput | DripScheduledMessageOrderByWithRelationInput[]
    cursor?: DripScheduledMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DripScheduledMessageScalarFieldEnum | DripScheduledMessageScalarFieldEnum[]
  }

  /**
   * DripCampaign without action
   */
  export type DripCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaign
     */
    select?: DripCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignInclude<ExtArgs> | null
  }


  /**
   * Model DripCampaignStep
   */

  export type AggregateDripCampaignStep = {
    _count: DripCampaignStepCountAggregateOutputType | null
    _avg: DripCampaignStepAvgAggregateOutputType | null
    _sum: DripCampaignStepSumAggregateOutputType | null
    _min: DripCampaignStepMinAggregateOutputType | null
    _max: DripCampaignStepMaxAggregateOutputType | null
  }

  export type DripCampaignStepAvgAggregateOutputType = {
    sequence: number | null
    delayHours: number | null
  }

  export type DripCampaignStepSumAggregateOutputType = {
    sequence: number | null
    delayHours: number | null
  }

  export type DripCampaignStepMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    sequence: number | null
    delayHours: number | null
    message: string | null
    mediaUrl: string | null
    mediaType: string | null
    createdAt: Date | null
  }

  export type DripCampaignStepMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    sequence: number | null
    delayHours: number | null
    message: string | null
    mediaUrl: string | null
    mediaType: string | null
    createdAt: Date | null
  }

  export type DripCampaignStepCountAggregateOutputType = {
    id: number
    campaignId: number
    sequence: number
    delayHours: number
    message: number
    mediaUrl: number
    mediaType: number
    createdAt: number
    _all: number
  }


  export type DripCampaignStepAvgAggregateInputType = {
    sequence?: true
    delayHours?: true
  }

  export type DripCampaignStepSumAggregateInputType = {
    sequence?: true
    delayHours?: true
  }

  export type DripCampaignStepMinAggregateInputType = {
    id?: true
    campaignId?: true
    sequence?: true
    delayHours?: true
    message?: true
    mediaUrl?: true
    mediaType?: true
    createdAt?: true
  }

  export type DripCampaignStepMaxAggregateInputType = {
    id?: true
    campaignId?: true
    sequence?: true
    delayHours?: true
    message?: true
    mediaUrl?: true
    mediaType?: true
    createdAt?: true
  }

  export type DripCampaignStepCountAggregateInputType = {
    id?: true
    campaignId?: true
    sequence?: true
    delayHours?: true
    message?: true
    mediaUrl?: true
    mediaType?: true
    createdAt?: true
    _all?: true
  }

  export type DripCampaignStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DripCampaignStep to aggregate.
     */
    where?: DripCampaignStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripCampaignSteps to fetch.
     */
    orderBy?: DripCampaignStepOrderByWithRelationInput | DripCampaignStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DripCampaignStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripCampaignSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripCampaignSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DripCampaignSteps
    **/
    _count?: true | DripCampaignStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DripCampaignStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DripCampaignStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DripCampaignStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DripCampaignStepMaxAggregateInputType
  }

  export type GetDripCampaignStepAggregateType<T extends DripCampaignStepAggregateArgs> = {
        [P in keyof T & keyof AggregateDripCampaignStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDripCampaignStep[P]>
      : GetScalarType<T[P], AggregateDripCampaignStep[P]>
  }




  export type DripCampaignStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DripCampaignStepWhereInput
    orderBy?: DripCampaignStepOrderByWithAggregationInput | DripCampaignStepOrderByWithAggregationInput[]
    by: DripCampaignStepScalarFieldEnum[] | DripCampaignStepScalarFieldEnum
    having?: DripCampaignStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DripCampaignStepCountAggregateInputType | true
    _avg?: DripCampaignStepAvgAggregateInputType
    _sum?: DripCampaignStepSumAggregateInputType
    _min?: DripCampaignStepMinAggregateInputType
    _max?: DripCampaignStepMaxAggregateInputType
  }

  export type DripCampaignStepGroupByOutputType = {
    id: string
    campaignId: string
    sequence: number
    delayHours: number
    message: string
    mediaUrl: string | null
    mediaType: string | null
    createdAt: Date
    _count: DripCampaignStepCountAggregateOutputType | null
    _avg: DripCampaignStepAvgAggregateOutputType | null
    _sum: DripCampaignStepSumAggregateOutputType | null
    _min: DripCampaignStepMinAggregateOutputType | null
    _max: DripCampaignStepMaxAggregateOutputType | null
  }

  type GetDripCampaignStepGroupByPayload<T extends DripCampaignStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DripCampaignStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DripCampaignStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DripCampaignStepGroupByOutputType[P]>
            : GetScalarType<T[P], DripCampaignStepGroupByOutputType[P]>
        }
      >
    >


  export type DripCampaignStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    sequence?: boolean
    delayHours?: boolean
    message?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    createdAt?: boolean
    campaign?: boolean | DripCampaignDefaultArgs<ExtArgs>
    scheduled?: boolean | DripCampaignStep$scheduledArgs<ExtArgs>
    _count?: boolean | DripCampaignStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dripCampaignStep"]>


  export type DripCampaignStepSelectScalar = {
    id?: boolean
    campaignId?: boolean
    sequence?: boolean
    delayHours?: boolean
    message?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    createdAt?: boolean
  }

  export type DripCampaignStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | DripCampaignDefaultArgs<ExtArgs>
    scheduled?: boolean | DripCampaignStep$scheduledArgs<ExtArgs>
    _count?: boolean | DripCampaignStepCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DripCampaignStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DripCampaignStep"
    objects: {
      campaign: Prisma.$DripCampaignPayload<ExtArgs>
      scheduled: Prisma.$DripScheduledMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      sequence: number
      delayHours: number
      message: string
      mediaUrl: string | null
      mediaType: string | null
      createdAt: Date
    }, ExtArgs["result"]["dripCampaignStep"]>
    composites: {}
  }

  type DripCampaignStepGetPayload<S extends boolean | null | undefined | DripCampaignStepDefaultArgs> = $Result.GetResult<Prisma.$DripCampaignStepPayload, S>

  type DripCampaignStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DripCampaignStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DripCampaignStepCountAggregateInputType | true
    }

  export interface DripCampaignStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DripCampaignStep'], meta: { name: 'DripCampaignStep' } }
    /**
     * Find zero or one DripCampaignStep that matches the filter.
     * @param {DripCampaignStepFindUniqueArgs} args - Arguments to find a DripCampaignStep
     * @example
     * // Get one DripCampaignStep
     * const dripCampaignStep = await prisma.dripCampaignStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DripCampaignStepFindUniqueArgs>(args: SelectSubset<T, DripCampaignStepFindUniqueArgs<ExtArgs>>): Prisma__DripCampaignStepClient<$Result.GetResult<Prisma.$DripCampaignStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DripCampaignStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DripCampaignStepFindUniqueOrThrowArgs} args - Arguments to find a DripCampaignStep
     * @example
     * // Get one DripCampaignStep
     * const dripCampaignStep = await prisma.dripCampaignStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DripCampaignStepFindUniqueOrThrowArgs>(args: SelectSubset<T, DripCampaignStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DripCampaignStepClient<$Result.GetResult<Prisma.$DripCampaignStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DripCampaignStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignStepFindFirstArgs} args - Arguments to find a DripCampaignStep
     * @example
     * // Get one DripCampaignStep
     * const dripCampaignStep = await prisma.dripCampaignStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DripCampaignStepFindFirstArgs>(args?: SelectSubset<T, DripCampaignStepFindFirstArgs<ExtArgs>>): Prisma__DripCampaignStepClient<$Result.GetResult<Prisma.$DripCampaignStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DripCampaignStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignStepFindFirstOrThrowArgs} args - Arguments to find a DripCampaignStep
     * @example
     * // Get one DripCampaignStep
     * const dripCampaignStep = await prisma.dripCampaignStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DripCampaignStepFindFirstOrThrowArgs>(args?: SelectSubset<T, DripCampaignStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__DripCampaignStepClient<$Result.GetResult<Prisma.$DripCampaignStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DripCampaignSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DripCampaignSteps
     * const dripCampaignSteps = await prisma.dripCampaignStep.findMany()
     * 
     * // Get first 10 DripCampaignSteps
     * const dripCampaignSteps = await prisma.dripCampaignStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dripCampaignStepWithIdOnly = await prisma.dripCampaignStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DripCampaignStepFindManyArgs>(args?: SelectSubset<T, DripCampaignStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DripCampaignStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DripCampaignStep.
     * @param {DripCampaignStepCreateArgs} args - Arguments to create a DripCampaignStep.
     * @example
     * // Create one DripCampaignStep
     * const DripCampaignStep = await prisma.dripCampaignStep.create({
     *   data: {
     *     // ... data to create a DripCampaignStep
     *   }
     * })
     * 
     */
    create<T extends DripCampaignStepCreateArgs>(args: SelectSubset<T, DripCampaignStepCreateArgs<ExtArgs>>): Prisma__DripCampaignStepClient<$Result.GetResult<Prisma.$DripCampaignStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DripCampaignSteps.
     * @param {DripCampaignStepCreateManyArgs} args - Arguments to create many DripCampaignSteps.
     * @example
     * // Create many DripCampaignSteps
     * const dripCampaignStep = await prisma.dripCampaignStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DripCampaignStepCreateManyArgs>(args?: SelectSubset<T, DripCampaignStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DripCampaignStep.
     * @param {DripCampaignStepDeleteArgs} args - Arguments to delete one DripCampaignStep.
     * @example
     * // Delete one DripCampaignStep
     * const DripCampaignStep = await prisma.dripCampaignStep.delete({
     *   where: {
     *     // ... filter to delete one DripCampaignStep
     *   }
     * })
     * 
     */
    delete<T extends DripCampaignStepDeleteArgs>(args: SelectSubset<T, DripCampaignStepDeleteArgs<ExtArgs>>): Prisma__DripCampaignStepClient<$Result.GetResult<Prisma.$DripCampaignStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DripCampaignStep.
     * @param {DripCampaignStepUpdateArgs} args - Arguments to update one DripCampaignStep.
     * @example
     * // Update one DripCampaignStep
     * const dripCampaignStep = await prisma.dripCampaignStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DripCampaignStepUpdateArgs>(args: SelectSubset<T, DripCampaignStepUpdateArgs<ExtArgs>>): Prisma__DripCampaignStepClient<$Result.GetResult<Prisma.$DripCampaignStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DripCampaignSteps.
     * @param {DripCampaignStepDeleteManyArgs} args - Arguments to filter DripCampaignSteps to delete.
     * @example
     * // Delete a few DripCampaignSteps
     * const { count } = await prisma.dripCampaignStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DripCampaignStepDeleteManyArgs>(args?: SelectSubset<T, DripCampaignStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DripCampaignSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DripCampaignSteps
     * const dripCampaignStep = await prisma.dripCampaignStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DripCampaignStepUpdateManyArgs>(args: SelectSubset<T, DripCampaignStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DripCampaignStep.
     * @param {DripCampaignStepUpsertArgs} args - Arguments to update or create a DripCampaignStep.
     * @example
     * // Update or create a DripCampaignStep
     * const dripCampaignStep = await prisma.dripCampaignStep.upsert({
     *   create: {
     *     // ... data to create a DripCampaignStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DripCampaignStep we want to update
     *   }
     * })
     */
    upsert<T extends DripCampaignStepUpsertArgs>(args: SelectSubset<T, DripCampaignStepUpsertArgs<ExtArgs>>): Prisma__DripCampaignStepClient<$Result.GetResult<Prisma.$DripCampaignStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DripCampaignSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignStepCountArgs} args - Arguments to filter DripCampaignSteps to count.
     * @example
     * // Count the number of DripCampaignSteps
     * const count = await prisma.dripCampaignStep.count({
     *   where: {
     *     // ... the filter for the DripCampaignSteps we want to count
     *   }
     * })
    **/
    count<T extends DripCampaignStepCountArgs>(
      args?: Subset<T, DripCampaignStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DripCampaignStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DripCampaignStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DripCampaignStepAggregateArgs>(args: Subset<T, DripCampaignStepAggregateArgs>): Prisma.PrismaPromise<GetDripCampaignStepAggregateType<T>>

    /**
     * Group by DripCampaignStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripCampaignStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DripCampaignStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DripCampaignStepGroupByArgs['orderBy'] }
        : { orderBy?: DripCampaignStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DripCampaignStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDripCampaignStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DripCampaignStep model
   */
  readonly fields: DripCampaignStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DripCampaignStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DripCampaignStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends DripCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DripCampaignDefaultArgs<ExtArgs>>): Prisma__DripCampaignClient<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    scheduled<T extends DripCampaignStep$scheduledArgs<ExtArgs> = {}>(args?: Subset<T, DripCampaignStep$scheduledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DripCampaignStep model
   */ 
  interface DripCampaignStepFieldRefs {
    readonly id: FieldRef<"DripCampaignStep", 'String'>
    readonly campaignId: FieldRef<"DripCampaignStep", 'String'>
    readonly sequence: FieldRef<"DripCampaignStep", 'Int'>
    readonly delayHours: FieldRef<"DripCampaignStep", 'Int'>
    readonly message: FieldRef<"DripCampaignStep", 'String'>
    readonly mediaUrl: FieldRef<"DripCampaignStep", 'String'>
    readonly mediaType: FieldRef<"DripCampaignStep", 'String'>
    readonly createdAt: FieldRef<"DripCampaignStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DripCampaignStep findUnique
   */
  export type DripCampaignStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStep
     */
    select?: DripCampaignStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignStepInclude<ExtArgs> | null
    /**
     * Filter, which DripCampaignStep to fetch.
     */
    where: DripCampaignStepWhereUniqueInput
  }

  /**
   * DripCampaignStep findUniqueOrThrow
   */
  export type DripCampaignStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStep
     */
    select?: DripCampaignStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignStepInclude<ExtArgs> | null
    /**
     * Filter, which DripCampaignStep to fetch.
     */
    where: DripCampaignStepWhereUniqueInput
  }

  /**
   * DripCampaignStep findFirst
   */
  export type DripCampaignStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStep
     */
    select?: DripCampaignStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignStepInclude<ExtArgs> | null
    /**
     * Filter, which DripCampaignStep to fetch.
     */
    where?: DripCampaignStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripCampaignSteps to fetch.
     */
    orderBy?: DripCampaignStepOrderByWithRelationInput | DripCampaignStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DripCampaignSteps.
     */
    cursor?: DripCampaignStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripCampaignSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripCampaignSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DripCampaignSteps.
     */
    distinct?: DripCampaignStepScalarFieldEnum | DripCampaignStepScalarFieldEnum[]
  }

  /**
   * DripCampaignStep findFirstOrThrow
   */
  export type DripCampaignStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStep
     */
    select?: DripCampaignStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignStepInclude<ExtArgs> | null
    /**
     * Filter, which DripCampaignStep to fetch.
     */
    where?: DripCampaignStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripCampaignSteps to fetch.
     */
    orderBy?: DripCampaignStepOrderByWithRelationInput | DripCampaignStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DripCampaignSteps.
     */
    cursor?: DripCampaignStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripCampaignSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripCampaignSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DripCampaignSteps.
     */
    distinct?: DripCampaignStepScalarFieldEnum | DripCampaignStepScalarFieldEnum[]
  }

  /**
   * DripCampaignStep findMany
   */
  export type DripCampaignStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStep
     */
    select?: DripCampaignStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignStepInclude<ExtArgs> | null
    /**
     * Filter, which DripCampaignSteps to fetch.
     */
    where?: DripCampaignStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripCampaignSteps to fetch.
     */
    orderBy?: DripCampaignStepOrderByWithRelationInput | DripCampaignStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DripCampaignSteps.
     */
    cursor?: DripCampaignStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripCampaignSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripCampaignSteps.
     */
    skip?: number
    distinct?: DripCampaignStepScalarFieldEnum | DripCampaignStepScalarFieldEnum[]
  }

  /**
   * DripCampaignStep create
   */
  export type DripCampaignStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStep
     */
    select?: DripCampaignStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignStepInclude<ExtArgs> | null
    /**
     * The data needed to create a DripCampaignStep.
     */
    data: XOR<DripCampaignStepCreateInput, DripCampaignStepUncheckedCreateInput>
  }

  /**
   * DripCampaignStep createMany
   */
  export type DripCampaignStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DripCampaignSteps.
     */
    data: DripCampaignStepCreateManyInput | DripCampaignStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DripCampaignStep update
   */
  export type DripCampaignStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStep
     */
    select?: DripCampaignStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignStepInclude<ExtArgs> | null
    /**
     * The data needed to update a DripCampaignStep.
     */
    data: XOR<DripCampaignStepUpdateInput, DripCampaignStepUncheckedUpdateInput>
    /**
     * Choose, which DripCampaignStep to update.
     */
    where: DripCampaignStepWhereUniqueInput
  }

  /**
   * DripCampaignStep updateMany
   */
  export type DripCampaignStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DripCampaignSteps.
     */
    data: XOR<DripCampaignStepUpdateManyMutationInput, DripCampaignStepUncheckedUpdateManyInput>
    /**
     * Filter which DripCampaignSteps to update
     */
    where?: DripCampaignStepWhereInput
  }

  /**
   * DripCampaignStep upsert
   */
  export type DripCampaignStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStep
     */
    select?: DripCampaignStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignStepInclude<ExtArgs> | null
    /**
     * The filter to search for the DripCampaignStep to update in case it exists.
     */
    where: DripCampaignStepWhereUniqueInput
    /**
     * In case the DripCampaignStep found by the `where` argument doesn't exist, create a new DripCampaignStep with this data.
     */
    create: XOR<DripCampaignStepCreateInput, DripCampaignStepUncheckedCreateInput>
    /**
     * In case the DripCampaignStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DripCampaignStepUpdateInput, DripCampaignStepUncheckedUpdateInput>
  }

  /**
   * DripCampaignStep delete
   */
  export type DripCampaignStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStep
     */
    select?: DripCampaignStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignStepInclude<ExtArgs> | null
    /**
     * Filter which DripCampaignStep to delete.
     */
    where: DripCampaignStepWhereUniqueInput
  }

  /**
   * DripCampaignStep deleteMany
   */
  export type DripCampaignStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DripCampaignSteps to delete
     */
    where?: DripCampaignStepWhereInput
  }

  /**
   * DripCampaignStep.scheduled
   */
  export type DripCampaignStep$scheduledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    where?: DripScheduledMessageWhereInput
    orderBy?: DripScheduledMessageOrderByWithRelationInput | DripScheduledMessageOrderByWithRelationInput[]
    cursor?: DripScheduledMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DripScheduledMessageScalarFieldEnum | DripScheduledMessageScalarFieldEnum[]
  }

  /**
   * DripCampaignStep without action
   */
  export type DripCampaignStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripCampaignStep
     */
    select?: DripCampaignStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripCampaignStepInclude<ExtArgs> | null
  }


  /**
   * Model DripEnrollment
   */

  export type AggregateDripEnrollment = {
    _count: DripEnrollmentCountAggregateOutputType | null
    _avg: DripEnrollmentAvgAggregateOutputType | null
    _sum: DripEnrollmentSumAggregateOutputType | null
    _min: DripEnrollmentMinAggregateOutputType | null
    _max: DripEnrollmentMaxAggregateOutputType | null
  }

  export type DripEnrollmentAvgAggregateOutputType = {
    currentStep: number | null
  }

  export type DripEnrollmentSumAggregateOutputType = {
    currentStep: number | null
  }

  export type DripEnrollmentMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contactId: string | null
    currentStep: number | null
    status: $Enums.DripEnrollmentStatus | null
    enrolledAt: Date | null
    completedAt: Date | null
  }

  export type DripEnrollmentMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contactId: string | null
    currentStep: number | null
    status: $Enums.DripEnrollmentStatus | null
    enrolledAt: Date | null
    completedAt: Date | null
  }

  export type DripEnrollmentCountAggregateOutputType = {
    id: number
    campaignId: number
    contactId: number
    currentStep: number
    status: number
    enrolledAt: number
    completedAt: number
    _all: number
  }


  export type DripEnrollmentAvgAggregateInputType = {
    currentStep?: true
  }

  export type DripEnrollmentSumAggregateInputType = {
    currentStep?: true
  }

  export type DripEnrollmentMinAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    currentStep?: true
    status?: true
    enrolledAt?: true
    completedAt?: true
  }

  export type DripEnrollmentMaxAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    currentStep?: true
    status?: true
    enrolledAt?: true
    completedAt?: true
  }

  export type DripEnrollmentCountAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    currentStep?: true
    status?: true
    enrolledAt?: true
    completedAt?: true
    _all?: true
  }

  export type DripEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DripEnrollment to aggregate.
     */
    where?: DripEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripEnrollments to fetch.
     */
    orderBy?: DripEnrollmentOrderByWithRelationInput | DripEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DripEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DripEnrollments
    **/
    _count?: true | DripEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DripEnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DripEnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DripEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DripEnrollmentMaxAggregateInputType
  }

  export type GetDripEnrollmentAggregateType<T extends DripEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDripEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDripEnrollment[P]>
      : GetScalarType<T[P], AggregateDripEnrollment[P]>
  }




  export type DripEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DripEnrollmentWhereInput
    orderBy?: DripEnrollmentOrderByWithAggregationInput | DripEnrollmentOrderByWithAggregationInput[]
    by: DripEnrollmentScalarFieldEnum[] | DripEnrollmentScalarFieldEnum
    having?: DripEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DripEnrollmentCountAggregateInputType | true
    _avg?: DripEnrollmentAvgAggregateInputType
    _sum?: DripEnrollmentSumAggregateInputType
    _min?: DripEnrollmentMinAggregateInputType
    _max?: DripEnrollmentMaxAggregateInputType
  }

  export type DripEnrollmentGroupByOutputType = {
    id: string
    campaignId: string
    contactId: string
    currentStep: number
    status: $Enums.DripEnrollmentStatus
    enrolledAt: Date
    completedAt: Date | null
    _count: DripEnrollmentCountAggregateOutputType | null
    _avg: DripEnrollmentAvgAggregateOutputType | null
    _sum: DripEnrollmentSumAggregateOutputType | null
    _min: DripEnrollmentMinAggregateOutputType | null
    _max: DripEnrollmentMaxAggregateOutputType | null
  }

  type GetDripEnrollmentGroupByPayload<T extends DripEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DripEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DripEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DripEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], DripEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type DripEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    currentStep?: boolean
    status?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    campaign?: boolean | DripCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dripEnrollment"]>


  export type DripEnrollmentSelectScalar = {
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    currentStep?: boolean
    status?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
  }

  export type DripEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | DripCampaignDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $DripEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DripEnrollment"
    objects: {
      campaign: Prisma.$DripCampaignPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      contactId: string
      currentStep: number
      status: $Enums.DripEnrollmentStatus
      enrolledAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["dripEnrollment"]>
    composites: {}
  }

  type DripEnrollmentGetPayload<S extends boolean | null | undefined | DripEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$DripEnrollmentPayload, S>

  type DripEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DripEnrollmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DripEnrollmentCountAggregateInputType | true
    }

  export interface DripEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DripEnrollment'], meta: { name: 'DripEnrollment' } }
    /**
     * Find zero or one DripEnrollment that matches the filter.
     * @param {DripEnrollmentFindUniqueArgs} args - Arguments to find a DripEnrollment
     * @example
     * // Get one DripEnrollment
     * const dripEnrollment = await prisma.dripEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DripEnrollmentFindUniqueArgs>(args: SelectSubset<T, DripEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__DripEnrollmentClient<$Result.GetResult<Prisma.$DripEnrollmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DripEnrollment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DripEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a DripEnrollment
     * @example
     * // Get one DripEnrollment
     * const dripEnrollment = await prisma.dripEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DripEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DripEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DripEnrollmentClient<$Result.GetResult<Prisma.$DripEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DripEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripEnrollmentFindFirstArgs} args - Arguments to find a DripEnrollment
     * @example
     * // Get one DripEnrollment
     * const dripEnrollment = await prisma.dripEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DripEnrollmentFindFirstArgs>(args?: SelectSubset<T, DripEnrollmentFindFirstArgs<ExtArgs>>): Prisma__DripEnrollmentClient<$Result.GetResult<Prisma.$DripEnrollmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DripEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripEnrollmentFindFirstOrThrowArgs} args - Arguments to find a DripEnrollment
     * @example
     * // Get one DripEnrollment
     * const dripEnrollment = await prisma.dripEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DripEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DripEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DripEnrollmentClient<$Result.GetResult<Prisma.$DripEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DripEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DripEnrollments
     * const dripEnrollments = await prisma.dripEnrollment.findMany()
     * 
     * // Get first 10 DripEnrollments
     * const dripEnrollments = await prisma.dripEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dripEnrollmentWithIdOnly = await prisma.dripEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DripEnrollmentFindManyArgs>(args?: SelectSubset<T, DripEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DripEnrollmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DripEnrollment.
     * @param {DripEnrollmentCreateArgs} args - Arguments to create a DripEnrollment.
     * @example
     * // Create one DripEnrollment
     * const DripEnrollment = await prisma.dripEnrollment.create({
     *   data: {
     *     // ... data to create a DripEnrollment
     *   }
     * })
     * 
     */
    create<T extends DripEnrollmentCreateArgs>(args: SelectSubset<T, DripEnrollmentCreateArgs<ExtArgs>>): Prisma__DripEnrollmentClient<$Result.GetResult<Prisma.$DripEnrollmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DripEnrollments.
     * @param {DripEnrollmentCreateManyArgs} args - Arguments to create many DripEnrollments.
     * @example
     * // Create many DripEnrollments
     * const dripEnrollment = await prisma.dripEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DripEnrollmentCreateManyArgs>(args?: SelectSubset<T, DripEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DripEnrollment.
     * @param {DripEnrollmentDeleteArgs} args - Arguments to delete one DripEnrollment.
     * @example
     * // Delete one DripEnrollment
     * const DripEnrollment = await prisma.dripEnrollment.delete({
     *   where: {
     *     // ... filter to delete one DripEnrollment
     *   }
     * })
     * 
     */
    delete<T extends DripEnrollmentDeleteArgs>(args: SelectSubset<T, DripEnrollmentDeleteArgs<ExtArgs>>): Prisma__DripEnrollmentClient<$Result.GetResult<Prisma.$DripEnrollmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DripEnrollment.
     * @param {DripEnrollmentUpdateArgs} args - Arguments to update one DripEnrollment.
     * @example
     * // Update one DripEnrollment
     * const dripEnrollment = await prisma.dripEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DripEnrollmentUpdateArgs>(args: SelectSubset<T, DripEnrollmentUpdateArgs<ExtArgs>>): Prisma__DripEnrollmentClient<$Result.GetResult<Prisma.$DripEnrollmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DripEnrollments.
     * @param {DripEnrollmentDeleteManyArgs} args - Arguments to filter DripEnrollments to delete.
     * @example
     * // Delete a few DripEnrollments
     * const { count } = await prisma.dripEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DripEnrollmentDeleteManyArgs>(args?: SelectSubset<T, DripEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DripEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DripEnrollments
     * const dripEnrollment = await prisma.dripEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DripEnrollmentUpdateManyArgs>(args: SelectSubset<T, DripEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DripEnrollment.
     * @param {DripEnrollmentUpsertArgs} args - Arguments to update or create a DripEnrollment.
     * @example
     * // Update or create a DripEnrollment
     * const dripEnrollment = await prisma.dripEnrollment.upsert({
     *   create: {
     *     // ... data to create a DripEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DripEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends DripEnrollmentUpsertArgs>(args: SelectSubset<T, DripEnrollmentUpsertArgs<ExtArgs>>): Prisma__DripEnrollmentClient<$Result.GetResult<Prisma.$DripEnrollmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DripEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripEnrollmentCountArgs} args - Arguments to filter DripEnrollments to count.
     * @example
     * // Count the number of DripEnrollments
     * const count = await prisma.dripEnrollment.count({
     *   where: {
     *     // ... the filter for the DripEnrollments we want to count
     *   }
     * })
    **/
    count<T extends DripEnrollmentCountArgs>(
      args?: Subset<T, DripEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DripEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DripEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DripEnrollmentAggregateArgs>(args: Subset<T, DripEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetDripEnrollmentAggregateType<T>>

    /**
     * Group by DripEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DripEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DripEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: DripEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DripEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDripEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DripEnrollment model
   */
  readonly fields: DripEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DripEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DripEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends DripCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DripCampaignDefaultArgs<ExtArgs>>): Prisma__DripCampaignClient<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DripEnrollment model
   */ 
  interface DripEnrollmentFieldRefs {
    readonly id: FieldRef<"DripEnrollment", 'String'>
    readonly campaignId: FieldRef<"DripEnrollment", 'String'>
    readonly contactId: FieldRef<"DripEnrollment", 'String'>
    readonly currentStep: FieldRef<"DripEnrollment", 'Int'>
    readonly status: FieldRef<"DripEnrollment", 'DripEnrollmentStatus'>
    readonly enrolledAt: FieldRef<"DripEnrollment", 'DateTime'>
    readonly completedAt: FieldRef<"DripEnrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DripEnrollment findUnique
   */
  export type DripEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which DripEnrollment to fetch.
     */
    where: DripEnrollmentWhereUniqueInput
  }

  /**
   * DripEnrollment findUniqueOrThrow
   */
  export type DripEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which DripEnrollment to fetch.
     */
    where: DripEnrollmentWhereUniqueInput
  }

  /**
   * DripEnrollment findFirst
   */
  export type DripEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which DripEnrollment to fetch.
     */
    where?: DripEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripEnrollments to fetch.
     */
    orderBy?: DripEnrollmentOrderByWithRelationInput | DripEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DripEnrollments.
     */
    cursor?: DripEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DripEnrollments.
     */
    distinct?: DripEnrollmentScalarFieldEnum | DripEnrollmentScalarFieldEnum[]
  }

  /**
   * DripEnrollment findFirstOrThrow
   */
  export type DripEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which DripEnrollment to fetch.
     */
    where?: DripEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripEnrollments to fetch.
     */
    orderBy?: DripEnrollmentOrderByWithRelationInput | DripEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DripEnrollments.
     */
    cursor?: DripEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DripEnrollments.
     */
    distinct?: DripEnrollmentScalarFieldEnum | DripEnrollmentScalarFieldEnum[]
  }

  /**
   * DripEnrollment findMany
   */
  export type DripEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which DripEnrollments to fetch.
     */
    where?: DripEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripEnrollments to fetch.
     */
    orderBy?: DripEnrollmentOrderByWithRelationInput | DripEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DripEnrollments.
     */
    cursor?: DripEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripEnrollments.
     */
    skip?: number
    distinct?: DripEnrollmentScalarFieldEnum | DripEnrollmentScalarFieldEnum[]
  }

  /**
   * DripEnrollment create
   */
  export type DripEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DripEnrollment.
     */
    data: XOR<DripEnrollmentCreateInput, DripEnrollmentUncheckedCreateInput>
  }

  /**
   * DripEnrollment createMany
   */
  export type DripEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DripEnrollments.
     */
    data: DripEnrollmentCreateManyInput | DripEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DripEnrollment update
   */
  export type DripEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DripEnrollment.
     */
    data: XOR<DripEnrollmentUpdateInput, DripEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which DripEnrollment to update.
     */
    where: DripEnrollmentWhereUniqueInput
  }

  /**
   * DripEnrollment updateMany
   */
  export type DripEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DripEnrollments.
     */
    data: XOR<DripEnrollmentUpdateManyMutationInput, DripEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which DripEnrollments to update
     */
    where?: DripEnrollmentWhereInput
  }

  /**
   * DripEnrollment upsert
   */
  export type DripEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DripEnrollment to update in case it exists.
     */
    where: DripEnrollmentWhereUniqueInput
    /**
     * In case the DripEnrollment found by the `where` argument doesn't exist, create a new DripEnrollment with this data.
     */
    create: XOR<DripEnrollmentCreateInput, DripEnrollmentUncheckedCreateInput>
    /**
     * In case the DripEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DripEnrollmentUpdateInput, DripEnrollmentUncheckedUpdateInput>
  }

  /**
   * DripEnrollment delete
   */
  export type DripEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which DripEnrollment to delete.
     */
    where: DripEnrollmentWhereUniqueInput
  }

  /**
   * DripEnrollment deleteMany
   */
  export type DripEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DripEnrollments to delete
     */
    where?: DripEnrollmentWhereInput
  }

  /**
   * DripEnrollment without action
   */
  export type DripEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripEnrollment
     */
    select?: DripEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model DripScheduledMessage
   */

  export type AggregateDripScheduledMessage = {
    _count: DripScheduledMessageCountAggregateOutputType | null
    _min: DripScheduledMessageMinAggregateOutputType | null
    _max: DripScheduledMessageMaxAggregateOutputType | null
  }

  export type DripScheduledMessageMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    stepId: string | null
    contactId: string | null
    message: string | null
    mediaUrl: string | null
    mediaType: string | null
    scheduledFor: Date | null
    status: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type DripScheduledMessageMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    stepId: string | null
    contactId: string | null
    message: string | null
    mediaUrl: string | null
    mediaType: string | null
    scheduledFor: Date | null
    status: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type DripScheduledMessageCountAggregateOutputType = {
    id: number
    campaignId: number
    stepId: number
    contactId: number
    message: number
    mediaUrl: number
    mediaType: number
    scheduledFor: number
    status: number
    sentAt: number
    createdAt: number
    _all: number
  }


  export type DripScheduledMessageMinAggregateInputType = {
    id?: true
    campaignId?: true
    stepId?: true
    contactId?: true
    message?: true
    mediaUrl?: true
    mediaType?: true
    scheduledFor?: true
    status?: true
    sentAt?: true
    createdAt?: true
  }

  export type DripScheduledMessageMaxAggregateInputType = {
    id?: true
    campaignId?: true
    stepId?: true
    contactId?: true
    message?: true
    mediaUrl?: true
    mediaType?: true
    scheduledFor?: true
    status?: true
    sentAt?: true
    createdAt?: true
  }

  export type DripScheduledMessageCountAggregateInputType = {
    id?: true
    campaignId?: true
    stepId?: true
    contactId?: true
    message?: true
    mediaUrl?: true
    mediaType?: true
    scheduledFor?: true
    status?: true
    sentAt?: true
    createdAt?: true
    _all?: true
  }

  export type DripScheduledMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DripScheduledMessage to aggregate.
     */
    where?: DripScheduledMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripScheduledMessages to fetch.
     */
    orderBy?: DripScheduledMessageOrderByWithRelationInput | DripScheduledMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DripScheduledMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripScheduledMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripScheduledMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DripScheduledMessages
    **/
    _count?: true | DripScheduledMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DripScheduledMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DripScheduledMessageMaxAggregateInputType
  }

  export type GetDripScheduledMessageAggregateType<T extends DripScheduledMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDripScheduledMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDripScheduledMessage[P]>
      : GetScalarType<T[P], AggregateDripScheduledMessage[P]>
  }




  export type DripScheduledMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DripScheduledMessageWhereInput
    orderBy?: DripScheduledMessageOrderByWithAggregationInput | DripScheduledMessageOrderByWithAggregationInput[]
    by: DripScheduledMessageScalarFieldEnum[] | DripScheduledMessageScalarFieldEnum
    having?: DripScheduledMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DripScheduledMessageCountAggregateInputType | true
    _min?: DripScheduledMessageMinAggregateInputType
    _max?: DripScheduledMessageMaxAggregateInputType
  }

  export type DripScheduledMessageGroupByOutputType = {
    id: string
    campaignId: string
    stepId: string
    contactId: string
    message: string
    mediaUrl: string | null
    mediaType: string | null
    scheduledFor: Date
    status: string
    sentAt: Date | null
    createdAt: Date
    _count: DripScheduledMessageCountAggregateOutputType | null
    _min: DripScheduledMessageMinAggregateOutputType | null
    _max: DripScheduledMessageMaxAggregateOutputType | null
  }

  type GetDripScheduledMessageGroupByPayload<T extends DripScheduledMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DripScheduledMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DripScheduledMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DripScheduledMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DripScheduledMessageGroupByOutputType[P]>
        }
      >
    >


  export type DripScheduledMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    stepId?: boolean
    contactId?: boolean
    message?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    scheduledFor?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
    campaign?: boolean | DripCampaignDefaultArgs<ExtArgs>
    step?: boolean | DripCampaignStepDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dripScheduledMessage"]>


  export type DripScheduledMessageSelectScalar = {
    id?: boolean
    campaignId?: boolean
    stepId?: boolean
    contactId?: boolean
    message?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    scheduledFor?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }

  export type DripScheduledMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | DripCampaignDefaultArgs<ExtArgs>
    step?: boolean | DripCampaignStepDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $DripScheduledMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DripScheduledMessage"
    objects: {
      campaign: Prisma.$DripCampaignPayload<ExtArgs>
      step: Prisma.$DripCampaignStepPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      stepId: string
      contactId: string
      message: string
      mediaUrl: string | null
      mediaType: string | null
      scheduledFor: Date
      status: string
      sentAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["dripScheduledMessage"]>
    composites: {}
  }

  type DripScheduledMessageGetPayload<S extends boolean | null | undefined | DripScheduledMessageDefaultArgs> = $Result.GetResult<Prisma.$DripScheduledMessagePayload, S>

  type DripScheduledMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DripScheduledMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DripScheduledMessageCountAggregateInputType | true
    }

  export interface DripScheduledMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DripScheduledMessage'], meta: { name: 'DripScheduledMessage' } }
    /**
     * Find zero or one DripScheduledMessage that matches the filter.
     * @param {DripScheduledMessageFindUniqueArgs} args - Arguments to find a DripScheduledMessage
     * @example
     * // Get one DripScheduledMessage
     * const dripScheduledMessage = await prisma.dripScheduledMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DripScheduledMessageFindUniqueArgs>(args: SelectSubset<T, DripScheduledMessageFindUniqueArgs<ExtArgs>>): Prisma__DripScheduledMessageClient<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DripScheduledMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DripScheduledMessageFindUniqueOrThrowArgs} args - Arguments to find a DripScheduledMessage
     * @example
     * // Get one DripScheduledMessage
     * const dripScheduledMessage = await prisma.dripScheduledMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DripScheduledMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, DripScheduledMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DripScheduledMessageClient<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DripScheduledMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripScheduledMessageFindFirstArgs} args - Arguments to find a DripScheduledMessage
     * @example
     * // Get one DripScheduledMessage
     * const dripScheduledMessage = await prisma.dripScheduledMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DripScheduledMessageFindFirstArgs>(args?: SelectSubset<T, DripScheduledMessageFindFirstArgs<ExtArgs>>): Prisma__DripScheduledMessageClient<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DripScheduledMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripScheduledMessageFindFirstOrThrowArgs} args - Arguments to find a DripScheduledMessage
     * @example
     * // Get one DripScheduledMessage
     * const dripScheduledMessage = await prisma.dripScheduledMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DripScheduledMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, DripScheduledMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DripScheduledMessageClient<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DripScheduledMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripScheduledMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DripScheduledMessages
     * const dripScheduledMessages = await prisma.dripScheduledMessage.findMany()
     * 
     * // Get first 10 DripScheduledMessages
     * const dripScheduledMessages = await prisma.dripScheduledMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dripScheduledMessageWithIdOnly = await prisma.dripScheduledMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DripScheduledMessageFindManyArgs>(args?: SelectSubset<T, DripScheduledMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DripScheduledMessage.
     * @param {DripScheduledMessageCreateArgs} args - Arguments to create a DripScheduledMessage.
     * @example
     * // Create one DripScheduledMessage
     * const DripScheduledMessage = await prisma.dripScheduledMessage.create({
     *   data: {
     *     // ... data to create a DripScheduledMessage
     *   }
     * })
     * 
     */
    create<T extends DripScheduledMessageCreateArgs>(args: SelectSubset<T, DripScheduledMessageCreateArgs<ExtArgs>>): Prisma__DripScheduledMessageClient<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DripScheduledMessages.
     * @param {DripScheduledMessageCreateManyArgs} args - Arguments to create many DripScheduledMessages.
     * @example
     * // Create many DripScheduledMessages
     * const dripScheduledMessage = await prisma.dripScheduledMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DripScheduledMessageCreateManyArgs>(args?: SelectSubset<T, DripScheduledMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DripScheduledMessage.
     * @param {DripScheduledMessageDeleteArgs} args - Arguments to delete one DripScheduledMessage.
     * @example
     * // Delete one DripScheduledMessage
     * const DripScheduledMessage = await prisma.dripScheduledMessage.delete({
     *   where: {
     *     // ... filter to delete one DripScheduledMessage
     *   }
     * })
     * 
     */
    delete<T extends DripScheduledMessageDeleteArgs>(args: SelectSubset<T, DripScheduledMessageDeleteArgs<ExtArgs>>): Prisma__DripScheduledMessageClient<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DripScheduledMessage.
     * @param {DripScheduledMessageUpdateArgs} args - Arguments to update one DripScheduledMessage.
     * @example
     * // Update one DripScheduledMessage
     * const dripScheduledMessage = await prisma.dripScheduledMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DripScheduledMessageUpdateArgs>(args: SelectSubset<T, DripScheduledMessageUpdateArgs<ExtArgs>>): Prisma__DripScheduledMessageClient<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DripScheduledMessages.
     * @param {DripScheduledMessageDeleteManyArgs} args - Arguments to filter DripScheduledMessages to delete.
     * @example
     * // Delete a few DripScheduledMessages
     * const { count } = await prisma.dripScheduledMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DripScheduledMessageDeleteManyArgs>(args?: SelectSubset<T, DripScheduledMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DripScheduledMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripScheduledMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DripScheduledMessages
     * const dripScheduledMessage = await prisma.dripScheduledMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DripScheduledMessageUpdateManyArgs>(args: SelectSubset<T, DripScheduledMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DripScheduledMessage.
     * @param {DripScheduledMessageUpsertArgs} args - Arguments to update or create a DripScheduledMessage.
     * @example
     * // Update or create a DripScheduledMessage
     * const dripScheduledMessage = await prisma.dripScheduledMessage.upsert({
     *   create: {
     *     // ... data to create a DripScheduledMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DripScheduledMessage we want to update
     *   }
     * })
     */
    upsert<T extends DripScheduledMessageUpsertArgs>(args: SelectSubset<T, DripScheduledMessageUpsertArgs<ExtArgs>>): Prisma__DripScheduledMessageClient<$Result.GetResult<Prisma.$DripScheduledMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DripScheduledMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripScheduledMessageCountArgs} args - Arguments to filter DripScheduledMessages to count.
     * @example
     * // Count the number of DripScheduledMessages
     * const count = await prisma.dripScheduledMessage.count({
     *   where: {
     *     // ... the filter for the DripScheduledMessages we want to count
     *   }
     * })
    **/
    count<T extends DripScheduledMessageCountArgs>(
      args?: Subset<T, DripScheduledMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DripScheduledMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DripScheduledMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripScheduledMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DripScheduledMessageAggregateArgs>(args: Subset<T, DripScheduledMessageAggregateArgs>): Prisma.PrismaPromise<GetDripScheduledMessageAggregateType<T>>

    /**
     * Group by DripScheduledMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DripScheduledMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DripScheduledMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DripScheduledMessageGroupByArgs['orderBy'] }
        : { orderBy?: DripScheduledMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DripScheduledMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDripScheduledMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DripScheduledMessage model
   */
  readonly fields: DripScheduledMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DripScheduledMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DripScheduledMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends DripCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DripCampaignDefaultArgs<ExtArgs>>): Prisma__DripCampaignClient<$Result.GetResult<Prisma.$DripCampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    step<T extends DripCampaignStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DripCampaignStepDefaultArgs<ExtArgs>>): Prisma__DripCampaignStepClient<$Result.GetResult<Prisma.$DripCampaignStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DripScheduledMessage model
   */ 
  interface DripScheduledMessageFieldRefs {
    readonly id: FieldRef<"DripScheduledMessage", 'String'>
    readonly campaignId: FieldRef<"DripScheduledMessage", 'String'>
    readonly stepId: FieldRef<"DripScheduledMessage", 'String'>
    readonly contactId: FieldRef<"DripScheduledMessage", 'String'>
    readonly message: FieldRef<"DripScheduledMessage", 'String'>
    readonly mediaUrl: FieldRef<"DripScheduledMessage", 'String'>
    readonly mediaType: FieldRef<"DripScheduledMessage", 'String'>
    readonly scheduledFor: FieldRef<"DripScheduledMessage", 'DateTime'>
    readonly status: FieldRef<"DripScheduledMessage", 'String'>
    readonly sentAt: FieldRef<"DripScheduledMessage", 'DateTime'>
    readonly createdAt: FieldRef<"DripScheduledMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DripScheduledMessage findUnique
   */
  export type DripScheduledMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    /**
     * Filter, which DripScheduledMessage to fetch.
     */
    where: DripScheduledMessageWhereUniqueInput
  }

  /**
   * DripScheduledMessage findUniqueOrThrow
   */
  export type DripScheduledMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    /**
     * Filter, which DripScheduledMessage to fetch.
     */
    where: DripScheduledMessageWhereUniqueInput
  }

  /**
   * DripScheduledMessage findFirst
   */
  export type DripScheduledMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    /**
     * Filter, which DripScheduledMessage to fetch.
     */
    where?: DripScheduledMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripScheduledMessages to fetch.
     */
    orderBy?: DripScheduledMessageOrderByWithRelationInput | DripScheduledMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DripScheduledMessages.
     */
    cursor?: DripScheduledMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripScheduledMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripScheduledMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DripScheduledMessages.
     */
    distinct?: DripScheduledMessageScalarFieldEnum | DripScheduledMessageScalarFieldEnum[]
  }

  /**
   * DripScheduledMessage findFirstOrThrow
   */
  export type DripScheduledMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    /**
     * Filter, which DripScheduledMessage to fetch.
     */
    where?: DripScheduledMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripScheduledMessages to fetch.
     */
    orderBy?: DripScheduledMessageOrderByWithRelationInput | DripScheduledMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DripScheduledMessages.
     */
    cursor?: DripScheduledMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripScheduledMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripScheduledMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DripScheduledMessages.
     */
    distinct?: DripScheduledMessageScalarFieldEnum | DripScheduledMessageScalarFieldEnum[]
  }

  /**
   * DripScheduledMessage findMany
   */
  export type DripScheduledMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    /**
     * Filter, which DripScheduledMessages to fetch.
     */
    where?: DripScheduledMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DripScheduledMessages to fetch.
     */
    orderBy?: DripScheduledMessageOrderByWithRelationInput | DripScheduledMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DripScheduledMessages.
     */
    cursor?: DripScheduledMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DripScheduledMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DripScheduledMessages.
     */
    skip?: number
    distinct?: DripScheduledMessageScalarFieldEnum | DripScheduledMessageScalarFieldEnum[]
  }

  /**
   * DripScheduledMessage create
   */
  export type DripScheduledMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a DripScheduledMessage.
     */
    data: XOR<DripScheduledMessageCreateInput, DripScheduledMessageUncheckedCreateInput>
  }

  /**
   * DripScheduledMessage createMany
   */
  export type DripScheduledMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DripScheduledMessages.
     */
    data: DripScheduledMessageCreateManyInput | DripScheduledMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DripScheduledMessage update
   */
  export type DripScheduledMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a DripScheduledMessage.
     */
    data: XOR<DripScheduledMessageUpdateInput, DripScheduledMessageUncheckedUpdateInput>
    /**
     * Choose, which DripScheduledMessage to update.
     */
    where: DripScheduledMessageWhereUniqueInput
  }

  /**
   * DripScheduledMessage updateMany
   */
  export type DripScheduledMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DripScheduledMessages.
     */
    data: XOR<DripScheduledMessageUpdateManyMutationInput, DripScheduledMessageUncheckedUpdateManyInput>
    /**
     * Filter which DripScheduledMessages to update
     */
    where?: DripScheduledMessageWhereInput
  }

  /**
   * DripScheduledMessage upsert
   */
  export type DripScheduledMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the DripScheduledMessage to update in case it exists.
     */
    where: DripScheduledMessageWhereUniqueInput
    /**
     * In case the DripScheduledMessage found by the `where` argument doesn't exist, create a new DripScheduledMessage with this data.
     */
    create: XOR<DripScheduledMessageCreateInput, DripScheduledMessageUncheckedCreateInput>
    /**
     * In case the DripScheduledMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DripScheduledMessageUpdateInput, DripScheduledMessageUncheckedUpdateInput>
  }

  /**
   * DripScheduledMessage delete
   */
  export type DripScheduledMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
    /**
     * Filter which DripScheduledMessage to delete.
     */
    where: DripScheduledMessageWhereUniqueInput
  }

  /**
   * DripScheduledMessage deleteMany
   */
  export type DripScheduledMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DripScheduledMessages to delete
     */
    where?: DripScheduledMessageWhereInput
  }

  /**
   * DripScheduledMessage without action
   */
  export type DripScheduledMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DripScheduledMessage
     */
    select?: DripScheduledMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DripScheduledMessageInclude<ExtArgs> | null
  }


  /**
   * Model WebhookLog
   */

  export type AggregateWebhookLog = {
    _count: WebhookLogCountAggregateOutputType | null
    _avg: WebhookLogAvgAggregateOutputType | null
    _sum: WebhookLogSumAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  export type WebhookLogAvgAggregateOutputType = {
    status: number | null
    retries: number | null
  }

  export type WebhookLogSumAggregateOutputType = {
    status: number | null
    retries: number | null
  }

  export type WebhookLogMinAggregateOutputType = {
    id: string | null
    event: string | null
    status: number | null
    error: string | null
    retries: number | null
    createdAt: Date | null
  }

  export type WebhookLogMaxAggregateOutputType = {
    id: string | null
    event: string | null
    status: number | null
    error: string | null
    retries: number | null
    createdAt: Date | null
  }

  export type WebhookLogCountAggregateOutputType = {
    id: number
    event: number
    payload: number
    status: number
    error: number
    retries: number
    createdAt: number
    _all: number
  }


  export type WebhookLogAvgAggregateInputType = {
    status?: true
    retries?: true
  }

  export type WebhookLogSumAggregateInputType = {
    status?: true
    retries?: true
  }

  export type WebhookLogMinAggregateInputType = {
    id?: true
    event?: true
    status?: true
    error?: true
    retries?: true
    createdAt?: true
  }

  export type WebhookLogMaxAggregateInputType = {
    id?: true
    event?: true
    status?: true
    error?: true
    retries?: true
    createdAt?: true
  }

  export type WebhookLogCountAggregateInputType = {
    id?: true
    event?: true
    payload?: true
    status?: true
    error?: true
    retries?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookLog to aggregate.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookLogs
    **/
    _count?: true | WebhookLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookLogMaxAggregateInputType
  }

  export type GetWebhookLogAggregateType<T extends WebhookLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookLog[P]>
      : GetScalarType<T[P], AggregateWebhookLog[P]>
  }




  export type WebhookLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookLogWhereInput
    orderBy?: WebhookLogOrderByWithAggregationInput | WebhookLogOrderByWithAggregationInput[]
    by: WebhookLogScalarFieldEnum[] | WebhookLogScalarFieldEnum
    having?: WebhookLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookLogCountAggregateInputType | true
    _avg?: WebhookLogAvgAggregateInputType
    _sum?: WebhookLogSumAggregateInputType
    _min?: WebhookLogMinAggregateInputType
    _max?: WebhookLogMaxAggregateInputType
  }

  export type WebhookLogGroupByOutputType = {
    id: string
    event: string
    payload: JsonValue
    status: number
    error: string | null
    retries: number
    createdAt: Date
    _count: WebhookLogCountAggregateOutputType | null
    _avg: WebhookLogAvgAggregateOutputType | null
    _sum: WebhookLogSumAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  type GetWebhookLogGroupByPayload<T extends WebhookLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
        }
      >
    >


  export type WebhookLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event?: boolean
    payload?: boolean
    status?: boolean
    error?: boolean
    retries?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>


  export type WebhookLogSelectScalar = {
    id?: boolean
    event?: boolean
    payload?: boolean
    status?: boolean
    error?: boolean
    retries?: boolean
    createdAt?: boolean
  }


  export type $WebhookLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      event: string
      payload: Prisma.JsonValue
      status: number
      error: string | null
      retries: number
      createdAt: Date
    }, ExtArgs["result"]["webhookLog"]>
    composites: {}
  }

  type WebhookLogGetPayload<S extends boolean | null | undefined | WebhookLogDefaultArgs> = $Result.GetResult<Prisma.$WebhookLogPayload, S>

  type WebhookLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookLogCountAggregateInputType | true
    }

  export interface WebhookLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookLog'], meta: { name: 'WebhookLog' } }
    /**
     * Find zero or one WebhookLog that matches the filter.
     * @param {WebhookLogFindUniqueArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookLogFindUniqueArgs>(args: SelectSubset<T, WebhookLogFindUniqueArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookLogFindUniqueOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindFirstArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookLogFindFirstArgs>(args?: SelectSubset<T, WebhookLogFindFirstArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindFirstOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany()
     * 
     * // Get first 10 WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookLogFindManyArgs>(args?: SelectSubset<T, WebhookLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookLog.
     * @param {WebhookLogCreateArgs} args - Arguments to create a WebhookLog.
     * @example
     * // Create one WebhookLog
     * const WebhookLog = await prisma.webhookLog.create({
     *   data: {
     *     // ... data to create a WebhookLog
     *   }
     * })
     * 
     */
    create<T extends WebhookLogCreateArgs>(args: SelectSubset<T, WebhookLogCreateArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookLogs.
     * @param {WebhookLogCreateManyArgs} args - Arguments to create many WebhookLogs.
     * @example
     * // Create many WebhookLogs
     * const webhookLog = await prisma.webhookLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookLogCreateManyArgs>(args?: SelectSubset<T, WebhookLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WebhookLog.
     * @param {WebhookLogDeleteArgs} args - Arguments to delete one WebhookLog.
     * @example
     * // Delete one WebhookLog
     * const WebhookLog = await prisma.webhookLog.delete({
     *   where: {
     *     // ... filter to delete one WebhookLog
     *   }
     * })
     * 
     */
    delete<T extends WebhookLogDeleteArgs>(args: SelectSubset<T, WebhookLogDeleteArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookLog.
     * @param {WebhookLogUpdateArgs} args - Arguments to update one WebhookLog.
     * @example
     * // Update one WebhookLog
     * const webhookLog = await prisma.webhookLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookLogUpdateArgs>(args: SelectSubset<T, WebhookLogUpdateArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookLogs.
     * @param {WebhookLogDeleteManyArgs} args - Arguments to filter WebhookLogs to delete.
     * @example
     * // Delete a few WebhookLogs
     * const { count } = await prisma.webhookLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookLogDeleteManyArgs>(args?: SelectSubset<T, WebhookLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookLogs
     * const webhookLog = await prisma.webhookLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookLogUpdateManyArgs>(args: SelectSubset<T, WebhookLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookLog.
     * @param {WebhookLogUpsertArgs} args - Arguments to update or create a WebhookLog.
     * @example
     * // Update or create a WebhookLog
     * const webhookLog = await prisma.webhookLog.upsert({
     *   create: {
     *     // ... data to create a WebhookLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookLog we want to update
     *   }
     * })
     */
    upsert<T extends WebhookLogUpsertArgs>(args: SelectSubset<T, WebhookLogUpsertArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogCountArgs} args - Arguments to filter WebhookLogs to count.
     * @example
     * // Count the number of WebhookLogs
     * const count = await prisma.webhookLog.count({
     *   where: {
     *     // ... the filter for the WebhookLogs we want to count
     *   }
     * })
    **/
    count<T extends WebhookLogCountArgs>(
      args?: Subset<T, WebhookLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookLogAggregateArgs>(args: Subset<T, WebhookLogAggregateArgs>): Prisma.PrismaPromise<GetWebhookLogAggregateType<T>>

    /**
     * Group by WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookLogGroupByArgs['orderBy'] }
        : { orderBy?: WebhookLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookLog model
   */
  readonly fields: WebhookLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookLog model
   */ 
  interface WebhookLogFieldRefs {
    readonly id: FieldRef<"WebhookLog", 'String'>
    readonly event: FieldRef<"WebhookLog", 'String'>
    readonly payload: FieldRef<"WebhookLog", 'Json'>
    readonly status: FieldRef<"WebhookLog", 'Int'>
    readonly error: FieldRef<"WebhookLog", 'String'>
    readonly retries: FieldRef<"WebhookLog", 'Int'>
    readonly createdAt: FieldRef<"WebhookLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookLog findUnique
   */
  export type WebhookLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog findUniqueOrThrow
   */
  export type WebhookLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog findFirst
   */
  export type WebhookLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog findFirstOrThrow
   */
  export type WebhookLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog findMany
   */
  export type WebhookLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter, which WebhookLogs to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog create
   */
  export type WebhookLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * The data needed to create a WebhookLog.
     */
    data: XOR<WebhookLogCreateInput, WebhookLogUncheckedCreateInput>
  }

  /**
   * WebhookLog createMany
   */
  export type WebhookLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookLogs.
     */
    data: WebhookLogCreateManyInput | WebhookLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookLog update
   */
  export type WebhookLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * The data needed to update a WebhookLog.
     */
    data: XOR<WebhookLogUpdateInput, WebhookLogUncheckedUpdateInput>
    /**
     * Choose, which WebhookLog to update.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog updateMany
   */
  export type WebhookLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookLogs.
     */
    data: XOR<WebhookLogUpdateManyMutationInput, WebhookLogUncheckedUpdateManyInput>
    /**
     * Filter which WebhookLogs to update
     */
    where?: WebhookLogWhereInput
  }

  /**
   * WebhookLog upsert
   */
  export type WebhookLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * The filter to search for the WebhookLog to update in case it exists.
     */
    where: WebhookLogWhereUniqueInput
    /**
     * In case the WebhookLog found by the `where` argument doesn't exist, create a new WebhookLog with this data.
     */
    create: XOR<WebhookLogCreateInput, WebhookLogUncheckedCreateInput>
    /**
     * In case the WebhookLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookLogUpdateInput, WebhookLogUncheckedUpdateInput>
  }

  /**
   * WebhookLog delete
   */
  export type WebhookLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Filter which WebhookLog to delete.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog deleteMany
   */
  export type WebhookLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookLogs to delete
     */
    where?: WebhookLogWhereInput
  }

  /**
   * WebhookLog without action
   */
  export type WebhookLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    name: 'name',
    avatarUrl: 'avatarUrl',
    role: 'role',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    phoneNumber: 'phoneNumber',
    name: 'name',
    pushName: 'pushName',
    businessName: 'businessName',
    email: 'email',
    avatarUrl: 'avatarUrl',
    profilePhotoUrl: 'profilePhotoUrl',
    company: 'company',
    department: 'department',
    contactType: 'contactType',
    timezone: 'timezone',
    lastMessageAt: 'lastMessageAt',
    lastActiveAt: 'lastActiveAt',
    engagementScore: 'engagementScore',
    engagementLevel: 'engagementLevel',
    messageCount: 'messageCount',
    totalInteractions: 'totalInteractions',
    isBlocked: 'isBlocked',
    isBusiness: 'isBusiness',
    isVerified: 'isVerified',
    customFields: 'customFields',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    contactId: 'contactId',
    isActive: 'isActive',
    unreadCount: 'unreadCount',
    lastMessageAt: 'lastMessageAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    contactId: 'contactId',
    conversationId: 'conversationId',
    waMessageId: 'waMessageId',
    content: 'content',
    messageType: 'messageType',
    direction: 'direction',
    status: 'status',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    mediaFileName: 'mediaFileName',
    quotedMessageId: 'quotedMessageId',
    isGroupMessage: 'isGroupMessage',
    groupId: 'groupId',
    groupName: 'groupName',
    isStatusUpdate: 'isStatusUpdate',
    isChannelMessage: 'isChannelMessage',
    channelId: 'channelId',
    senderName: 'senderName',
    templateId: 'templateId',
    quickReplyId: 'quickReplyId',
    tagIds: 'tagIds',
    metadata: 'metadata',
    scheduledAt: 'scheduledAt',
    sendAt: 'sendAt',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ReactionScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    emoji: 'emoji',
    createdAt: 'createdAt'
  };

  export type ReactionScalarFieldEnum = (typeof ReactionScalarFieldEnum)[keyof typeof ReactionScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    color: 'color',
    createdAt: 'createdAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TagOnContactScalarFieldEnum: {
    contactId: 'contactId',
    tagId: 'tagId',
    assignedAt: 'assignedAt'
  };

  export type TagOnContactScalarFieldEnum = (typeof TagOnContactScalarFieldEnum)[keyof typeof TagOnContactScalarFieldEnum]


  export const SegmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    criteria: 'criteria',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SegmentScalarFieldEnum = (typeof SegmentScalarFieldEnum)[keyof typeof SegmentScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    templateId: 'templateId',
    content: 'content',
    mediaUrl: 'mediaUrl',
    scheduleTime: 'scheduleTime',
    sentAt: 'sentAt',
    completedAt: 'completedAt',
    recipientCount: 'recipientCount',
    sentCount: 'sentCount',
    failedCount: 'failedCount',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const QuickReplyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    category: 'category',
    shortcut: 'shortcut',
    isActive: 'isActive',
    usageCount: 'usageCount',
    usageTodayCount: 'usageTodayCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuickReplyScalarFieldEnum = (typeof QuickReplyScalarFieldEnum)[keyof typeof QuickReplyScalarFieldEnum]


  export const MessageTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    language: 'language',
    content: 'content',
    variables: 'variables',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type MessageTemplateScalarFieldEnum = (typeof MessageTemplateScalarFieldEnum)[keyof typeof MessageTemplateScalarFieldEnum]


  export const AutomationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    trigger: 'trigger',
    actions: 'actions',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutomationScalarFieldEnum = (typeof AutomationScalarFieldEnum)[keyof typeof AutomationScalarFieldEnum]


  export const AutoReplyScalarFieldEnum: {
    id: 'id',
    isActive: 'isActive',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutoReplyScalarFieldEnum = (typeof AutoReplyScalarFieldEnum)[keyof typeof AutoReplyScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    contactId: 'contactId',
    messageId: 'messageId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const AppConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppConfigScalarFieldEnum = (typeof AppConfigScalarFieldEnum)[keyof typeof AppConfigScalarFieldEnum]


  export const DripCampaignScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    triggerType: 'triggerType',
    triggerValue: 'triggerValue',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DripCampaignScalarFieldEnum = (typeof DripCampaignScalarFieldEnum)[keyof typeof DripCampaignScalarFieldEnum]


  export const DripCampaignStepScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    sequence: 'sequence',
    delayHours: 'delayHours',
    message: 'message',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    createdAt: 'createdAt'
  };

  export type DripCampaignStepScalarFieldEnum = (typeof DripCampaignStepScalarFieldEnum)[keyof typeof DripCampaignStepScalarFieldEnum]


  export const DripEnrollmentScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    contactId: 'contactId',
    currentStep: 'currentStep',
    status: 'status',
    enrolledAt: 'enrolledAt',
    completedAt: 'completedAt'
  };

  export type DripEnrollmentScalarFieldEnum = (typeof DripEnrollmentScalarFieldEnum)[keyof typeof DripEnrollmentScalarFieldEnum]


  export const DripScheduledMessageScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    stepId: 'stepId',
    contactId: 'contactId',
    message: 'message',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    scheduledFor: 'scheduledFor',
    status: 'status',
    sentAt: 'sentAt',
    createdAt: 'createdAt'
  };

  export type DripScheduledMessageScalarFieldEnum = (typeof DripScheduledMessageScalarFieldEnum)[keyof typeof DripScheduledMessageScalarFieldEnum]


  export const WebhookLogScalarFieldEnum: {
    id: 'id',
    event: 'event',
    payload: 'payload',
    status: 'status',
    error: 'error',
    retries: 'retries',
    createdAt: 'createdAt'
  };

  export type WebhookLogScalarFieldEnum = (typeof WebhookLogScalarFieldEnum)[keyof typeof WebhookLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    name: 'name',
    avatarUrl: 'avatarUrl'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const ContactOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    phoneNumber: 'phoneNumber',
    name: 'name',
    pushName: 'pushName',
    businessName: 'businessName',
    email: 'email',
    avatarUrl: 'avatarUrl',
    profilePhotoUrl: 'profilePhotoUrl',
    company: 'company',
    department: 'department',
    contactType: 'contactType',
    timezone: 'timezone',
    engagementLevel: 'engagementLevel'
  };

  export type ContactOrderByRelevanceFieldEnum = (typeof ContactOrderByRelevanceFieldEnum)[keyof typeof ContactOrderByRelevanceFieldEnum]


  export const ConversationOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    contactId: 'contactId'
  };

  export type ConversationOrderByRelevanceFieldEnum = (typeof ConversationOrderByRelevanceFieldEnum)[keyof typeof ConversationOrderByRelevanceFieldEnum]


  export const MessageOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    contactId: 'contactId',
    conversationId: 'conversationId',
    waMessageId: 'waMessageId',
    content: 'content',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    mediaFileName: 'mediaFileName',
    quotedMessageId: 'quotedMessageId',
    groupId: 'groupId',
    groupName: 'groupName',
    channelId: 'channelId',
    senderName: 'senderName',
    templateId: 'templateId',
    quickReplyId: 'quickReplyId'
  };

  export type MessageOrderByRelevanceFieldEnum = (typeof MessageOrderByRelevanceFieldEnum)[keyof typeof MessageOrderByRelevanceFieldEnum]


  export const ReactionOrderByRelevanceFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    emoji: 'emoji'
  };

  export type ReactionOrderByRelevanceFieldEnum = (typeof ReactionOrderByRelevanceFieldEnum)[keyof typeof ReactionOrderByRelevanceFieldEnum]


  export const TagOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    color: 'color'
  };

  export type TagOrderByRelevanceFieldEnum = (typeof TagOrderByRelevanceFieldEnum)[keyof typeof TagOrderByRelevanceFieldEnum]


  export const TagOnContactOrderByRelevanceFieldEnum: {
    contactId: 'contactId',
    tagId: 'tagId'
  };

  export type TagOnContactOrderByRelevanceFieldEnum = (typeof TagOnContactOrderByRelevanceFieldEnum)[keyof typeof TagOnContactOrderByRelevanceFieldEnum]


  export const SegmentOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name'
  };

  export type SegmentOrderByRelevanceFieldEnum = (typeof SegmentOrderByRelevanceFieldEnum)[keyof typeof SegmentOrderByRelevanceFieldEnum]


  export const CampaignOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    templateId: 'templateId',
    content: 'content',
    mediaUrl: 'mediaUrl'
  };

  export type CampaignOrderByRelevanceFieldEnum = (typeof CampaignOrderByRelevanceFieldEnum)[keyof typeof CampaignOrderByRelevanceFieldEnum]


  export const QuickReplyOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    category: 'category',
    shortcut: 'shortcut'
  };

  export type QuickReplyOrderByRelevanceFieldEnum = (typeof QuickReplyOrderByRelevanceFieldEnum)[keyof typeof QuickReplyOrderByRelevanceFieldEnum]


  export const MessageTemplateOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    language: 'language',
    content: 'content'
  };

  export type MessageTemplateOrderByRelevanceFieldEnum = (typeof MessageTemplateOrderByRelevanceFieldEnum)[keyof typeof MessageTemplateOrderByRelevanceFieldEnum]


  export const AutomationOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    trigger: 'trigger'
  };

  export type AutomationOrderByRelevanceFieldEnum = (typeof AutomationOrderByRelevanceFieldEnum)[keyof typeof AutomationOrderByRelevanceFieldEnum]


  export const AutoReplyOrderByRelevanceFieldEnum: {
    id: 'id',
    message: 'message'
  };

  export type AutoReplyOrderByRelevanceFieldEnum = (typeof AutoReplyOrderByRelevanceFieldEnum)[keyof typeof AutoReplyOrderByRelevanceFieldEnum]


  export const NoteOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    contactId: 'contactId',
    messageId: 'messageId',
    content: 'content'
  };

  export type NoteOrderByRelevanceFieldEnum = (typeof NoteOrderByRelevanceFieldEnum)[keyof typeof NoteOrderByRelevanceFieldEnum]


  export const ActivityLogOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type ActivityLogOrderByRelevanceFieldEnum = (typeof ActivityLogOrderByRelevanceFieldEnum)[keyof typeof ActivityLogOrderByRelevanceFieldEnum]


  export const AppConfigOrderByRelevanceFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type AppConfigOrderByRelevanceFieldEnum = (typeof AppConfigOrderByRelevanceFieldEnum)[keyof typeof AppConfigOrderByRelevanceFieldEnum]


  export const DripCampaignOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    triggerValue: 'triggerValue'
  };

  export type DripCampaignOrderByRelevanceFieldEnum = (typeof DripCampaignOrderByRelevanceFieldEnum)[keyof typeof DripCampaignOrderByRelevanceFieldEnum]


  export const DripCampaignStepOrderByRelevanceFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    message: 'message',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType'
  };

  export type DripCampaignStepOrderByRelevanceFieldEnum = (typeof DripCampaignStepOrderByRelevanceFieldEnum)[keyof typeof DripCampaignStepOrderByRelevanceFieldEnum]


  export const DripEnrollmentOrderByRelevanceFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    contactId: 'contactId'
  };

  export type DripEnrollmentOrderByRelevanceFieldEnum = (typeof DripEnrollmentOrderByRelevanceFieldEnum)[keyof typeof DripEnrollmentOrderByRelevanceFieldEnum]


  export const DripScheduledMessageOrderByRelevanceFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    stepId: 'stepId',
    contactId: 'contactId',
    message: 'message',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    status: 'status'
  };

  export type DripScheduledMessageOrderByRelevanceFieldEnum = (typeof DripScheduledMessageOrderByRelevanceFieldEnum)[keyof typeof DripScheduledMessageOrderByRelevanceFieldEnum]


  export const WebhookLogOrderByRelevanceFieldEnum: {
    id: 'id',
    event: 'event',
    error: 'error'
  };

  export type WebhookLogOrderByRelevanceFieldEnum = (typeof WebhookLogOrderByRelevanceFieldEnum)[keyof typeof WebhookLogOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageDirection'
   */
  export type EnumMessageDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageDirection'>
    


  /**
   * Reference to a field of type 'MessageStatus'
   */
  export type EnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus'>
    


  /**
   * Reference to a field of type 'CampaignType'
   */
  export type EnumCampaignTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignType'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ConfigType'
   */
  export type EnumConfigTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConfigType'>
    


  /**
   * Reference to a field of type 'DripTriggerType'
   */
  export type EnumDripTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DripTriggerType'>
    


  /**
   * Reference to a field of type 'DripEnrollmentStatus'
   */
  export type EnumDripEnrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DripEnrollmentStatus'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    conversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
    contacts?: ContactListRelationFilter
    tags?: TagListRelationFilter
    segments?: SegmentListRelationFilter
    quickReplies?: QuickReplyListRelationFilter
    automations?: AutomationListRelationFilter
    notes?: NoteListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    dripCampaigns?: DripCampaignListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    conversations?: ConversationOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    segments?: SegmentOrderByRelationAggregateInput
    quickReplies?: QuickReplyOrderByRelationAggregateInput
    automations?: AutomationOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    dripCampaigns?: DripCampaignOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    conversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
    contacts?: ContactListRelationFilter
    tags?: TagListRelationFilter
    segments?: SegmentListRelationFilter
    quickReplies?: QuickReplyListRelationFilter
    automations?: AutomationListRelationFilter
    notes?: NoteListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    dripCampaigns?: DripCampaignListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    userId?: StringFilter<"Contact"> | string
    phoneNumber?: StringFilter<"Contact"> | string
    name?: StringNullableFilter<"Contact"> | string | null
    pushName?: StringNullableFilter<"Contact"> | string | null
    businessName?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    avatarUrl?: StringNullableFilter<"Contact"> | string | null
    profilePhotoUrl?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    department?: StringNullableFilter<"Contact"> | string | null
    contactType?: StringFilter<"Contact"> | string
    timezone?: StringNullableFilter<"Contact"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    lastActiveAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    engagementScore?: FloatFilter<"Contact"> | number
    engagementLevel?: StringFilter<"Contact"> | string
    messageCount?: IntFilter<"Contact"> | number
    totalInteractions?: IntFilter<"Contact"> | number
    isBlocked?: BoolFilter<"Contact"> | boolean
    isBusiness?: BoolFilter<"Contact"> | boolean
    isVerified?: BoolFilter<"Contact"> | boolean
    customFields?: JsonNullableFilter<"Contact">
    metadata?: JsonNullableFilter<"Contact">
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    conversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
    tags?: TagOnContactListRelationFilter
    notes?: NoteListRelationFilter
    dripEnrollments?: DripEnrollmentListRelationFilter
    dripScheduled?: DripScheduledMessageListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrderInput | SortOrder
    pushName?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    profilePhotoUrl?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    contactType?: SortOrder
    timezone?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    engagementScore?: SortOrder
    engagementLevel?: SortOrder
    messageCount?: SortOrder
    totalInteractions?: SortOrder
    isBlocked?: SortOrder
    isBusiness?: SortOrder
    isVerified?: SortOrder
    customFields?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    conversations?: ConversationOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    tags?: TagOnContactOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    dripEnrollments?: DripEnrollmentOrderByRelationAggregateInput
    dripScheduled?: DripScheduledMessageOrderByRelationAggregateInput
    _relevance?: ContactOrderByRelevanceInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_phoneNumber?: ContactUserIdPhoneNumberCompoundUniqueInput
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    userId?: StringFilter<"Contact"> | string
    phoneNumber?: StringFilter<"Contact"> | string
    name?: StringNullableFilter<"Contact"> | string | null
    pushName?: StringNullableFilter<"Contact"> | string | null
    businessName?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    avatarUrl?: StringNullableFilter<"Contact"> | string | null
    profilePhotoUrl?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    department?: StringNullableFilter<"Contact"> | string | null
    contactType?: StringFilter<"Contact"> | string
    timezone?: StringNullableFilter<"Contact"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    lastActiveAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    engagementScore?: FloatFilter<"Contact"> | number
    engagementLevel?: StringFilter<"Contact"> | string
    messageCount?: IntFilter<"Contact"> | number
    totalInteractions?: IntFilter<"Contact"> | number
    isBlocked?: BoolFilter<"Contact"> | boolean
    isBusiness?: BoolFilter<"Contact"> | boolean
    isVerified?: BoolFilter<"Contact"> | boolean
    customFields?: JsonNullableFilter<"Contact">
    metadata?: JsonNullableFilter<"Contact">
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    conversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
    tags?: TagOnContactListRelationFilter
    notes?: NoteListRelationFilter
    dripEnrollments?: DripEnrollmentListRelationFilter
    dripScheduled?: DripScheduledMessageListRelationFilter
  }, "id" | "userId_phoneNumber">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrderInput | SortOrder
    pushName?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    profilePhotoUrl?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    contactType?: SortOrder
    timezone?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    engagementScore?: SortOrder
    engagementLevel?: SortOrder
    messageCount?: SortOrder
    totalInteractions?: SortOrder
    isBlocked?: SortOrder
    isBusiness?: SortOrder
    isVerified?: SortOrder
    customFields?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    userId?: StringWithAggregatesFilter<"Contact"> | string
    phoneNumber?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    pushName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    businessName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    profilePhotoUrl?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    company?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    department?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    contactType?: StringWithAggregatesFilter<"Contact"> | string
    timezone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
    engagementScore?: FloatWithAggregatesFilter<"Contact"> | number
    engagementLevel?: StringWithAggregatesFilter<"Contact"> | string
    messageCount?: IntWithAggregatesFilter<"Contact"> | number
    totalInteractions?: IntWithAggregatesFilter<"Contact"> | number
    isBlocked?: BoolWithAggregatesFilter<"Contact"> | boolean
    isBusiness?: BoolWithAggregatesFilter<"Contact"> | boolean
    isVerified?: BoolWithAggregatesFilter<"Contact"> | boolean
    customFields?: JsonNullableWithAggregatesFilter<"Contact">
    metadata?: JsonNullableWithAggregatesFilter<"Contact">
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    contactId?: StringFilter<"Conversation"> | string
    isActive?: BoolFilter<"Conversation"> | boolean
    unreadCount?: IntFilter<"Conversation"> | number
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    metadata?: JsonNullableFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    isActive?: SortOrder
    unreadCount?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    _relevance?: ConversationOrderByRelevanceInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_contactId?: ConversationUserIdContactIdCompoundUniqueInput
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    userId?: StringFilter<"Conversation"> | string
    contactId?: StringFilter<"Conversation"> | string
    isActive?: BoolFilter<"Conversation"> | boolean
    unreadCount?: IntFilter<"Conversation"> | number
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    metadata?: JsonNullableFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    messages?: MessageListRelationFilter
  }, "id" | "userId_contactId">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    isActive?: SortOrder
    unreadCount?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _avg?: ConversationAvgOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
    _sum?: ConversationSumOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    userId?: StringWithAggregatesFilter<"Conversation"> | string
    contactId?: StringWithAggregatesFilter<"Conversation"> | string
    isActive?: BoolWithAggregatesFilter<"Conversation"> | boolean
    unreadCount?: IntWithAggregatesFilter<"Conversation"> | number
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Conversation">
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    userId?: StringFilter<"Message"> | string
    contactId?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    waMessageId?: StringNullableFilter<"Message"> | string | null
    content?: StringNullableFilter<"Message"> | string | null
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    direction?: EnumMessageDirectionFilter<"Message"> | $Enums.MessageDirection
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    mediaType?: StringNullableFilter<"Message"> | string | null
    mediaFileName?: StringNullableFilter<"Message"> | string | null
    quotedMessageId?: StringNullableFilter<"Message"> | string | null
    isGroupMessage?: BoolFilter<"Message"> | boolean
    groupId?: StringNullableFilter<"Message"> | string | null
    groupName?: StringNullableFilter<"Message"> | string | null
    isStatusUpdate?: BoolFilter<"Message"> | boolean
    isChannelMessage?: BoolFilter<"Message"> | boolean
    channelId?: StringNullableFilter<"Message"> | string | null
    senderName?: StringNullableFilter<"Message"> | string | null
    templateId?: StringNullableFilter<"Message"> | string | null
    quickReplyId?: StringNullableFilter<"Message"> | string | null
    tagIds?: JsonNullableFilter<"Message">
    metadata?: JsonNullableFilter<"Message">
    scheduledAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    sendAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    reactions?: ReactionListRelationFilter
    notes?: NoteListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    conversationId?: SortOrder
    waMessageId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    messageType?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    mediaFileName?: SortOrderInput | SortOrder
    quotedMessageId?: SortOrderInput | SortOrder
    isGroupMessage?: SortOrder
    groupId?: SortOrderInput | SortOrder
    groupName?: SortOrderInput | SortOrder
    isStatusUpdate?: SortOrder
    isChannelMessage?: SortOrder
    channelId?: SortOrderInput | SortOrder
    senderName?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    quickReplyId?: SortOrderInput | SortOrder
    tagIds?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sendAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    conversation?: ConversationOrderByWithRelationInput
    reactions?: ReactionOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    _relevance?: MessageOrderByRelevanceInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    waMessageId?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    userId?: StringFilter<"Message"> | string
    contactId?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    direction?: EnumMessageDirectionFilter<"Message"> | $Enums.MessageDirection
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    mediaType?: StringNullableFilter<"Message"> | string | null
    mediaFileName?: StringNullableFilter<"Message"> | string | null
    quotedMessageId?: StringNullableFilter<"Message"> | string | null
    isGroupMessage?: BoolFilter<"Message"> | boolean
    groupId?: StringNullableFilter<"Message"> | string | null
    groupName?: StringNullableFilter<"Message"> | string | null
    isStatusUpdate?: BoolFilter<"Message"> | boolean
    isChannelMessage?: BoolFilter<"Message"> | boolean
    channelId?: StringNullableFilter<"Message"> | string | null
    senderName?: StringNullableFilter<"Message"> | string | null
    templateId?: StringNullableFilter<"Message"> | string | null
    quickReplyId?: StringNullableFilter<"Message"> | string | null
    tagIds?: JsonNullableFilter<"Message">
    metadata?: JsonNullableFilter<"Message">
    scheduledAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    sendAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    reactions?: ReactionListRelationFilter
    notes?: NoteListRelationFilter
  }, "id" | "waMessageId">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    conversationId?: SortOrder
    waMessageId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    messageType?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    mediaFileName?: SortOrderInput | SortOrder
    quotedMessageId?: SortOrderInput | SortOrder
    isGroupMessage?: SortOrder
    groupId?: SortOrderInput | SortOrder
    groupName?: SortOrderInput | SortOrder
    isStatusUpdate?: SortOrder
    isChannelMessage?: SortOrder
    channelId?: SortOrderInput | SortOrder
    senderName?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    quickReplyId?: SortOrderInput | SortOrder
    tagIds?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sendAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    userId?: StringWithAggregatesFilter<"Message"> | string
    contactId?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    waMessageId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    content?: StringNullableWithAggregatesFilter<"Message"> | string | null
    messageType?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    direction?: EnumMessageDirectionWithAggregatesFilter<"Message"> | $Enums.MessageDirection
    status?: EnumMessageStatusWithAggregatesFilter<"Message"> | $Enums.MessageStatus
    mediaUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    mediaType?: StringNullableWithAggregatesFilter<"Message"> | string | null
    mediaFileName?: StringNullableWithAggregatesFilter<"Message"> | string | null
    quotedMessageId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    isGroupMessage?: BoolWithAggregatesFilter<"Message"> | boolean
    groupId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    groupName?: StringNullableWithAggregatesFilter<"Message"> | string | null
    isStatusUpdate?: BoolWithAggregatesFilter<"Message"> | boolean
    isChannelMessage?: BoolWithAggregatesFilter<"Message"> | boolean
    channelId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    senderName?: StringNullableWithAggregatesFilter<"Message"> | string | null
    templateId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    quickReplyId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    tagIds?: JsonNullableWithAggregatesFilter<"Message">
    metadata?: JsonNullableWithAggregatesFilter<"Message">
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    sendAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ReactionWhereInput = {
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    id?: StringFilter<"Reaction"> | string
    messageId?: StringFilter<"Reaction"> | string
    emoji?: StringFilter<"Reaction"> | string
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }

  export type ReactionOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    _relevance?: ReactionOrderByRelevanceInput
  }

  export type ReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_emoji?: ReactionMessageIdEmojiCompoundUniqueInput
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    messageId?: StringFilter<"Reaction"> | string
    emoji?: StringFilter<"Reaction"> | string
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }, "id" | "messageId_emoji">

  export type ReactionOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    _count?: ReactionCountOrderByAggregateInput
    _max?: ReactionMaxOrderByAggregateInput
    _min?: ReactionMinOrderByAggregateInput
  }

  export type ReactionScalarWhereWithAggregatesInput = {
    AND?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    OR?: ReactionScalarWhereWithAggregatesInput[]
    NOT?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reaction"> | string
    messageId?: StringWithAggregatesFilter<"Reaction"> | string
    emoji?: StringWithAggregatesFilter<"Reaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Reaction"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    userId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contacts?: TagOnContactListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    contacts?: TagOnContactOrderByRelationAggregateInput
    _relevance?: TagOrderByRelevanceInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_name?: TagUserIdNameCompoundUniqueInput
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    userId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contacts?: TagOnContactListRelationFilter
  }, "id" | "userId_name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    userId?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type TagOnContactWhereInput = {
    AND?: TagOnContactWhereInput | TagOnContactWhereInput[]
    OR?: TagOnContactWhereInput[]
    NOT?: TagOnContactWhereInput | TagOnContactWhereInput[]
    contactId?: StringFilter<"TagOnContact"> | string
    tagId?: StringFilter<"TagOnContact"> | string
    assignedAt?: DateTimeFilter<"TagOnContact"> | Date | string
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type TagOnContactOrderByWithRelationInput = {
    contactId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
    _relevance?: TagOnContactOrderByRelevanceInput
  }

  export type TagOnContactWhereUniqueInput = Prisma.AtLeast<{
    contactId_tagId?: TagOnContactContactIdTagIdCompoundUniqueInput
    AND?: TagOnContactWhereInput | TagOnContactWhereInput[]
    OR?: TagOnContactWhereInput[]
    NOT?: TagOnContactWhereInput | TagOnContactWhereInput[]
    contactId?: StringFilter<"TagOnContact"> | string
    tagId?: StringFilter<"TagOnContact"> | string
    assignedAt?: DateTimeFilter<"TagOnContact"> | Date | string
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }, "contactId_tagId">

  export type TagOnContactOrderByWithAggregationInput = {
    contactId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
    _count?: TagOnContactCountOrderByAggregateInput
    _max?: TagOnContactMaxOrderByAggregateInput
    _min?: TagOnContactMinOrderByAggregateInput
  }

  export type TagOnContactScalarWhereWithAggregatesInput = {
    AND?: TagOnContactScalarWhereWithAggregatesInput | TagOnContactScalarWhereWithAggregatesInput[]
    OR?: TagOnContactScalarWhereWithAggregatesInput[]
    NOT?: TagOnContactScalarWhereWithAggregatesInput | TagOnContactScalarWhereWithAggregatesInput[]
    contactId?: StringWithAggregatesFilter<"TagOnContact"> | string
    tagId?: StringWithAggregatesFilter<"TagOnContact"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"TagOnContact"> | Date | string
  }

  export type SegmentWhereInput = {
    AND?: SegmentWhereInput | SegmentWhereInput[]
    OR?: SegmentWhereInput[]
    NOT?: SegmentWhereInput | SegmentWhereInput[]
    id?: StringFilter<"Segment"> | string
    userId?: StringFilter<"Segment"> | string
    name?: StringFilter<"Segment"> | string
    criteria?: JsonFilter<"Segment">
    createdAt?: DateTimeFilter<"Segment"> | Date | string
    updatedAt?: DateTimeFilter<"Segment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SegmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: SegmentOrderByRelevanceInput
  }

  export type SegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_name?: SegmentUserIdNameCompoundUniqueInput
    AND?: SegmentWhereInput | SegmentWhereInput[]
    OR?: SegmentWhereInput[]
    NOT?: SegmentWhereInput | SegmentWhereInput[]
    userId?: StringFilter<"Segment"> | string
    name?: StringFilter<"Segment"> | string
    criteria?: JsonFilter<"Segment">
    createdAt?: DateTimeFilter<"Segment"> | Date | string
    updatedAt?: DateTimeFilter<"Segment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_name">

  export type SegmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SegmentCountOrderByAggregateInput
    _max?: SegmentMaxOrderByAggregateInput
    _min?: SegmentMinOrderByAggregateInput
  }

  export type SegmentScalarWhereWithAggregatesInput = {
    AND?: SegmentScalarWhereWithAggregatesInput | SegmentScalarWhereWithAggregatesInput[]
    OR?: SegmentScalarWhereWithAggregatesInput[]
    NOT?: SegmentScalarWhereWithAggregatesInput | SegmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Segment"> | string
    userId?: StringWithAggregatesFilter<"Segment"> | string
    name?: StringWithAggregatesFilter<"Segment"> | string
    criteria?: JsonWithAggregatesFilter<"Segment">
    createdAt?: DateTimeWithAggregatesFilter<"Segment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Segment"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    type?: EnumCampaignTypeFilter<"Campaign"> | $Enums.CampaignType
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    templateId?: StringNullableFilter<"Campaign"> | string | null
    content?: StringNullableFilter<"Campaign"> | string | null
    mediaUrl?: StringNullableFilter<"Campaign"> | string | null
    scheduleTime?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    recipientCount?: IntFilter<"Campaign"> | number
    sentCount?: IntFilter<"Campaign"> | number
    failedCount?: IntFilter<"Campaign"> | number
    metadata?: JsonNullableFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    templateId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    scheduleTime?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: CampaignOrderByRelevanceInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    type?: EnumCampaignTypeFilter<"Campaign"> | $Enums.CampaignType
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    templateId?: StringNullableFilter<"Campaign"> | string | null
    content?: StringNullableFilter<"Campaign"> | string | null
    mediaUrl?: StringNullableFilter<"Campaign"> | string | null
    scheduleTime?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    recipientCount?: IntFilter<"Campaign"> | number
    sentCount?: IntFilter<"Campaign"> | number
    failedCount?: IntFilter<"Campaign"> | number
    metadata?: JsonNullableFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    templateId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    scheduleTime?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    type?: EnumCampaignTypeWithAggregatesFilter<"Campaign"> | $Enums.CampaignType
    status?: EnumCampaignStatusWithAggregatesFilter<"Campaign"> | $Enums.CampaignStatus
    templateId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    content?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    scheduleTime?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    recipientCount?: IntWithAggregatesFilter<"Campaign"> | number
    sentCount?: IntWithAggregatesFilter<"Campaign"> | number
    failedCount?: IntWithAggregatesFilter<"Campaign"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Campaign">
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type QuickReplyWhereInput = {
    AND?: QuickReplyWhereInput | QuickReplyWhereInput[]
    OR?: QuickReplyWhereInput[]
    NOT?: QuickReplyWhereInput | QuickReplyWhereInput[]
    id?: StringFilter<"QuickReply"> | string
    userId?: StringFilter<"QuickReply"> | string
    title?: StringFilter<"QuickReply"> | string
    content?: StringFilter<"QuickReply"> | string
    category?: StringNullableFilter<"QuickReply"> | string | null
    shortcut?: StringNullableFilter<"QuickReply"> | string | null
    isActive?: BoolFilter<"QuickReply"> | boolean
    usageCount?: IntFilter<"QuickReply"> | number
    usageTodayCount?: IntFilter<"QuickReply"> | number
    createdAt?: DateTimeFilter<"QuickReply"> | Date | string
    updatedAt?: DateTimeFilter<"QuickReply"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type QuickReplyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    shortcut?: SortOrderInput | SortOrder
    isActive?: SortOrder
    usageCount?: SortOrder
    usageTodayCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: QuickReplyOrderByRelevanceInput
  }

  export type QuickReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shortcut?: string
    AND?: QuickReplyWhereInput | QuickReplyWhereInput[]
    OR?: QuickReplyWhereInput[]
    NOT?: QuickReplyWhereInput | QuickReplyWhereInput[]
    userId?: StringFilter<"QuickReply"> | string
    title?: StringFilter<"QuickReply"> | string
    content?: StringFilter<"QuickReply"> | string
    category?: StringNullableFilter<"QuickReply"> | string | null
    isActive?: BoolFilter<"QuickReply"> | boolean
    usageCount?: IntFilter<"QuickReply"> | number
    usageTodayCount?: IntFilter<"QuickReply"> | number
    createdAt?: DateTimeFilter<"QuickReply"> | Date | string
    updatedAt?: DateTimeFilter<"QuickReply"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "shortcut">

  export type QuickReplyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    shortcut?: SortOrderInput | SortOrder
    isActive?: SortOrder
    usageCount?: SortOrder
    usageTodayCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuickReplyCountOrderByAggregateInput
    _avg?: QuickReplyAvgOrderByAggregateInput
    _max?: QuickReplyMaxOrderByAggregateInput
    _min?: QuickReplyMinOrderByAggregateInput
    _sum?: QuickReplySumOrderByAggregateInput
  }

  export type QuickReplyScalarWhereWithAggregatesInput = {
    AND?: QuickReplyScalarWhereWithAggregatesInput | QuickReplyScalarWhereWithAggregatesInput[]
    OR?: QuickReplyScalarWhereWithAggregatesInput[]
    NOT?: QuickReplyScalarWhereWithAggregatesInput | QuickReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuickReply"> | string
    userId?: StringWithAggregatesFilter<"QuickReply"> | string
    title?: StringWithAggregatesFilter<"QuickReply"> | string
    content?: StringWithAggregatesFilter<"QuickReply"> | string
    category?: StringNullableWithAggregatesFilter<"QuickReply"> | string | null
    shortcut?: StringNullableWithAggregatesFilter<"QuickReply"> | string | null
    isActive?: BoolWithAggregatesFilter<"QuickReply"> | boolean
    usageCount?: IntWithAggregatesFilter<"QuickReply"> | number
    usageTodayCount?: IntWithAggregatesFilter<"QuickReply"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuickReply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuickReply"> | Date | string
  }

  export type MessageTemplateWhereInput = {
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    id?: StringFilter<"MessageTemplate"> | string
    name?: StringFilter<"MessageTemplate"> | string
    category?: StringFilter<"MessageTemplate"> | string
    language?: StringFilter<"MessageTemplate"> | string
    content?: StringFilter<"MessageTemplate"> | string
    variables?: JsonNullableFilter<"MessageTemplate">
    metadata?: JsonNullableFilter<"MessageTemplate">
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
  }

  export type MessageTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    language?: SortOrder
    content?: SortOrder
    variables?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: MessageTemplateOrderByRelevanceInput
  }

  export type MessageTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_language?: MessageTemplateNameLanguageCompoundUniqueInput
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    name?: StringFilter<"MessageTemplate"> | string
    category?: StringFilter<"MessageTemplate"> | string
    language?: StringFilter<"MessageTemplate"> | string
    content?: StringFilter<"MessageTemplate"> | string
    variables?: JsonNullableFilter<"MessageTemplate">
    metadata?: JsonNullableFilter<"MessageTemplate">
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
  }, "id" | "name_language">

  export type MessageTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    language?: SortOrder
    content?: SortOrder
    variables?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageTemplateCountOrderByAggregateInput
    _max?: MessageTemplateMaxOrderByAggregateInput
    _min?: MessageTemplateMinOrderByAggregateInput
  }

  export type MessageTemplateScalarWhereWithAggregatesInput = {
    AND?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    OR?: MessageTemplateScalarWhereWithAggregatesInput[]
    NOT?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageTemplate"> | string
    name?: StringWithAggregatesFilter<"MessageTemplate"> | string
    category?: StringWithAggregatesFilter<"MessageTemplate"> | string
    language?: StringWithAggregatesFilter<"MessageTemplate"> | string
    content?: StringWithAggregatesFilter<"MessageTemplate"> | string
    variables?: JsonNullableWithAggregatesFilter<"MessageTemplate">
    metadata?: JsonNullableWithAggregatesFilter<"MessageTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"MessageTemplate"> | Date | string
  }

  export type AutomationWhereInput = {
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    id?: StringFilter<"Automation"> | string
    userId?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    trigger?: StringFilter<"Automation"> | string
    actions?: JsonFilter<"Automation">
    isActive?: BoolFilter<"Automation"> | boolean
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AutomationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    trigger?: SortOrder
    actions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AutomationOrderByRelevanceInput
  }

  export type AutomationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    userId?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    trigger?: StringFilter<"Automation"> | string
    actions?: JsonFilter<"Automation">
    isActive?: BoolFilter<"Automation"> | boolean
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AutomationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    trigger?: SortOrder
    actions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AutomationCountOrderByAggregateInput
    _max?: AutomationMaxOrderByAggregateInput
    _min?: AutomationMinOrderByAggregateInput
  }

  export type AutomationScalarWhereWithAggregatesInput = {
    AND?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    OR?: AutomationScalarWhereWithAggregatesInput[]
    NOT?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Automation"> | string
    userId?: StringWithAggregatesFilter<"Automation"> | string
    name?: StringWithAggregatesFilter<"Automation"> | string
    trigger?: StringWithAggregatesFilter<"Automation"> | string
    actions?: JsonWithAggregatesFilter<"Automation">
    isActive?: BoolWithAggregatesFilter<"Automation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
  }

  export type AutoReplyWhereInput = {
    AND?: AutoReplyWhereInput | AutoReplyWhereInput[]
    OR?: AutoReplyWhereInput[]
    NOT?: AutoReplyWhereInput | AutoReplyWhereInput[]
    id?: StringFilter<"AutoReply"> | string
    isActive?: BoolFilter<"AutoReply"> | boolean
    message?: StringFilter<"AutoReply"> | string
    createdAt?: DateTimeFilter<"AutoReply"> | Date | string
    updatedAt?: DateTimeFilter<"AutoReply"> | Date | string
  }

  export type AutoReplyOrderByWithRelationInput = {
    id?: SortOrder
    isActive?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: AutoReplyOrderByRelevanceInput
  }

  export type AutoReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutoReplyWhereInput | AutoReplyWhereInput[]
    OR?: AutoReplyWhereInput[]
    NOT?: AutoReplyWhereInput | AutoReplyWhereInput[]
    isActive?: BoolFilter<"AutoReply"> | boolean
    message?: StringFilter<"AutoReply"> | string
    createdAt?: DateTimeFilter<"AutoReply"> | Date | string
    updatedAt?: DateTimeFilter<"AutoReply"> | Date | string
  }, "id">

  export type AutoReplyOrderByWithAggregationInput = {
    id?: SortOrder
    isActive?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AutoReplyCountOrderByAggregateInput
    _max?: AutoReplyMaxOrderByAggregateInput
    _min?: AutoReplyMinOrderByAggregateInput
  }

  export type AutoReplyScalarWhereWithAggregatesInput = {
    AND?: AutoReplyScalarWhereWithAggregatesInput | AutoReplyScalarWhereWithAggregatesInput[]
    OR?: AutoReplyScalarWhereWithAggregatesInput[]
    NOT?: AutoReplyScalarWhereWithAggregatesInput | AutoReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutoReply"> | string
    isActive?: BoolWithAggregatesFilter<"AutoReply"> | boolean
    message?: StringWithAggregatesFilter<"AutoReply"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AutoReply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutoReply"> | Date | string
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: StringFilter<"Note"> | string
    userId?: StringFilter<"Note"> | string
    contactId?: StringNullableFilter<"Note"> | string | null
    messageId?: StringNullableFilter<"Note"> | string | null
    content?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    message?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    message?: MessageOrderByWithRelationInput
    _relevance?: NoteOrderByRelevanceInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    userId?: StringFilter<"Note"> | string
    contactId?: StringNullableFilter<"Note"> | string | null
    messageId?: StringNullableFilter<"Note"> | string | null
    content?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    message?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
  }, "id">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NoteCountOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Note"> | string
    userId?: StringWithAggregatesFilter<"Note"> | string
    contactId?: StringNullableWithAggregatesFilter<"Note"> | string | null
    messageId?: StringNullableWithAggregatesFilter<"Note"> | string | null
    content?: StringWithAggregatesFilter<"Note"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringFilter<"ActivityLog"> | string
    action?: EnumActivityTypeFilter<"ActivityLog"> | $Enums.ActivityType
    resourceType?: StringNullableFilter<"ActivityLog"> | string | null
    resourceId?: StringNullableFilter<"ActivityLog"> | string | null
    details?: JsonNullableFilter<"ActivityLog">
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: ActivityLogOrderByRelevanceInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: StringFilter<"ActivityLog"> | string
    action?: EnumActivityTypeFilter<"ActivityLog"> | $Enums.ActivityType
    resourceType?: StringNullableFilter<"ActivityLog"> | string | null
    resourceId?: StringNullableFilter<"ActivityLog"> | string | null
    details?: JsonNullableFilter<"ActivityLog">
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    userId?: StringWithAggregatesFilter<"ActivityLog"> | string
    action?: EnumActivityTypeWithAggregatesFilter<"ActivityLog"> | $Enums.ActivityType
    resourceType?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"ActivityLog">
    ipAddress?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type AppConfigWhereInput = {
    AND?: AppConfigWhereInput | AppConfigWhereInput[]
    OR?: AppConfigWhereInput[]
    NOT?: AppConfigWhereInput | AppConfigWhereInput[]
    id?: StringFilter<"AppConfig"> | string
    key?: StringFilter<"AppConfig"> | string
    value?: StringFilter<"AppConfig"> | string
    type?: EnumConfigTypeFilter<"AppConfig"> | $Enums.ConfigType
    createdAt?: DateTimeFilter<"AppConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AppConfig"> | Date | string
  }

  export type AppConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: AppConfigOrderByRelevanceInput
  }

  export type AppConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: AppConfigWhereInput | AppConfigWhereInput[]
    OR?: AppConfigWhereInput[]
    NOT?: AppConfigWhereInput | AppConfigWhereInput[]
    value?: StringFilter<"AppConfig"> | string
    type?: EnumConfigTypeFilter<"AppConfig"> | $Enums.ConfigType
    createdAt?: DateTimeFilter<"AppConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AppConfig"> | Date | string
  }, "id" | "key">

  export type AppConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppConfigCountOrderByAggregateInput
    _max?: AppConfigMaxOrderByAggregateInput
    _min?: AppConfigMinOrderByAggregateInput
  }

  export type AppConfigScalarWhereWithAggregatesInput = {
    AND?: AppConfigScalarWhereWithAggregatesInput | AppConfigScalarWhereWithAggregatesInput[]
    OR?: AppConfigScalarWhereWithAggregatesInput[]
    NOT?: AppConfigScalarWhereWithAggregatesInput | AppConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppConfig"> | string
    key?: StringWithAggregatesFilter<"AppConfig"> | string
    value?: StringWithAggregatesFilter<"AppConfig"> | string
    type?: EnumConfigTypeWithAggregatesFilter<"AppConfig"> | $Enums.ConfigType
    createdAt?: DateTimeWithAggregatesFilter<"AppConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AppConfig"> | Date | string
  }

  export type DripCampaignWhereInput = {
    AND?: DripCampaignWhereInput | DripCampaignWhereInput[]
    OR?: DripCampaignWhereInput[]
    NOT?: DripCampaignWhereInput | DripCampaignWhereInput[]
    id?: StringFilter<"DripCampaign"> | string
    userId?: StringFilter<"DripCampaign"> | string
    name?: StringFilter<"DripCampaign"> | string
    description?: StringNullableFilter<"DripCampaign"> | string | null
    triggerType?: EnumDripTriggerTypeFilter<"DripCampaign"> | $Enums.DripTriggerType
    triggerValue?: StringNullableFilter<"DripCampaign"> | string | null
    isActive?: BoolFilter<"DripCampaign"> | boolean
    createdAt?: DateTimeFilter<"DripCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"DripCampaign"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    steps?: DripCampaignStepListRelationFilter
    enrollments?: DripEnrollmentListRelationFilter
    scheduled?: DripScheduledMessageListRelationFilter
  }

  export type DripCampaignOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    steps?: DripCampaignStepOrderByRelationAggregateInput
    enrollments?: DripEnrollmentOrderByRelationAggregateInput
    scheduled?: DripScheduledMessageOrderByRelationAggregateInput
    _relevance?: DripCampaignOrderByRelevanceInput
  }

  export type DripCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DripCampaignWhereInput | DripCampaignWhereInput[]
    OR?: DripCampaignWhereInput[]
    NOT?: DripCampaignWhereInput | DripCampaignWhereInput[]
    userId?: StringFilter<"DripCampaign"> | string
    name?: StringFilter<"DripCampaign"> | string
    description?: StringNullableFilter<"DripCampaign"> | string | null
    triggerType?: EnumDripTriggerTypeFilter<"DripCampaign"> | $Enums.DripTriggerType
    triggerValue?: StringNullableFilter<"DripCampaign"> | string | null
    isActive?: BoolFilter<"DripCampaign"> | boolean
    createdAt?: DateTimeFilter<"DripCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"DripCampaign"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    steps?: DripCampaignStepListRelationFilter
    enrollments?: DripEnrollmentListRelationFilter
    scheduled?: DripScheduledMessageListRelationFilter
  }, "id">

  export type DripCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DripCampaignCountOrderByAggregateInput
    _max?: DripCampaignMaxOrderByAggregateInput
    _min?: DripCampaignMinOrderByAggregateInput
  }

  export type DripCampaignScalarWhereWithAggregatesInput = {
    AND?: DripCampaignScalarWhereWithAggregatesInput | DripCampaignScalarWhereWithAggregatesInput[]
    OR?: DripCampaignScalarWhereWithAggregatesInput[]
    NOT?: DripCampaignScalarWhereWithAggregatesInput | DripCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DripCampaign"> | string
    userId?: StringWithAggregatesFilter<"DripCampaign"> | string
    name?: StringWithAggregatesFilter<"DripCampaign"> | string
    description?: StringNullableWithAggregatesFilter<"DripCampaign"> | string | null
    triggerType?: EnumDripTriggerTypeWithAggregatesFilter<"DripCampaign"> | $Enums.DripTriggerType
    triggerValue?: StringNullableWithAggregatesFilter<"DripCampaign"> | string | null
    isActive?: BoolWithAggregatesFilter<"DripCampaign"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DripCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DripCampaign"> | Date | string
  }

  export type DripCampaignStepWhereInput = {
    AND?: DripCampaignStepWhereInput | DripCampaignStepWhereInput[]
    OR?: DripCampaignStepWhereInput[]
    NOT?: DripCampaignStepWhereInput | DripCampaignStepWhereInput[]
    id?: StringFilter<"DripCampaignStep"> | string
    campaignId?: StringFilter<"DripCampaignStep"> | string
    sequence?: IntFilter<"DripCampaignStep"> | number
    delayHours?: IntFilter<"DripCampaignStep"> | number
    message?: StringFilter<"DripCampaignStep"> | string
    mediaUrl?: StringNullableFilter<"DripCampaignStep"> | string | null
    mediaType?: StringNullableFilter<"DripCampaignStep"> | string | null
    createdAt?: DateTimeFilter<"DripCampaignStep"> | Date | string
    campaign?: XOR<DripCampaignRelationFilter, DripCampaignWhereInput>
    scheduled?: DripScheduledMessageListRelationFilter
  }

  export type DripCampaignStepOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sequence?: SortOrder
    delayHours?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: DripCampaignOrderByWithRelationInput
    scheduled?: DripScheduledMessageOrderByRelationAggregateInput
    _relevance?: DripCampaignStepOrderByRelevanceInput
  }

  export type DripCampaignStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DripCampaignStepWhereInput | DripCampaignStepWhereInput[]
    OR?: DripCampaignStepWhereInput[]
    NOT?: DripCampaignStepWhereInput | DripCampaignStepWhereInput[]
    campaignId?: StringFilter<"DripCampaignStep"> | string
    sequence?: IntFilter<"DripCampaignStep"> | number
    delayHours?: IntFilter<"DripCampaignStep"> | number
    message?: StringFilter<"DripCampaignStep"> | string
    mediaUrl?: StringNullableFilter<"DripCampaignStep"> | string | null
    mediaType?: StringNullableFilter<"DripCampaignStep"> | string | null
    createdAt?: DateTimeFilter<"DripCampaignStep"> | Date | string
    campaign?: XOR<DripCampaignRelationFilter, DripCampaignWhereInput>
    scheduled?: DripScheduledMessageListRelationFilter
  }, "id">

  export type DripCampaignStepOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sequence?: SortOrder
    delayHours?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DripCampaignStepCountOrderByAggregateInput
    _avg?: DripCampaignStepAvgOrderByAggregateInput
    _max?: DripCampaignStepMaxOrderByAggregateInput
    _min?: DripCampaignStepMinOrderByAggregateInput
    _sum?: DripCampaignStepSumOrderByAggregateInput
  }

  export type DripCampaignStepScalarWhereWithAggregatesInput = {
    AND?: DripCampaignStepScalarWhereWithAggregatesInput | DripCampaignStepScalarWhereWithAggregatesInput[]
    OR?: DripCampaignStepScalarWhereWithAggregatesInput[]
    NOT?: DripCampaignStepScalarWhereWithAggregatesInput | DripCampaignStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DripCampaignStep"> | string
    campaignId?: StringWithAggregatesFilter<"DripCampaignStep"> | string
    sequence?: IntWithAggregatesFilter<"DripCampaignStep"> | number
    delayHours?: IntWithAggregatesFilter<"DripCampaignStep"> | number
    message?: StringWithAggregatesFilter<"DripCampaignStep"> | string
    mediaUrl?: StringNullableWithAggregatesFilter<"DripCampaignStep"> | string | null
    mediaType?: StringNullableWithAggregatesFilter<"DripCampaignStep"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DripCampaignStep"> | Date | string
  }

  export type DripEnrollmentWhereInput = {
    AND?: DripEnrollmentWhereInput | DripEnrollmentWhereInput[]
    OR?: DripEnrollmentWhereInput[]
    NOT?: DripEnrollmentWhereInput | DripEnrollmentWhereInput[]
    id?: StringFilter<"DripEnrollment"> | string
    campaignId?: StringFilter<"DripEnrollment"> | string
    contactId?: StringFilter<"DripEnrollment"> | string
    currentStep?: IntFilter<"DripEnrollment"> | number
    status?: EnumDripEnrollmentStatusFilter<"DripEnrollment"> | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFilter<"DripEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"DripEnrollment"> | Date | string | null
    campaign?: XOR<DripCampaignRelationFilter, DripCampaignWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
  }

  export type DripEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    campaign?: DripCampaignOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    _relevance?: DripEnrollmentOrderByRelevanceInput
  }

  export type DripEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_contactId?: DripEnrollmentCampaignIdContactIdCompoundUniqueInput
    AND?: DripEnrollmentWhereInput | DripEnrollmentWhereInput[]
    OR?: DripEnrollmentWhereInput[]
    NOT?: DripEnrollmentWhereInput | DripEnrollmentWhereInput[]
    campaignId?: StringFilter<"DripEnrollment"> | string
    contactId?: StringFilter<"DripEnrollment"> | string
    currentStep?: IntFilter<"DripEnrollment"> | number
    status?: EnumDripEnrollmentStatusFilter<"DripEnrollment"> | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFilter<"DripEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"DripEnrollment"> | Date | string | null
    campaign?: XOR<DripCampaignRelationFilter, DripCampaignWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
  }, "id" | "campaignId_contactId">

  export type DripEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: DripEnrollmentCountOrderByAggregateInput
    _avg?: DripEnrollmentAvgOrderByAggregateInput
    _max?: DripEnrollmentMaxOrderByAggregateInput
    _min?: DripEnrollmentMinOrderByAggregateInput
    _sum?: DripEnrollmentSumOrderByAggregateInput
  }

  export type DripEnrollmentScalarWhereWithAggregatesInput = {
    AND?: DripEnrollmentScalarWhereWithAggregatesInput | DripEnrollmentScalarWhereWithAggregatesInput[]
    OR?: DripEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: DripEnrollmentScalarWhereWithAggregatesInput | DripEnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DripEnrollment"> | string
    campaignId?: StringWithAggregatesFilter<"DripEnrollment"> | string
    contactId?: StringWithAggregatesFilter<"DripEnrollment"> | string
    currentStep?: IntWithAggregatesFilter<"DripEnrollment"> | number
    status?: EnumDripEnrollmentStatusWithAggregatesFilter<"DripEnrollment"> | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeWithAggregatesFilter<"DripEnrollment"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"DripEnrollment"> | Date | string | null
  }

  export type DripScheduledMessageWhereInput = {
    AND?: DripScheduledMessageWhereInput | DripScheduledMessageWhereInput[]
    OR?: DripScheduledMessageWhereInput[]
    NOT?: DripScheduledMessageWhereInput | DripScheduledMessageWhereInput[]
    id?: StringFilter<"DripScheduledMessage"> | string
    campaignId?: StringFilter<"DripScheduledMessage"> | string
    stepId?: StringFilter<"DripScheduledMessage"> | string
    contactId?: StringFilter<"DripScheduledMessage"> | string
    message?: StringFilter<"DripScheduledMessage"> | string
    mediaUrl?: StringNullableFilter<"DripScheduledMessage"> | string | null
    mediaType?: StringNullableFilter<"DripScheduledMessage"> | string | null
    scheduledFor?: DateTimeFilter<"DripScheduledMessage"> | Date | string
    status?: StringFilter<"DripScheduledMessage"> | string
    sentAt?: DateTimeNullableFilter<"DripScheduledMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"DripScheduledMessage"> | Date | string
    campaign?: XOR<DripCampaignRelationFilter, DripCampaignWhereInput>
    step?: XOR<DripCampaignStepRelationFilter, DripCampaignStepWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
  }

  export type DripScheduledMessageOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    stepId?: SortOrder
    contactId?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: DripCampaignOrderByWithRelationInput
    step?: DripCampaignStepOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    _relevance?: DripScheduledMessageOrderByRelevanceInput
  }

  export type DripScheduledMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DripScheduledMessageWhereInput | DripScheduledMessageWhereInput[]
    OR?: DripScheduledMessageWhereInput[]
    NOT?: DripScheduledMessageWhereInput | DripScheduledMessageWhereInput[]
    campaignId?: StringFilter<"DripScheduledMessage"> | string
    stepId?: StringFilter<"DripScheduledMessage"> | string
    contactId?: StringFilter<"DripScheduledMessage"> | string
    message?: StringFilter<"DripScheduledMessage"> | string
    mediaUrl?: StringNullableFilter<"DripScheduledMessage"> | string | null
    mediaType?: StringNullableFilter<"DripScheduledMessage"> | string | null
    scheduledFor?: DateTimeFilter<"DripScheduledMessage"> | Date | string
    status?: StringFilter<"DripScheduledMessage"> | string
    sentAt?: DateTimeNullableFilter<"DripScheduledMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"DripScheduledMessage"> | Date | string
    campaign?: XOR<DripCampaignRelationFilter, DripCampaignWhereInput>
    step?: XOR<DripCampaignStepRelationFilter, DripCampaignStepWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
  }, "id">

  export type DripScheduledMessageOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    stepId?: SortOrder
    contactId?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DripScheduledMessageCountOrderByAggregateInput
    _max?: DripScheduledMessageMaxOrderByAggregateInput
    _min?: DripScheduledMessageMinOrderByAggregateInput
  }

  export type DripScheduledMessageScalarWhereWithAggregatesInput = {
    AND?: DripScheduledMessageScalarWhereWithAggregatesInput | DripScheduledMessageScalarWhereWithAggregatesInput[]
    OR?: DripScheduledMessageScalarWhereWithAggregatesInput[]
    NOT?: DripScheduledMessageScalarWhereWithAggregatesInput | DripScheduledMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DripScheduledMessage"> | string
    campaignId?: StringWithAggregatesFilter<"DripScheduledMessage"> | string
    stepId?: StringWithAggregatesFilter<"DripScheduledMessage"> | string
    contactId?: StringWithAggregatesFilter<"DripScheduledMessage"> | string
    message?: StringWithAggregatesFilter<"DripScheduledMessage"> | string
    mediaUrl?: StringNullableWithAggregatesFilter<"DripScheduledMessage"> | string | null
    mediaType?: StringNullableWithAggregatesFilter<"DripScheduledMessage"> | string | null
    scheduledFor?: DateTimeWithAggregatesFilter<"DripScheduledMessage"> | Date | string
    status?: StringWithAggregatesFilter<"DripScheduledMessage"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"DripScheduledMessage"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DripScheduledMessage"> | Date | string
  }

  export type WebhookLogWhereInput = {
    AND?: WebhookLogWhereInput | WebhookLogWhereInput[]
    OR?: WebhookLogWhereInput[]
    NOT?: WebhookLogWhereInput | WebhookLogWhereInput[]
    id?: StringFilter<"WebhookLog"> | string
    event?: StringFilter<"WebhookLog"> | string
    payload?: JsonFilter<"WebhookLog">
    status?: IntFilter<"WebhookLog"> | number
    error?: StringNullableFilter<"WebhookLog"> | string | null
    retries?: IntFilter<"WebhookLog"> | number
    createdAt?: DateTimeFilter<"WebhookLog"> | Date | string
  }

  export type WebhookLogOrderByWithRelationInput = {
    id?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    retries?: SortOrder
    createdAt?: SortOrder
    _relevance?: WebhookLogOrderByRelevanceInput
  }

  export type WebhookLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookLogWhereInput | WebhookLogWhereInput[]
    OR?: WebhookLogWhereInput[]
    NOT?: WebhookLogWhereInput | WebhookLogWhereInput[]
    event?: StringFilter<"WebhookLog"> | string
    payload?: JsonFilter<"WebhookLog">
    status?: IntFilter<"WebhookLog"> | number
    error?: StringNullableFilter<"WebhookLog"> | string | null
    retries?: IntFilter<"WebhookLog"> | number
    createdAt?: DateTimeFilter<"WebhookLog"> | Date | string
  }, "id">

  export type WebhookLogOrderByWithAggregationInput = {
    id?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    retries?: SortOrder
    createdAt?: SortOrder
    _count?: WebhookLogCountOrderByAggregateInput
    _avg?: WebhookLogAvgOrderByAggregateInput
    _max?: WebhookLogMaxOrderByAggregateInput
    _min?: WebhookLogMinOrderByAggregateInput
    _sum?: WebhookLogSumOrderByAggregateInput
  }

  export type WebhookLogScalarWhereWithAggregatesInput = {
    AND?: WebhookLogScalarWhereWithAggregatesInput | WebhookLogScalarWhereWithAggregatesInput[]
    OR?: WebhookLogScalarWhereWithAggregatesInput[]
    NOT?: WebhookLogScalarWhereWithAggregatesInput | WebhookLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookLog"> | string
    event?: StringWithAggregatesFilter<"WebhookLog"> | string
    payload?: JsonWithAggregatesFilter<"WebhookLog">
    status?: IntWithAggregatesFilter<"WebhookLog"> | number
    error?: StringNullableWithAggregatesFilter<"WebhookLog"> | string | null
    retries?: IntWithAggregatesFilter<"WebhookLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WebhookLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    segments?: SegmentCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyCreateNestedManyWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    segments?: SegmentUncheckedCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyUncheckedCreateNestedManyWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    segments?: SegmentUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUpdateManyWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUncheckedUpdateManyWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactCreateInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContactsInput
    conversations?: ConversationCreateNestedManyWithoutContactInput
    messages?: MessageCreateNestedManyWithoutContactInput
    tags?: TagOnContactCreateNestedManyWithoutContactInput
    notes?: NoteCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    userId: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
    messages?: MessageUncheckedCreateNestedManyWithoutContactInput
    tags?: TagOnContactUncheckedCreateNestedManyWithoutContactInput
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentUncheckedCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
    conversations?: ConversationUpdateManyWithoutContactNestedInput
    messages?: MessageUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUpdateManyWithoutContactNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUncheckedUpdateManyWithoutContactNestedInput
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUncheckedUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    userId: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    isActive?: boolean
    unreadCount?: number
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    contact: ContactCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    userId: string
    contactId: string
    isActive?: boolean
    unreadCount?: number
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    contact?: ContactUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    userId: string
    contactId: string
    isActive?: boolean
    unreadCount?: number
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMessagesInput
    contact: ContactCreateNestedOneWithoutMessagesInput
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    reactions?: ReactionCreateNestedManyWithoutMessageInput
    notes?: NoteCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    userId: string
    contactId: string
    conversationId: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ReactionUncheckedCreateNestedManyWithoutMessageInput
    notes?: NoteUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    contact?: ContactUpdateOneRequiredWithoutMessagesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: ReactionUpdateManyWithoutMessageNestedInput
    notes?: NoteUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ReactionUncheckedUpdateManyWithoutMessageNestedInput
    notes?: NoteUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    userId: string
    contactId: string
    conversationId: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionCreateInput = {
    id?: string
    emoji: string
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateInput = {
    id?: string
    messageId: string
    emoji: string
    createdAt?: Date | string
  }

  export type ReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionCreateManyInput = {
    id?: string
    messageId: string
    emoji: string
    createdAt?: Date | string
  }

  export type ReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
    contacts?: TagOnContactCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    color?: string | null
    createdAt?: Date | string
    contacts?: TagOnContactUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
    contacts?: TagOnContactUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: TagOnContactUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    userId: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagOnContactCreateInput = {
    assignedAt?: Date | string
    contact: ContactCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutContactsInput
  }

  export type TagOnContactUncheckedCreateInput = {
    contactId: string
    tagId: string
    assignedAt?: Date | string
  }

  export type TagOnContactUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutContactsNestedInput
  }

  export type TagOnContactUncheckedUpdateInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagOnContactCreateManyInput = {
    contactId: string
    tagId: string
    assignedAt?: Date | string
  }

  export type TagOnContactUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagOnContactUncheckedUpdateManyInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentCreateInput = {
    id?: string
    name: string
    criteria: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSegmentsInput
  }

  export type SegmentUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    criteria: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSegmentsNestedInput
  }

  export type SegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentCreateManyInput = {
    id?: string
    userId: string
    name: string
    criteria: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    templateId?: string | null
    content?: string | null
    mediaUrl?: string | null
    scheduleTime?: Date | string | null
    sentAt?: Date | string | null
    completedAt?: Date | string | null
    recipientCount?: number
    sentCount?: number
    failedCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    templateId?: string | null
    content?: string | null
    mediaUrl?: string | null
    scheduleTime?: Date | string | null
    sentAt?: Date | string | null
    completedAt?: Date | string | null
    recipientCount?: number
    sentCount?: number
    failedCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    templateId?: string | null
    content?: string | null
    mediaUrl?: string | null
    scheduleTime?: Date | string | null
    sentAt?: Date | string | null
    completedAt?: Date | string | null
    recipientCount?: number
    sentCount?: number
    failedCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickReplyCreateInput = {
    id?: string
    title: string
    content: string
    category?: string | null
    shortcut?: string | null
    isActive?: boolean
    usageCount?: number
    usageTodayCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutQuickRepliesInput
  }

  export type QuickReplyUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    content: string
    category?: string | null
    shortcut?: string | null
    isActive?: boolean
    usageCount?: number
    usageTodayCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuickReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortcut?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    usageTodayCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutQuickRepliesNestedInput
  }

  export type QuickReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortcut?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    usageTodayCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickReplyCreateManyInput = {
    id?: string
    userId: string
    title: string
    content: string
    category?: string | null
    shortcut?: string | null
    isActive?: boolean
    usageCount?: number
    usageTodayCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuickReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortcut?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    usageTodayCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortcut?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    usageTodayCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateCreateInput = {
    id?: string
    name: string
    category: string
    language?: string
    content: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageTemplateUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    language?: string
    content: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateCreateManyInput = {
    id?: string
    name: string
    category: string
    language?: string
    content: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationCreateInput = {
    id?: string
    name: string
    trigger: string
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAutomationsInput
  }

  export type AutomationUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    trigger: string
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAutomationsNestedInput
  }

  export type AutomationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationCreateManyInput = {
    id?: string
    userId: string
    name: string
    trigger: string
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoReplyCreateInput = {
    id?: string
    isActive?: boolean
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoReplyUncheckedCreateInput = {
    id?: string
    isActive?: boolean
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoReplyCreateManyInput = {
    id?: string
    isActive?: boolean
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotesInput
    contact?: ContactCreateNestedOneWithoutNotesInput
    message?: MessageCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateInput = {
    id?: string
    userId: string
    contactId?: string | null
    messageId?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotesNestedInput
    contact?: ContactUpdateOneWithoutNotesNestedInput
    message?: MessageUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateManyInput = {
    id?: string
    userId: string
    contactId?: string | null
    messageId?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    id?: string
    action: $Enums.ActivityType
    resourceType?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: $Enums.ActivityType
    resourceType?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    userId: string
    action: $Enums.ActivityType
    resourceType?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigCreateInput = {
    id?: string
    key: string
    value: string
    type: $Enums.ConfigType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    type: $Enums.ConfigType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumConfigTypeFieldUpdateOperationsInput | $Enums.ConfigType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumConfigTypeFieldUpdateOperationsInput | $Enums.ConfigType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    type: $Enums.ConfigType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumConfigTypeFieldUpdateOperationsInput | $Enums.ConfigType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumConfigTypeFieldUpdateOperationsInput | $Enums.ConfigType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripCampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDripCampaignsInput
    steps?: DripCampaignStepCreateNestedManyWithoutCampaignInput
    enrollments?: DripEnrollmentCreateNestedManyWithoutCampaignInput
    scheduled?: DripScheduledMessageCreateNestedManyWithoutCampaignInput
  }

  export type DripCampaignUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: DripCampaignStepUncheckedCreateNestedManyWithoutCampaignInput
    enrollments?: DripEnrollmentUncheckedCreateNestedManyWithoutCampaignInput
    scheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type DripCampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDripCampaignsNestedInput
    steps?: DripCampaignStepUpdateManyWithoutCampaignNestedInput
    enrollments?: DripEnrollmentUpdateManyWithoutCampaignNestedInput
    scheduled?: DripScheduledMessageUpdateManyWithoutCampaignNestedInput
  }

  export type DripCampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: DripCampaignStepUncheckedUpdateManyWithoutCampaignNestedInput
    enrollments?: DripEnrollmentUncheckedUpdateManyWithoutCampaignNestedInput
    scheduled?: DripScheduledMessageUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type DripCampaignCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DripCampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripCampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripCampaignStepCreateInput = {
    id?: string
    sequence: number
    delayHours: number
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    createdAt?: Date | string
    campaign: DripCampaignCreateNestedOneWithoutStepsInput
    scheduled?: DripScheduledMessageCreateNestedManyWithoutStepInput
  }

  export type DripCampaignStepUncheckedCreateInput = {
    id?: string
    campaignId: string
    sequence: number
    delayHours: number
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    createdAt?: Date | string
    scheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutStepInput
  }

  export type DripCampaignStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: DripCampaignUpdateOneRequiredWithoutStepsNestedInput
    scheduled?: DripScheduledMessageUpdateManyWithoutStepNestedInput
  }

  export type DripCampaignStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled?: DripScheduledMessageUncheckedUpdateManyWithoutStepNestedInput
  }

  export type DripCampaignStepCreateManyInput = {
    id?: string
    campaignId: string
    sequence: number
    delayHours: number
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    createdAt?: Date | string
  }

  export type DripCampaignStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripCampaignStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripEnrollmentCreateInput = {
    id?: string
    currentStep?: number
    status: $Enums.DripEnrollmentStatus
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    campaign: DripCampaignCreateNestedOneWithoutEnrollmentsInput
    contact: ContactCreateNestedOneWithoutDripEnrollmentsInput
  }

  export type DripEnrollmentUncheckedCreateInput = {
    id?: string
    campaignId: string
    contactId: string
    currentStep?: number
    status: $Enums.DripEnrollmentStatus
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type DripEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumDripEnrollmentStatusFieldUpdateOperationsInput | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: DripCampaignUpdateOneRequiredWithoutEnrollmentsNestedInput
    contact?: ContactUpdateOneRequiredWithoutDripEnrollmentsNestedInput
  }

  export type DripEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumDripEnrollmentStatusFieldUpdateOperationsInput | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DripEnrollmentCreateManyInput = {
    id?: string
    campaignId: string
    contactId: string
    currentStep?: number
    status: $Enums.DripEnrollmentStatus
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type DripEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumDripEnrollmentStatusFieldUpdateOperationsInput | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DripEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumDripEnrollmentStatusFieldUpdateOperationsInput | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DripScheduledMessageCreateInput = {
    id?: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
    campaign: DripCampaignCreateNestedOneWithoutScheduledInput
    step: DripCampaignStepCreateNestedOneWithoutScheduledInput
    contact: ContactCreateNestedOneWithoutDripScheduledInput
  }

  export type DripScheduledMessageUncheckedCreateInput = {
    id?: string
    campaignId: string
    stepId: string
    contactId: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DripScheduledMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: DripCampaignUpdateOneRequiredWithoutScheduledNestedInput
    step?: DripCampaignStepUpdateOneRequiredWithoutScheduledNestedInput
    contact?: ContactUpdateOneRequiredWithoutDripScheduledNestedInput
  }

  export type DripScheduledMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripScheduledMessageCreateManyInput = {
    id?: string
    campaignId: string
    stepId: string
    contactId: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DripScheduledMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripScheduledMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogCreateInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status: number
    error?: string | null
    retries?: number
    createdAt?: Date | string
  }

  export type WebhookLogUncheckedCreateInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status: number
    error?: string | null
    retries?: number
    createdAt?: Date | string
  }

  export type WebhookLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogCreateManyInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status: number
    error?: string | null
    retries?: number
    createdAt?: Date | string
  }

  export type WebhookLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type SegmentListRelationFilter = {
    every?: SegmentWhereInput
    some?: SegmentWhereInput
    none?: SegmentWhereInput
  }

  export type QuickReplyListRelationFilter = {
    every?: QuickReplyWhereInput
    some?: QuickReplyWhereInput
    none?: QuickReplyWhereInput
  }

  export type AutomationListRelationFilter = {
    every?: AutomationWhereInput
    some?: AutomationWhereInput
    none?: AutomationWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type DripCampaignListRelationFilter = {
    every?: DripCampaignWhereInput
    some?: DripCampaignWhereInput
    none?: DripCampaignWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuickReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DripCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TagOnContactListRelationFilter = {
    every?: TagOnContactWhereInput
    some?: TagOnContactWhereInput
    none?: TagOnContactWhereInput
  }

  export type DripEnrollmentListRelationFilter = {
    every?: DripEnrollmentWhereInput
    some?: DripEnrollmentWhereInput
    none?: DripEnrollmentWhereInput
  }

  export type DripScheduledMessageListRelationFilter = {
    every?: DripScheduledMessageWhereInput
    some?: DripScheduledMessageWhereInput
    none?: DripScheduledMessageWhereInput
  }

  export type TagOnContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DripEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DripScheduledMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelevanceInput = {
    fields: ContactOrderByRelevanceFieldEnum | ContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactUserIdPhoneNumberCompoundUniqueInput = {
    userId: string
    phoneNumber: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    pushName?: SortOrder
    businessName?: SortOrder
    email?: SortOrder
    avatarUrl?: SortOrder
    profilePhotoUrl?: SortOrder
    company?: SortOrder
    department?: SortOrder
    contactType?: SortOrder
    timezone?: SortOrder
    lastMessageAt?: SortOrder
    lastActiveAt?: SortOrder
    engagementScore?: SortOrder
    engagementLevel?: SortOrder
    messageCount?: SortOrder
    totalInteractions?: SortOrder
    isBlocked?: SortOrder
    isBusiness?: SortOrder
    isVerified?: SortOrder
    customFields?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    engagementScore?: SortOrder
    messageCount?: SortOrder
    totalInteractions?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    pushName?: SortOrder
    businessName?: SortOrder
    email?: SortOrder
    avatarUrl?: SortOrder
    profilePhotoUrl?: SortOrder
    company?: SortOrder
    department?: SortOrder
    contactType?: SortOrder
    timezone?: SortOrder
    lastMessageAt?: SortOrder
    lastActiveAt?: SortOrder
    engagementScore?: SortOrder
    engagementLevel?: SortOrder
    messageCount?: SortOrder
    totalInteractions?: SortOrder
    isBlocked?: SortOrder
    isBusiness?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    pushName?: SortOrder
    businessName?: SortOrder
    email?: SortOrder
    avatarUrl?: SortOrder
    profilePhotoUrl?: SortOrder
    company?: SortOrder
    department?: SortOrder
    contactType?: SortOrder
    timezone?: SortOrder
    lastMessageAt?: SortOrder
    lastActiveAt?: SortOrder
    engagementScore?: SortOrder
    engagementLevel?: SortOrder
    messageCount?: SortOrder
    totalInteractions?: SortOrder
    isBlocked?: SortOrder
    isBusiness?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    engagementScore?: SortOrder
    messageCount?: SortOrder
    totalInteractions?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ContactRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ConversationOrderByRelevanceInput = {
    fields: ConversationOrderByRelevanceFieldEnum | ConversationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConversationUserIdContactIdCompoundUniqueInput = {
    userId: string
    contactId: string
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    isActive?: SortOrder
    unreadCount?: SortOrder
    lastMessageAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationAvgOrderByAggregateInput = {
    unreadCount?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    isActive?: SortOrder
    unreadCount?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    isActive?: SortOrder
    unreadCount?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationSumOrderByAggregateInput = {
    unreadCount?: SortOrder
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type EnumMessageDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageDirection | EnumMessageDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.MessageDirection[]
    notIn?: $Enums.MessageDirection[]
    not?: NestedEnumMessageDirectionFilter<$PrismaModel> | $Enums.MessageDirection
  }

  export type EnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[]
    notIn?: $Enums.MessageStatus[]
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type ReactionListRelationFilter = {
    every?: ReactionWhereInput
    some?: ReactionWhereInput
    none?: ReactionWhereInput
  }

  export type ReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelevanceInput = {
    fields: MessageOrderByRelevanceFieldEnum | MessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    conversationId?: SortOrder
    waMessageId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    mediaFileName?: SortOrder
    quotedMessageId?: SortOrder
    isGroupMessage?: SortOrder
    groupId?: SortOrder
    groupName?: SortOrder
    isStatusUpdate?: SortOrder
    isChannelMessage?: SortOrder
    channelId?: SortOrder
    senderName?: SortOrder
    templateId?: SortOrder
    quickReplyId?: SortOrder
    tagIds?: SortOrder
    metadata?: SortOrder
    scheduledAt?: SortOrder
    sendAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    conversationId?: SortOrder
    waMessageId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    mediaFileName?: SortOrder
    quotedMessageId?: SortOrder
    isGroupMessage?: SortOrder
    groupId?: SortOrder
    groupName?: SortOrder
    isStatusUpdate?: SortOrder
    isChannelMessage?: SortOrder
    channelId?: SortOrder
    senderName?: SortOrder
    templateId?: SortOrder
    quickReplyId?: SortOrder
    scheduledAt?: SortOrder
    sendAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    conversationId?: SortOrder
    waMessageId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    mediaFileName?: SortOrder
    quotedMessageId?: SortOrder
    isGroupMessage?: SortOrder
    groupId?: SortOrder
    groupName?: SortOrder
    isStatusUpdate?: SortOrder
    isChannelMessage?: SortOrder
    channelId?: SortOrder
    senderName?: SortOrder
    templateId?: SortOrder
    quickReplyId?: SortOrder
    scheduledAt?: SortOrder
    sendAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumMessageDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageDirection | EnumMessageDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.MessageDirection[]
    notIn?: $Enums.MessageDirection[]
    not?: NestedEnumMessageDirectionWithAggregatesFilter<$PrismaModel> | $Enums.MessageDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageDirectionFilter<$PrismaModel>
    _max?: NestedEnumMessageDirectionFilter<$PrismaModel>
  }

  export type EnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[]
    notIn?: $Enums.MessageStatus[]
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type ReactionOrderByRelevanceInput = {
    fields: ReactionOrderByRelevanceFieldEnum | ReactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReactionMessageIdEmojiCompoundUniqueInput = {
    messageId: string
    emoji: string
  }

  export type ReactionCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
  }

  export type ReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
  }

  export type ReactionMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
  }

  export type TagOrderByRelevanceInput = {
    fields: TagOrderByRelevanceFieldEnum | TagOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TagUserIdNameCompoundUniqueInput = {
    userId: string
    name: string
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type TagRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type TagOnContactOrderByRelevanceInput = {
    fields: TagOnContactOrderByRelevanceFieldEnum | TagOnContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TagOnContactContactIdTagIdCompoundUniqueInput = {
    contactId: string
    tagId: string
  }

  export type TagOnContactCountOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TagOnContactMaxOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TagOnContactMinOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SegmentOrderByRelevanceInput = {
    fields: SegmentOrderByRelevanceFieldEnum | SegmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SegmentUserIdNameCompoundUniqueInput = {
    userId: string
    name: string
  }

  export type SegmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SegmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumCampaignTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[]
    notIn?: $Enums.CampaignType[]
    not?: NestedEnumCampaignTypeFilter<$PrismaModel> | $Enums.CampaignType
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[]
    notIn?: $Enums.CampaignStatus[]
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type CampaignOrderByRelevanceInput = {
    fields: CampaignOrderByRelevanceFieldEnum | CampaignOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    scheduleTime?: SortOrder
    sentAt?: SortOrder
    completedAt?: SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    scheduleTime?: SortOrder
    sentAt?: SortOrder
    completedAt?: SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    templateId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    scheduleTime?: SortOrder
    sentAt?: SortOrder
    completedAt?: SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
  }

  export type EnumCampaignTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[]
    notIn?: $Enums.CampaignType[]
    not?: NestedEnumCampaignTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignTypeFilter<$PrismaModel>
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[]
    notIn?: $Enums.CampaignStatus[]
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type QuickReplyOrderByRelevanceInput = {
    fields: QuickReplyOrderByRelevanceFieldEnum | QuickReplyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QuickReplyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    shortcut?: SortOrder
    isActive?: SortOrder
    usageCount?: SortOrder
    usageTodayCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuickReplyAvgOrderByAggregateInput = {
    usageCount?: SortOrder
    usageTodayCount?: SortOrder
  }

  export type QuickReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    shortcut?: SortOrder
    isActive?: SortOrder
    usageCount?: SortOrder
    usageTodayCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuickReplyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    shortcut?: SortOrder
    isActive?: SortOrder
    usageCount?: SortOrder
    usageTodayCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuickReplySumOrderByAggregateInput = {
    usageCount?: SortOrder
    usageTodayCount?: SortOrder
  }

  export type MessageTemplateOrderByRelevanceInput = {
    fields: MessageTemplateOrderByRelevanceFieldEnum | MessageTemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MessageTemplateNameLanguageCompoundUniqueInput = {
    name: string
    language: string
  }

  export type MessageTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    language?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    language?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    language?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AutomationOrderByRelevanceInput = {
    fields: AutomationOrderByRelevanceFieldEnum | AutomationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AutomationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    trigger?: SortOrder
    actions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    trigger?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    trigger?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoReplyOrderByRelevanceInput = {
    fields: AutoReplyOrderByRelevanceFieldEnum | AutoReplyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AutoReplyCountOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoReplyMinOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactNullableRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type MessageNullableRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type NoteOrderByRelevanceInput = {
    fields: NoteOrderByRelevanceFieldEnum | NoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    messageId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    messageId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    messageId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[]
    notIn?: $Enums.ActivityType[]
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type ActivityLogOrderByRelevanceInput = {
    fields: ActivityLogOrderByRelevanceFieldEnum | ActivityLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[]
    notIn?: $Enums.ActivityType[]
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type EnumConfigTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfigType | EnumConfigTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConfigType[]
    notIn?: $Enums.ConfigType[]
    not?: NestedEnumConfigTypeFilter<$PrismaModel> | $Enums.ConfigType
  }

  export type AppConfigOrderByRelevanceInput = {
    fields: AppConfigOrderByRelevanceFieldEnum | AppConfigOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AppConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConfigTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfigType | EnumConfigTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConfigType[]
    notIn?: $Enums.ConfigType[]
    not?: NestedEnumConfigTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConfigType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfigTypeFilter<$PrismaModel>
    _max?: NestedEnumConfigTypeFilter<$PrismaModel>
  }

  export type EnumDripTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DripTriggerType | EnumDripTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DripTriggerType[]
    notIn?: $Enums.DripTriggerType[]
    not?: NestedEnumDripTriggerTypeFilter<$PrismaModel> | $Enums.DripTriggerType
  }

  export type DripCampaignStepListRelationFilter = {
    every?: DripCampaignStepWhereInput
    some?: DripCampaignStepWhereInput
    none?: DripCampaignStepWhereInput
  }

  export type DripCampaignStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DripCampaignOrderByRelevanceInput = {
    fields: DripCampaignOrderByRelevanceFieldEnum | DripCampaignOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DripCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DripCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DripCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDripTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DripTriggerType | EnumDripTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DripTriggerType[]
    notIn?: $Enums.DripTriggerType[]
    not?: NestedEnumDripTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.DripTriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDripTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumDripTriggerTypeFilter<$PrismaModel>
  }

  export type DripCampaignRelationFilter = {
    is?: DripCampaignWhereInput
    isNot?: DripCampaignWhereInput
  }

  export type DripCampaignStepOrderByRelevanceInput = {
    fields: DripCampaignStepOrderByRelevanceFieldEnum | DripCampaignStepOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DripCampaignStepCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sequence?: SortOrder
    delayHours?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
  }

  export type DripCampaignStepAvgOrderByAggregateInput = {
    sequence?: SortOrder
    delayHours?: SortOrder
  }

  export type DripCampaignStepMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sequence?: SortOrder
    delayHours?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
  }

  export type DripCampaignStepMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sequence?: SortOrder
    delayHours?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
  }

  export type DripCampaignStepSumOrderByAggregateInput = {
    sequence?: SortOrder
    delayHours?: SortOrder
  }

  export type EnumDripEnrollmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DripEnrollmentStatus | EnumDripEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DripEnrollmentStatus[]
    notIn?: $Enums.DripEnrollmentStatus[]
    not?: NestedEnumDripEnrollmentStatusFilter<$PrismaModel> | $Enums.DripEnrollmentStatus
  }

  export type DripEnrollmentOrderByRelevanceInput = {
    fields: DripEnrollmentOrderByRelevanceFieldEnum | DripEnrollmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DripEnrollmentCampaignIdContactIdCompoundUniqueInput = {
    campaignId: string
    contactId: string
  }

  export type DripEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
  }

  export type DripEnrollmentAvgOrderByAggregateInput = {
    currentStep?: SortOrder
  }

  export type DripEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
  }

  export type DripEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
  }

  export type DripEnrollmentSumOrderByAggregateInput = {
    currentStep?: SortOrder
  }

  export type EnumDripEnrollmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DripEnrollmentStatus | EnumDripEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DripEnrollmentStatus[]
    notIn?: $Enums.DripEnrollmentStatus[]
    not?: NestedEnumDripEnrollmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DripEnrollmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDripEnrollmentStatusFilter<$PrismaModel>
    _max?: NestedEnumDripEnrollmentStatusFilter<$PrismaModel>
  }

  export type DripCampaignStepRelationFilter = {
    is?: DripCampaignStepWhereInput
    isNot?: DripCampaignStepWhereInput
  }

  export type DripScheduledMessageOrderByRelevanceInput = {
    fields: DripScheduledMessageOrderByRelevanceFieldEnum | DripScheduledMessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DripScheduledMessageCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    stepId?: SortOrder
    contactId?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DripScheduledMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    stepId?: SortOrder
    contactId?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DripScheduledMessageMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    stepId?: SortOrder
    contactId?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogOrderByRelevanceInput = {
    fields: WebhookLogOrderByRelevanceFieldEnum | WebhookLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WebhookLogCountOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrder
    retries?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogAvgOrderByAggregateInput = {
    status?: SortOrder
    retries?: SortOrder
  }

  export type WebhookLogMaxOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    status?: SortOrder
    error?: SortOrder
    retries?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogMinOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    status?: SortOrder
    error?: SortOrder
    retries?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogSumOrderByAggregateInput = {
    status?: SortOrder
    retries?: SortOrder
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutUserInput = {
    create?: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput> | TagCreateWithoutUserInput[] | TagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagCreateOrConnectWithoutUserInput | TagCreateOrConnectWithoutUserInput[]
    createMany?: TagCreateManyUserInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type SegmentCreateNestedManyWithoutUserInput = {
    create?: XOR<SegmentCreateWithoutUserInput, SegmentUncheckedCreateWithoutUserInput> | SegmentCreateWithoutUserInput[] | SegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutUserInput | SegmentCreateOrConnectWithoutUserInput[]
    createMany?: SegmentCreateManyUserInputEnvelope
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type QuickReplyCreateNestedManyWithoutUserInput = {
    create?: XOR<QuickReplyCreateWithoutUserInput, QuickReplyUncheckedCreateWithoutUserInput> | QuickReplyCreateWithoutUserInput[] | QuickReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuickReplyCreateOrConnectWithoutUserInput | QuickReplyCreateOrConnectWithoutUserInput[]
    createMany?: QuickReplyCreateManyUserInputEnvelope
    connect?: QuickReplyWhereUniqueInput | QuickReplyWhereUniqueInput[]
  }

  export type AutomationCreateNestedManyWithoutUserInput = {
    create?: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput> | AutomationCreateWithoutUserInput[] | AutomationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutUserInput | AutomationCreateOrConnectWithoutUserInput[]
    createMany?: AutomationCreateManyUserInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutUserInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type DripCampaignCreateNestedManyWithoutUserInput = {
    create?: XOR<DripCampaignCreateWithoutUserInput, DripCampaignUncheckedCreateWithoutUserInput> | DripCampaignCreateWithoutUserInput[] | DripCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DripCampaignCreateOrConnectWithoutUserInput | DripCampaignCreateOrConnectWithoutUserInput[]
    createMany?: DripCampaignCreateManyUserInputEnvelope
    connect?: DripCampaignWhereUniqueInput | DripCampaignWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput> | TagCreateWithoutUserInput[] | TagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagCreateOrConnectWithoutUserInput | TagCreateOrConnectWithoutUserInput[]
    createMany?: TagCreateManyUserInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type SegmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SegmentCreateWithoutUserInput, SegmentUncheckedCreateWithoutUserInput> | SegmentCreateWithoutUserInput[] | SegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutUserInput | SegmentCreateOrConnectWithoutUserInput[]
    createMany?: SegmentCreateManyUserInputEnvelope
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type QuickReplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuickReplyCreateWithoutUserInput, QuickReplyUncheckedCreateWithoutUserInput> | QuickReplyCreateWithoutUserInput[] | QuickReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuickReplyCreateOrConnectWithoutUserInput | QuickReplyCreateOrConnectWithoutUserInput[]
    createMany?: QuickReplyCreateManyUserInputEnvelope
    connect?: QuickReplyWhereUniqueInput | QuickReplyWhereUniqueInput[]
  }

  export type AutomationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput> | AutomationCreateWithoutUserInput[] | AutomationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutUserInput | AutomationCreateOrConnectWithoutUserInput[]
    createMany?: AutomationCreateManyUserInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type DripCampaignUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DripCampaignCreateWithoutUserInput, DripCampaignUncheckedCreateWithoutUserInput> | DripCampaignCreateWithoutUserInput[] | DripCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DripCampaignCreateOrConnectWithoutUserInput | DripCampaignCreateOrConnectWithoutUserInput[]
    createMany?: DripCampaignCreateManyUserInputEnvelope
    connect?: DripCampaignWhereUniqueInput | DripCampaignWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type TagUpdateManyWithoutUserNestedInput = {
    create?: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput> | TagCreateWithoutUserInput[] | TagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagCreateOrConnectWithoutUserInput | TagCreateOrConnectWithoutUserInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutUserInput | TagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TagCreateManyUserInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutUserInput | TagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TagUpdateManyWithWhereWithoutUserInput | TagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type SegmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<SegmentCreateWithoutUserInput, SegmentUncheckedCreateWithoutUserInput> | SegmentCreateWithoutUserInput[] | SegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutUserInput | SegmentCreateOrConnectWithoutUserInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutUserInput | SegmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SegmentCreateManyUserInputEnvelope
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutUserInput | SegmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutUserInput | SegmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type QuickReplyUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuickReplyCreateWithoutUserInput, QuickReplyUncheckedCreateWithoutUserInput> | QuickReplyCreateWithoutUserInput[] | QuickReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuickReplyCreateOrConnectWithoutUserInput | QuickReplyCreateOrConnectWithoutUserInput[]
    upsert?: QuickReplyUpsertWithWhereUniqueWithoutUserInput | QuickReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuickReplyCreateManyUserInputEnvelope
    set?: QuickReplyWhereUniqueInput | QuickReplyWhereUniqueInput[]
    disconnect?: QuickReplyWhereUniqueInput | QuickReplyWhereUniqueInput[]
    delete?: QuickReplyWhereUniqueInput | QuickReplyWhereUniqueInput[]
    connect?: QuickReplyWhereUniqueInput | QuickReplyWhereUniqueInput[]
    update?: QuickReplyUpdateWithWhereUniqueWithoutUserInput | QuickReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuickReplyUpdateManyWithWhereWithoutUserInput | QuickReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuickReplyScalarWhereInput | QuickReplyScalarWhereInput[]
  }

  export type AutomationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput> | AutomationCreateWithoutUserInput[] | AutomationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutUserInput | AutomationCreateOrConnectWithoutUserInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutUserInput | AutomationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutomationCreateManyUserInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutUserInput | AutomationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutUserInput | AutomationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutUserInput | NoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutUserInput | NoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutUserInput | NoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type DripCampaignUpdateManyWithoutUserNestedInput = {
    create?: XOR<DripCampaignCreateWithoutUserInput, DripCampaignUncheckedCreateWithoutUserInput> | DripCampaignCreateWithoutUserInput[] | DripCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DripCampaignCreateOrConnectWithoutUserInput | DripCampaignCreateOrConnectWithoutUserInput[]
    upsert?: DripCampaignUpsertWithWhereUniqueWithoutUserInput | DripCampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DripCampaignCreateManyUserInputEnvelope
    set?: DripCampaignWhereUniqueInput | DripCampaignWhereUniqueInput[]
    disconnect?: DripCampaignWhereUniqueInput | DripCampaignWhereUniqueInput[]
    delete?: DripCampaignWhereUniqueInput | DripCampaignWhereUniqueInput[]
    connect?: DripCampaignWhereUniqueInput | DripCampaignWhereUniqueInput[]
    update?: DripCampaignUpdateWithWhereUniqueWithoutUserInput | DripCampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DripCampaignUpdateManyWithWhereWithoutUserInput | DripCampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DripCampaignScalarWhereInput | DripCampaignScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput> | TagCreateWithoutUserInput[] | TagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagCreateOrConnectWithoutUserInput | TagCreateOrConnectWithoutUserInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutUserInput | TagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TagCreateManyUserInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutUserInput | TagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TagUpdateManyWithWhereWithoutUserInput | TagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type SegmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SegmentCreateWithoutUserInput, SegmentUncheckedCreateWithoutUserInput> | SegmentCreateWithoutUserInput[] | SegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutUserInput | SegmentCreateOrConnectWithoutUserInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutUserInput | SegmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SegmentCreateManyUserInputEnvelope
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutUserInput | SegmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutUserInput | SegmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type QuickReplyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuickReplyCreateWithoutUserInput, QuickReplyUncheckedCreateWithoutUserInput> | QuickReplyCreateWithoutUserInput[] | QuickReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuickReplyCreateOrConnectWithoutUserInput | QuickReplyCreateOrConnectWithoutUserInput[]
    upsert?: QuickReplyUpsertWithWhereUniqueWithoutUserInput | QuickReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuickReplyCreateManyUserInputEnvelope
    set?: QuickReplyWhereUniqueInput | QuickReplyWhereUniqueInput[]
    disconnect?: QuickReplyWhereUniqueInput | QuickReplyWhereUniqueInput[]
    delete?: QuickReplyWhereUniqueInput | QuickReplyWhereUniqueInput[]
    connect?: QuickReplyWhereUniqueInput | QuickReplyWhereUniqueInput[]
    update?: QuickReplyUpdateWithWhereUniqueWithoutUserInput | QuickReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuickReplyUpdateManyWithWhereWithoutUserInput | QuickReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuickReplyScalarWhereInput | QuickReplyScalarWhereInput[]
  }

  export type AutomationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput> | AutomationCreateWithoutUserInput[] | AutomationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutUserInput | AutomationCreateOrConnectWithoutUserInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutUserInput | AutomationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutomationCreateManyUserInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutUserInput | AutomationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutUserInput | AutomationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutUserInput | NoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutUserInput | NoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutUserInput | NoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type DripCampaignUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DripCampaignCreateWithoutUserInput, DripCampaignUncheckedCreateWithoutUserInput> | DripCampaignCreateWithoutUserInput[] | DripCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DripCampaignCreateOrConnectWithoutUserInput | DripCampaignCreateOrConnectWithoutUserInput[]
    upsert?: DripCampaignUpsertWithWhereUniqueWithoutUserInput | DripCampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DripCampaignCreateManyUserInputEnvelope
    set?: DripCampaignWhereUniqueInput | DripCampaignWhereUniqueInput[]
    disconnect?: DripCampaignWhereUniqueInput | DripCampaignWhereUniqueInput[]
    delete?: DripCampaignWhereUniqueInput | DripCampaignWhereUniqueInput[]
    connect?: DripCampaignWhereUniqueInput | DripCampaignWhereUniqueInput[]
    update?: DripCampaignUpdateWithWhereUniqueWithoutUserInput | DripCampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DripCampaignUpdateManyWithWhereWithoutUserInput | DripCampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DripCampaignScalarWhereInput | DripCampaignScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutContactsInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationCreateNestedManyWithoutContactInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutContactInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TagOnContactCreateNestedManyWithoutContactInput = {
    create?: XOR<TagOnContactCreateWithoutContactInput, TagOnContactUncheckedCreateWithoutContactInput> | TagOnContactCreateWithoutContactInput[] | TagOnContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TagOnContactCreateOrConnectWithoutContactInput | TagOnContactCreateOrConnectWithoutContactInput[]
    createMany?: TagOnContactCreateManyContactInputEnvelope
    connect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutContactInput = {
    create?: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput> | NoteCreateWithoutContactInput[] | NoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutContactInput | NoteCreateOrConnectWithoutContactInput[]
    createMany?: NoteCreateManyContactInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type DripEnrollmentCreateNestedManyWithoutContactInput = {
    create?: XOR<DripEnrollmentCreateWithoutContactInput, DripEnrollmentUncheckedCreateWithoutContactInput> | DripEnrollmentCreateWithoutContactInput[] | DripEnrollmentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DripEnrollmentCreateOrConnectWithoutContactInput | DripEnrollmentCreateOrConnectWithoutContactInput[]
    createMany?: DripEnrollmentCreateManyContactInputEnvelope
    connect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
  }

  export type DripScheduledMessageCreateNestedManyWithoutContactInput = {
    create?: XOR<DripScheduledMessageCreateWithoutContactInput, DripScheduledMessageUncheckedCreateWithoutContactInput> | DripScheduledMessageCreateWithoutContactInput[] | DripScheduledMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutContactInput | DripScheduledMessageCreateOrConnectWithoutContactInput[]
    createMany?: DripScheduledMessageCreateManyContactInputEnvelope
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TagOnContactUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<TagOnContactCreateWithoutContactInput, TagOnContactUncheckedCreateWithoutContactInput> | TagOnContactCreateWithoutContactInput[] | TagOnContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TagOnContactCreateOrConnectWithoutContactInput | TagOnContactCreateOrConnectWithoutContactInput[]
    createMany?: TagOnContactCreateManyContactInputEnvelope
    connect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput> | NoteCreateWithoutContactInput[] | NoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutContactInput | NoteCreateOrConnectWithoutContactInput[]
    createMany?: NoteCreateManyContactInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type DripEnrollmentUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<DripEnrollmentCreateWithoutContactInput, DripEnrollmentUncheckedCreateWithoutContactInput> | DripEnrollmentCreateWithoutContactInput[] | DripEnrollmentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DripEnrollmentCreateOrConnectWithoutContactInput | DripEnrollmentCreateOrConnectWithoutContactInput[]
    createMany?: DripEnrollmentCreateManyContactInputEnvelope
    connect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
  }

  export type DripScheduledMessageUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<DripScheduledMessageCreateWithoutContactInput, DripScheduledMessageUncheckedCreateWithoutContactInput> | DripScheduledMessageCreateWithoutContactInput[] | DripScheduledMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutContactInput | DripScheduledMessageCreateOrConnectWithoutContactInput[]
    createMany?: DripScheduledMessageCreateManyContactInputEnvelope
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    upsert?: UserUpsertWithoutContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactsInput, UserUpdateWithoutContactsInput>, UserUncheckedUpdateWithoutContactsInput>
  }

  export type ConversationUpdateManyWithoutContactNestedInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutContactInput | ConversationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutContactInput | ConversationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutContactInput | ConversationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutContactNestedInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutContactInput | MessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutContactInput | MessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutContactInput | MessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TagOnContactUpdateManyWithoutContactNestedInput = {
    create?: XOR<TagOnContactCreateWithoutContactInput, TagOnContactUncheckedCreateWithoutContactInput> | TagOnContactCreateWithoutContactInput[] | TagOnContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TagOnContactCreateOrConnectWithoutContactInput | TagOnContactCreateOrConnectWithoutContactInput[]
    upsert?: TagOnContactUpsertWithWhereUniqueWithoutContactInput | TagOnContactUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TagOnContactCreateManyContactInputEnvelope
    set?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    disconnect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    delete?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    connect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    update?: TagOnContactUpdateWithWhereUniqueWithoutContactInput | TagOnContactUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TagOnContactUpdateManyWithWhereWithoutContactInput | TagOnContactUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TagOnContactScalarWhereInput | TagOnContactScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutContactNestedInput = {
    create?: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput> | NoteCreateWithoutContactInput[] | NoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutContactInput | NoteCreateOrConnectWithoutContactInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutContactInput | NoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: NoteCreateManyContactInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutContactInput | NoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutContactInput | NoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type DripEnrollmentUpdateManyWithoutContactNestedInput = {
    create?: XOR<DripEnrollmentCreateWithoutContactInput, DripEnrollmentUncheckedCreateWithoutContactInput> | DripEnrollmentCreateWithoutContactInput[] | DripEnrollmentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DripEnrollmentCreateOrConnectWithoutContactInput | DripEnrollmentCreateOrConnectWithoutContactInput[]
    upsert?: DripEnrollmentUpsertWithWhereUniqueWithoutContactInput | DripEnrollmentUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: DripEnrollmentCreateManyContactInputEnvelope
    set?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    disconnect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    delete?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    connect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    update?: DripEnrollmentUpdateWithWhereUniqueWithoutContactInput | DripEnrollmentUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: DripEnrollmentUpdateManyWithWhereWithoutContactInput | DripEnrollmentUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: DripEnrollmentScalarWhereInput | DripEnrollmentScalarWhereInput[]
  }

  export type DripScheduledMessageUpdateManyWithoutContactNestedInput = {
    create?: XOR<DripScheduledMessageCreateWithoutContactInput, DripScheduledMessageUncheckedCreateWithoutContactInput> | DripScheduledMessageCreateWithoutContactInput[] | DripScheduledMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutContactInput | DripScheduledMessageCreateOrConnectWithoutContactInput[]
    upsert?: DripScheduledMessageUpsertWithWhereUniqueWithoutContactInput | DripScheduledMessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: DripScheduledMessageCreateManyContactInputEnvelope
    set?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    disconnect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    delete?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    update?: DripScheduledMessageUpdateWithWhereUniqueWithoutContactInput | DripScheduledMessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: DripScheduledMessageUpdateManyWithWhereWithoutContactInput | DripScheduledMessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: DripScheduledMessageScalarWhereInput | DripScheduledMessageScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutContactInput | ConversationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutContactInput | ConversationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutContactInput | ConversationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutContactInput | MessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutContactInput | MessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutContactInput | MessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TagOnContactUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<TagOnContactCreateWithoutContactInput, TagOnContactUncheckedCreateWithoutContactInput> | TagOnContactCreateWithoutContactInput[] | TagOnContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TagOnContactCreateOrConnectWithoutContactInput | TagOnContactCreateOrConnectWithoutContactInput[]
    upsert?: TagOnContactUpsertWithWhereUniqueWithoutContactInput | TagOnContactUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TagOnContactCreateManyContactInputEnvelope
    set?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    disconnect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    delete?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    connect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    update?: TagOnContactUpdateWithWhereUniqueWithoutContactInput | TagOnContactUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TagOnContactUpdateManyWithWhereWithoutContactInput | TagOnContactUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TagOnContactScalarWhereInput | TagOnContactScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput> | NoteCreateWithoutContactInput[] | NoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutContactInput | NoteCreateOrConnectWithoutContactInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutContactInput | NoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: NoteCreateManyContactInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutContactInput | NoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutContactInput | NoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type DripEnrollmentUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<DripEnrollmentCreateWithoutContactInput, DripEnrollmentUncheckedCreateWithoutContactInput> | DripEnrollmentCreateWithoutContactInput[] | DripEnrollmentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DripEnrollmentCreateOrConnectWithoutContactInput | DripEnrollmentCreateOrConnectWithoutContactInput[]
    upsert?: DripEnrollmentUpsertWithWhereUniqueWithoutContactInput | DripEnrollmentUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: DripEnrollmentCreateManyContactInputEnvelope
    set?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    disconnect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    delete?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    connect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    update?: DripEnrollmentUpdateWithWhereUniqueWithoutContactInput | DripEnrollmentUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: DripEnrollmentUpdateManyWithWhereWithoutContactInput | DripEnrollmentUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: DripEnrollmentScalarWhereInput | DripEnrollmentScalarWhereInput[]
  }

  export type DripScheduledMessageUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<DripScheduledMessageCreateWithoutContactInput, DripScheduledMessageUncheckedCreateWithoutContactInput> | DripScheduledMessageCreateWithoutContactInput[] | DripScheduledMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutContactInput | DripScheduledMessageCreateOrConnectWithoutContactInput[]
    upsert?: DripScheduledMessageUpsertWithWhereUniqueWithoutContactInput | DripScheduledMessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: DripScheduledMessageCreateManyContactInputEnvelope
    set?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    disconnect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    delete?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    update?: DripScheduledMessageUpdateWithWhereUniqueWithoutContactInput | DripScheduledMessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: DripScheduledMessageUpdateManyWithWhereWithoutContactInput | DripScheduledMessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: DripScheduledMessageScalarWhereInput | DripScheduledMessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutConversationsInput = {
    create?: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutConversationsInput
    connect?: ContactWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type ContactUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutConversationsInput
    upsert?: ContactUpsertWithoutConversationsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutConversationsInput, ContactUpdateWithoutConversationsInput>, ContactUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ContactCreateWithoutMessagesInput, ContactUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutMessagesInput
    connect?: ContactWhereUniqueInput
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type ReactionCreateNestedManyWithoutMessageInput = {
    create?: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput> | ReactionCreateWithoutMessageInput[] | ReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutMessageInput | ReactionCreateOrConnectWithoutMessageInput[]
    createMany?: ReactionCreateManyMessageInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutMessageInput = {
    create?: XOR<NoteCreateWithoutMessageInput, NoteUncheckedCreateWithoutMessageInput> | NoteCreateWithoutMessageInput[] | NoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMessageInput | NoteCreateOrConnectWithoutMessageInput[]
    createMany?: NoteCreateManyMessageInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput> | ReactionCreateWithoutMessageInput[] | ReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutMessageInput | ReactionCreateOrConnectWithoutMessageInput[]
    createMany?: ReactionCreateManyMessageInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<NoteCreateWithoutMessageInput, NoteUncheckedCreateWithoutMessageInput> | NoteCreateWithoutMessageInput[] | NoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMessageInput | NoteCreateOrConnectWithoutMessageInput[]
    createMany?: NoteCreateManyMessageInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type EnumMessageDirectionFieldUpdateOperationsInput = {
    set?: $Enums.MessageDirection
  }

  export type EnumMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.MessageStatus
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type ContactUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ContactCreateWithoutMessagesInput, ContactUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutMessagesInput
    upsert?: ContactUpsertWithoutMessagesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutMessagesInput, ContactUpdateWithoutMessagesInput>, ContactUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ReactionUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput> | ReactionCreateWithoutMessageInput[] | ReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutMessageInput | ReactionCreateOrConnectWithoutMessageInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutMessageInput | ReactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ReactionCreateManyMessageInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutMessageInput | ReactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutMessageInput | ReactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutMessageNestedInput = {
    create?: XOR<NoteCreateWithoutMessageInput, NoteUncheckedCreateWithoutMessageInput> | NoteCreateWithoutMessageInput[] | NoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMessageInput | NoteCreateOrConnectWithoutMessageInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutMessageInput | NoteUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: NoteCreateManyMessageInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutMessageInput | NoteUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutMessageInput | NoteUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput> | ReactionCreateWithoutMessageInput[] | ReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutMessageInput | ReactionCreateOrConnectWithoutMessageInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutMessageInput | ReactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ReactionCreateManyMessageInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutMessageInput | ReactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutMessageInput | ReactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<NoteCreateWithoutMessageInput, NoteUncheckedCreateWithoutMessageInput> | NoteCreateWithoutMessageInput[] | NoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMessageInput | NoteCreateOrConnectWithoutMessageInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutMessageInput | NoteUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: NoteCreateManyMessageInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutMessageInput | NoteUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutMessageInput | NoteUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutReactionsInput = {
    create?: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReactionsInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReactionsInput
    upsert?: MessageUpsertWithoutReactionsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutReactionsInput, MessageUpdateWithoutReactionsInput>, MessageUncheckedUpdateWithoutReactionsInput>
  }

  export type UserCreateNestedOneWithoutTagsInput = {
    create?: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput
    connect?: UserWhereUniqueInput
  }

  export type TagOnContactCreateNestedManyWithoutTagInput = {
    create?: XOR<TagOnContactCreateWithoutTagInput, TagOnContactUncheckedCreateWithoutTagInput> | TagOnContactCreateWithoutTagInput[] | TagOnContactUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagOnContactCreateOrConnectWithoutTagInput | TagOnContactCreateOrConnectWithoutTagInput[]
    createMany?: TagOnContactCreateManyTagInputEnvelope
    connect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
  }

  export type TagOnContactUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TagOnContactCreateWithoutTagInput, TagOnContactUncheckedCreateWithoutTagInput> | TagOnContactCreateWithoutTagInput[] | TagOnContactUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagOnContactCreateOrConnectWithoutTagInput | TagOnContactCreateOrConnectWithoutTagInput[]
    createMany?: TagOnContactCreateManyTagInputEnvelope
    connect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput
    upsert?: UserUpsertWithoutTagsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTagsInput, UserUpdateWithoutTagsInput>, UserUncheckedUpdateWithoutTagsInput>
  }

  export type TagOnContactUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagOnContactCreateWithoutTagInput, TagOnContactUncheckedCreateWithoutTagInput> | TagOnContactCreateWithoutTagInput[] | TagOnContactUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagOnContactCreateOrConnectWithoutTagInput | TagOnContactCreateOrConnectWithoutTagInput[]
    upsert?: TagOnContactUpsertWithWhereUniqueWithoutTagInput | TagOnContactUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagOnContactCreateManyTagInputEnvelope
    set?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    disconnect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    delete?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    connect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    update?: TagOnContactUpdateWithWhereUniqueWithoutTagInput | TagOnContactUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagOnContactUpdateManyWithWhereWithoutTagInput | TagOnContactUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagOnContactScalarWhereInput | TagOnContactScalarWhereInput[]
  }

  export type TagOnContactUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagOnContactCreateWithoutTagInput, TagOnContactUncheckedCreateWithoutTagInput> | TagOnContactCreateWithoutTagInput[] | TagOnContactUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagOnContactCreateOrConnectWithoutTagInput | TagOnContactCreateOrConnectWithoutTagInput[]
    upsert?: TagOnContactUpsertWithWhereUniqueWithoutTagInput | TagOnContactUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagOnContactCreateManyTagInputEnvelope
    set?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    disconnect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    delete?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    connect?: TagOnContactWhereUniqueInput | TagOnContactWhereUniqueInput[]
    update?: TagOnContactUpdateWithWhereUniqueWithoutTagInput | TagOnContactUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagOnContactUpdateManyWithWhereWithoutTagInput | TagOnContactUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagOnContactScalarWhereInput | TagOnContactScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutTagsInput = {
    create?: XOR<ContactCreateWithoutTagsInput, ContactUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTagsInput
    connect?: ContactWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutContactsInput = {
    create?: XOR<TagCreateWithoutContactsInput, TagUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TagCreateOrConnectWithoutContactsInput
    connect?: TagWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ContactCreateWithoutTagsInput, ContactUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTagsInput
    upsert?: ContactUpsertWithoutTagsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutTagsInput, ContactUpdateWithoutTagsInput>, ContactUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<TagCreateWithoutContactsInput, TagUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TagCreateOrConnectWithoutContactsInput
    upsert?: TagUpsertWithoutContactsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutContactsInput, TagUpdateWithoutContactsInput>, TagUncheckedUpdateWithoutContactsInput>
  }

  export type UserCreateNestedOneWithoutSegmentsInput = {
    create?: XOR<UserCreateWithoutSegmentsInput, UserUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSegmentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSegmentsNestedInput = {
    create?: XOR<UserCreateWithoutSegmentsInput, UserUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSegmentsInput
    upsert?: UserUpsertWithoutSegmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSegmentsInput, UserUpdateWithoutSegmentsInput>, UserUncheckedUpdateWithoutSegmentsInput>
  }

  export type EnumCampaignTypeFieldUpdateOperationsInput = {
    set?: $Enums.CampaignType
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type UserCreateNestedOneWithoutQuickRepliesInput = {
    create?: XOR<UserCreateWithoutQuickRepliesInput, UserUncheckedCreateWithoutQuickRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuickRepliesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutQuickRepliesNestedInput = {
    create?: XOR<UserCreateWithoutQuickRepliesInput, UserUncheckedCreateWithoutQuickRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuickRepliesInput
    upsert?: UserUpsertWithoutQuickRepliesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuickRepliesInput, UserUpdateWithoutQuickRepliesInput>, UserUncheckedUpdateWithoutQuickRepliesInput>
  }

  export type UserCreateNestedOneWithoutAutomationsInput = {
    create?: XOR<UserCreateWithoutAutomationsInput, UserUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutomationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAutomationsNestedInput = {
    create?: XOR<UserCreateWithoutAutomationsInput, UserUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutomationsInput
    upsert?: UserUpsertWithoutAutomationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAutomationsInput, UserUpdateWithoutAutomationsInput>, UserUncheckedUpdateWithoutAutomationsInput>
  }

  export type UserCreateNestedOneWithoutNotesInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    connect?: UserWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutNotesInput = {
    create?: XOR<ContactCreateWithoutNotesInput, ContactUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutNotesInput
    connect?: ContactWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutNotesInput = {
    create?: XOR<MessageCreateWithoutNotesInput, MessageUncheckedCreateWithoutNotesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutNotesInput
    connect?: MessageWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    upsert?: UserUpsertWithoutNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesInput, UserUpdateWithoutNotesInput>, UserUncheckedUpdateWithoutNotesInput>
  }

  export type ContactUpdateOneWithoutNotesNestedInput = {
    create?: XOR<ContactCreateWithoutNotesInput, ContactUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutNotesInput
    upsert?: ContactUpsertWithoutNotesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutNotesInput, ContactUpdateWithoutNotesInput>, ContactUncheckedUpdateWithoutNotesInput>
  }

  export type MessageUpdateOneWithoutNotesNestedInput = {
    create?: XOR<MessageCreateWithoutNotesInput, MessageUncheckedCreateWithoutNotesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutNotesInput
    upsert?: MessageUpsertWithoutNotesInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutNotesInput, MessageUpdateWithoutNotesInput>, MessageUncheckedUpdateWithoutNotesInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type UserUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type EnumConfigTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConfigType
  }

  export type UserCreateNestedOneWithoutDripCampaignsInput = {
    create?: XOR<UserCreateWithoutDripCampaignsInput, UserUncheckedCreateWithoutDripCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDripCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type DripCampaignStepCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DripCampaignStepCreateWithoutCampaignInput, DripCampaignStepUncheckedCreateWithoutCampaignInput> | DripCampaignStepCreateWithoutCampaignInput[] | DripCampaignStepUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripCampaignStepCreateOrConnectWithoutCampaignInput | DripCampaignStepCreateOrConnectWithoutCampaignInput[]
    createMany?: DripCampaignStepCreateManyCampaignInputEnvelope
    connect?: DripCampaignStepWhereUniqueInput | DripCampaignStepWhereUniqueInput[]
  }

  export type DripEnrollmentCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DripEnrollmentCreateWithoutCampaignInput, DripEnrollmentUncheckedCreateWithoutCampaignInput> | DripEnrollmentCreateWithoutCampaignInput[] | DripEnrollmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripEnrollmentCreateOrConnectWithoutCampaignInput | DripEnrollmentCreateOrConnectWithoutCampaignInput[]
    createMany?: DripEnrollmentCreateManyCampaignInputEnvelope
    connect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
  }

  export type DripScheduledMessageCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DripScheduledMessageCreateWithoutCampaignInput, DripScheduledMessageUncheckedCreateWithoutCampaignInput> | DripScheduledMessageCreateWithoutCampaignInput[] | DripScheduledMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutCampaignInput | DripScheduledMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: DripScheduledMessageCreateManyCampaignInputEnvelope
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
  }

  export type DripCampaignStepUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DripCampaignStepCreateWithoutCampaignInput, DripCampaignStepUncheckedCreateWithoutCampaignInput> | DripCampaignStepCreateWithoutCampaignInput[] | DripCampaignStepUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripCampaignStepCreateOrConnectWithoutCampaignInput | DripCampaignStepCreateOrConnectWithoutCampaignInput[]
    createMany?: DripCampaignStepCreateManyCampaignInputEnvelope
    connect?: DripCampaignStepWhereUniqueInput | DripCampaignStepWhereUniqueInput[]
  }

  export type DripEnrollmentUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DripEnrollmentCreateWithoutCampaignInput, DripEnrollmentUncheckedCreateWithoutCampaignInput> | DripEnrollmentCreateWithoutCampaignInput[] | DripEnrollmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripEnrollmentCreateOrConnectWithoutCampaignInput | DripEnrollmentCreateOrConnectWithoutCampaignInput[]
    createMany?: DripEnrollmentCreateManyCampaignInputEnvelope
    connect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
  }

  export type DripScheduledMessageUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DripScheduledMessageCreateWithoutCampaignInput, DripScheduledMessageUncheckedCreateWithoutCampaignInput> | DripScheduledMessageCreateWithoutCampaignInput[] | DripScheduledMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutCampaignInput | DripScheduledMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: DripScheduledMessageCreateManyCampaignInputEnvelope
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
  }

  export type EnumDripTriggerTypeFieldUpdateOperationsInput = {
    set?: $Enums.DripTriggerType
  }

  export type UserUpdateOneRequiredWithoutDripCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutDripCampaignsInput, UserUncheckedCreateWithoutDripCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDripCampaignsInput
    upsert?: UserUpsertWithoutDripCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDripCampaignsInput, UserUpdateWithoutDripCampaignsInput>, UserUncheckedUpdateWithoutDripCampaignsInput>
  }

  export type DripCampaignStepUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DripCampaignStepCreateWithoutCampaignInput, DripCampaignStepUncheckedCreateWithoutCampaignInput> | DripCampaignStepCreateWithoutCampaignInput[] | DripCampaignStepUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripCampaignStepCreateOrConnectWithoutCampaignInput | DripCampaignStepCreateOrConnectWithoutCampaignInput[]
    upsert?: DripCampaignStepUpsertWithWhereUniqueWithoutCampaignInput | DripCampaignStepUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DripCampaignStepCreateManyCampaignInputEnvelope
    set?: DripCampaignStepWhereUniqueInput | DripCampaignStepWhereUniqueInput[]
    disconnect?: DripCampaignStepWhereUniqueInput | DripCampaignStepWhereUniqueInput[]
    delete?: DripCampaignStepWhereUniqueInput | DripCampaignStepWhereUniqueInput[]
    connect?: DripCampaignStepWhereUniqueInput | DripCampaignStepWhereUniqueInput[]
    update?: DripCampaignStepUpdateWithWhereUniqueWithoutCampaignInput | DripCampaignStepUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DripCampaignStepUpdateManyWithWhereWithoutCampaignInput | DripCampaignStepUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DripCampaignStepScalarWhereInput | DripCampaignStepScalarWhereInput[]
  }

  export type DripEnrollmentUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DripEnrollmentCreateWithoutCampaignInput, DripEnrollmentUncheckedCreateWithoutCampaignInput> | DripEnrollmentCreateWithoutCampaignInput[] | DripEnrollmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripEnrollmentCreateOrConnectWithoutCampaignInput | DripEnrollmentCreateOrConnectWithoutCampaignInput[]
    upsert?: DripEnrollmentUpsertWithWhereUniqueWithoutCampaignInput | DripEnrollmentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DripEnrollmentCreateManyCampaignInputEnvelope
    set?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    disconnect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    delete?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    connect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    update?: DripEnrollmentUpdateWithWhereUniqueWithoutCampaignInput | DripEnrollmentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DripEnrollmentUpdateManyWithWhereWithoutCampaignInput | DripEnrollmentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DripEnrollmentScalarWhereInput | DripEnrollmentScalarWhereInput[]
  }

  export type DripScheduledMessageUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DripScheduledMessageCreateWithoutCampaignInput, DripScheduledMessageUncheckedCreateWithoutCampaignInput> | DripScheduledMessageCreateWithoutCampaignInput[] | DripScheduledMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutCampaignInput | DripScheduledMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: DripScheduledMessageUpsertWithWhereUniqueWithoutCampaignInput | DripScheduledMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DripScheduledMessageCreateManyCampaignInputEnvelope
    set?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    disconnect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    delete?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    update?: DripScheduledMessageUpdateWithWhereUniqueWithoutCampaignInput | DripScheduledMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DripScheduledMessageUpdateManyWithWhereWithoutCampaignInput | DripScheduledMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DripScheduledMessageScalarWhereInput | DripScheduledMessageScalarWhereInput[]
  }

  export type DripCampaignStepUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DripCampaignStepCreateWithoutCampaignInput, DripCampaignStepUncheckedCreateWithoutCampaignInput> | DripCampaignStepCreateWithoutCampaignInput[] | DripCampaignStepUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripCampaignStepCreateOrConnectWithoutCampaignInput | DripCampaignStepCreateOrConnectWithoutCampaignInput[]
    upsert?: DripCampaignStepUpsertWithWhereUniqueWithoutCampaignInput | DripCampaignStepUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DripCampaignStepCreateManyCampaignInputEnvelope
    set?: DripCampaignStepWhereUniqueInput | DripCampaignStepWhereUniqueInput[]
    disconnect?: DripCampaignStepWhereUniqueInput | DripCampaignStepWhereUniqueInput[]
    delete?: DripCampaignStepWhereUniqueInput | DripCampaignStepWhereUniqueInput[]
    connect?: DripCampaignStepWhereUniqueInput | DripCampaignStepWhereUniqueInput[]
    update?: DripCampaignStepUpdateWithWhereUniqueWithoutCampaignInput | DripCampaignStepUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DripCampaignStepUpdateManyWithWhereWithoutCampaignInput | DripCampaignStepUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DripCampaignStepScalarWhereInput | DripCampaignStepScalarWhereInput[]
  }

  export type DripEnrollmentUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DripEnrollmentCreateWithoutCampaignInput, DripEnrollmentUncheckedCreateWithoutCampaignInput> | DripEnrollmentCreateWithoutCampaignInput[] | DripEnrollmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripEnrollmentCreateOrConnectWithoutCampaignInput | DripEnrollmentCreateOrConnectWithoutCampaignInput[]
    upsert?: DripEnrollmentUpsertWithWhereUniqueWithoutCampaignInput | DripEnrollmentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DripEnrollmentCreateManyCampaignInputEnvelope
    set?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    disconnect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    delete?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    connect?: DripEnrollmentWhereUniqueInput | DripEnrollmentWhereUniqueInput[]
    update?: DripEnrollmentUpdateWithWhereUniqueWithoutCampaignInput | DripEnrollmentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DripEnrollmentUpdateManyWithWhereWithoutCampaignInput | DripEnrollmentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DripEnrollmentScalarWhereInput | DripEnrollmentScalarWhereInput[]
  }

  export type DripScheduledMessageUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DripScheduledMessageCreateWithoutCampaignInput, DripScheduledMessageUncheckedCreateWithoutCampaignInput> | DripScheduledMessageCreateWithoutCampaignInput[] | DripScheduledMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutCampaignInput | DripScheduledMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: DripScheduledMessageUpsertWithWhereUniqueWithoutCampaignInput | DripScheduledMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DripScheduledMessageCreateManyCampaignInputEnvelope
    set?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    disconnect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    delete?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    update?: DripScheduledMessageUpdateWithWhereUniqueWithoutCampaignInput | DripScheduledMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DripScheduledMessageUpdateManyWithWhereWithoutCampaignInput | DripScheduledMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DripScheduledMessageScalarWhereInput | DripScheduledMessageScalarWhereInput[]
  }

  export type DripCampaignCreateNestedOneWithoutStepsInput = {
    create?: XOR<DripCampaignCreateWithoutStepsInput, DripCampaignUncheckedCreateWithoutStepsInput>
    connectOrCreate?: DripCampaignCreateOrConnectWithoutStepsInput
    connect?: DripCampaignWhereUniqueInput
  }

  export type DripScheduledMessageCreateNestedManyWithoutStepInput = {
    create?: XOR<DripScheduledMessageCreateWithoutStepInput, DripScheduledMessageUncheckedCreateWithoutStepInput> | DripScheduledMessageCreateWithoutStepInput[] | DripScheduledMessageUncheckedCreateWithoutStepInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutStepInput | DripScheduledMessageCreateOrConnectWithoutStepInput[]
    createMany?: DripScheduledMessageCreateManyStepInputEnvelope
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
  }

  export type DripScheduledMessageUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<DripScheduledMessageCreateWithoutStepInput, DripScheduledMessageUncheckedCreateWithoutStepInput> | DripScheduledMessageCreateWithoutStepInput[] | DripScheduledMessageUncheckedCreateWithoutStepInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutStepInput | DripScheduledMessageCreateOrConnectWithoutStepInput[]
    createMany?: DripScheduledMessageCreateManyStepInputEnvelope
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
  }

  export type DripCampaignUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<DripCampaignCreateWithoutStepsInput, DripCampaignUncheckedCreateWithoutStepsInput>
    connectOrCreate?: DripCampaignCreateOrConnectWithoutStepsInput
    upsert?: DripCampaignUpsertWithoutStepsInput
    connect?: DripCampaignWhereUniqueInput
    update?: XOR<XOR<DripCampaignUpdateToOneWithWhereWithoutStepsInput, DripCampaignUpdateWithoutStepsInput>, DripCampaignUncheckedUpdateWithoutStepsInput>
  }

  export type DripScheduledMessageUpdateManyWithoutStepNestedInput = {
    create?: XOR<DripScheduledMessageCreateWithoutStepInput, DripScheduledMessageUncheckedCreateWithoutStepInput> | DripScheduledMessageCreateWithoutStepInput[] | DripScheduledMessageUncheckedCreateWithoutStepInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutStepInput | DripScheduledMessageCreateOrConnectWithoutStepInput[]
    upsert?: DripScheduledMessageUpsertWithWhereUniqueWithoutStepInput | DripScheduledMessageUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: DripScheduledMessageCreateManyStepInputEnvelope
    set?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    disconnect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    delete?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    update?: DripScheduledMessageUpdateWithWhereUniqueWithoutStepInput | DripScheduledMessageUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: DripScheduledMessageUpdateManyWithWhereWithoutStepInput | DripScheduledMessageUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: DripScheduledMessageScalarWhereInput | DripScheduledMessageScalarWhereInput[]
  }

  export type DripScheduledMessageUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<DripScheduledMessageCreateWithoutStepInput, DripScheduledMessageUncheckedCreateWithoutStepInput> | DripScheduledMessageCreateWithoutStepInput[] | DripScheduledMessageUncheckedCreateWithoutStepInput[]
    connectOrCreate?: DripScheduledMessageCreateOrConnectWithoutStepInput | DripScheduledMessageCreateOrConnectWithoutStepInput[]
    upsert?: DripScheduledMessageUpsertWithWhereUniqueWithoutStepInput | DripScheduledMessageUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: DripScheduledMessageCreateManyStepInputEnvelope
    set?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    disconnect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    delete?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    connect?: DripScheduledMessageWhereUniqueInput | DripScheduledMessageWhereUniqueInput[]
    update?: DripScheduledMessageUpdateWithWhereUniqueWithoutStepInput | DripScheduledMessageUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: DripScheduledMessageUpdateManyWithWhereWithoutStepInput | DripScheduledMessageUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: DripScheduledMessageScalarWhereInput | DripScheduledMessageScalarWhereInput[]
  }

  export type DripCampaignCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<DripCampaignCreateWithoutEnrollmentsInput, DripCampaignUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: DripCampaignCreateOrConnectWithoutEnrollmentsInput
    connect?: DripCampaignWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutDripEnrollmentsInput = {
    create?: XOR<ContactCreateWithoutDripEnrollmentsInput, ContactUncheckedCreateWithoutDripEnrollmentsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutDripEnrollmentsInput
    connect?: ContactWhereUniqueInput
  }

  export type EnumDripEnrollmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DripEnrollmentStatus
  }

  export type DripCampaignUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<DripCampaignCreateWithoutEnrollmentsInput, DripCampaignUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: DripCampaignCreateOrConnectWithoutEnrollmentsInput
    upsert?: DripCampaignUpsertWithoutEnrollmentsInput
    connect?: DripCampaignWhereUniqueInput
    update?: XOR<XOR<DripCampaignUpdateToOneWithWhereWithoutEnrollmentsInput, DripCampaignUpdateWithoutEnrollmentsInput>, DripCampaignUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ContactUpdateOneRequiredWithoutDripEnrollmentsNestedInput = {
    create?: XOR<ContactCreateWithoutDripEnrollmentsInput, ContactUncheckedCreateWithoutDripEnrollmentsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutDripEnrollmentsInput
    upsert?: ContactUpsertWithoutDripEnrollmentsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutDripEnrollmentsInput, ContactUpdateWithoutDripEnrollmentsInput>, ContactUncheckedUpdateWithoutDripEnrollmentsInput>
  }

  export type DripCampaignCreateNestedOneWithoutScheduledInput = {
    create?: XOR<DripCampaignCreateWithoutScheduledInput, DripCampaignUncheckedCreateWithoutScheduledInput>
    connectOrCreate?: DripCampaignCreateOrConnectWithoutScheduledInput
    connect?: DripCampaignWhereUniqueInput
  }

  export type DripCampaignStepCreateNestedOneWithoutScheduledInput = {
    create?: XOR<DripCampaignStepCreateWithoutScheduledInput, DripCampaignStepUncheckedCreateWithoutScheduledInput>
    connectOrCreate?: DripCampaignStepCreateOrConnectWithoutScheduledInput
    connect?: DripCampaignStepWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutDripScheduledInput = {
    create?: XOR<ContactCreateWithoutDripScheduledInput, ContactUncheckedCreateWithoutDripScheduledInput>
    connectOrCreate?: ContactCreateOrConnectWithoutDripScheduledInput
    connect?: ContactWhereUniqueInput
  }

  export type DripCampaignUpdateOneRequiredWithoutScheduledNestedInput = {
    create?: XOR<DripCampaignCreateWithoutScheduledInput, DripCampaignUncheckedCreateWithoutScheduledInput>
    connectOrCreate?: DripCampaignCreateOrConnectWithoutScheduledInput
    upsert?: DripCampaignUpsertWithoutScheduledInput
    connect?: DripCampaignWhereUniqueInput
    update?: XOR<XOR<DripCampaignUpdateToOneWithWhereWithoutScheduledInput, DripCampaignUpdateWithoutScheduledInput>, DripCampaignUncheckedUpdateWithoutScheduledInput>
  }

  export type DripCampaignStepUpdateOneRequiredWithoutScheduledNestedInput = {
    create?: XOR<DripCampaignStepCreateWithoutScheduledInput, DripCampaignStepUncheckedCreateWithoutScheduledInput>
    connectOrCreate?: DripCampaignStepCreateOrConnectWithoutScheduledInput
    upsert?: DripCampaignStepUpsertWithoutScheduledInput
    connect?: DripCampaignStepWhereUniqueInput
    update?: XOR<XOR<DripCampaignStepUpdateToOneWithWhereWithoutScheduledInput, DripCampaignStepUpdateWithoutScheduledInput>, DripCampaignStepUncheckedUpdateWithoutScheduledInput>
  }

  export type ContactUpdateOneRequiredWithoutDripScheduledNestedInput = {
    create?: XOR<ContactCreateWithoutDripScheduledInput, ContactUncheckedCreateWithoutDripScheduledInput>
    connectOrCreate?: ContactCreateOrConnectWithoutDripScheduledInput
    upsert?: ContactUpsertWithoutDripScheduledInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutDripScheduledInput, ContactUpdateWithoutDripScheduledInput>, ContactUncheckedUpdateWithoutDripScheduledInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageDirection | EnumMessageDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.MessageDirection[]
    notIn?: $Enums.MessageDirection[]
    not?: NestedEnumMessageDirectionFilter<$PrismaModel> | $Enums.MessageDirection
  }

  export type NestedEnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[]
    notIn?: $Enums.MessageStatus[]
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumMessageDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageDirection | EnumMessageDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.MessageDirection[]
    notIn?: $Enums.MessageDirection[]
    not?: NestedEnumMessageDirectionWithAggregatesFilter<$PrismaModel> | $Enums.MessageDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageDirectionFilter<$PrismaModel>
    _max?: NestedEnumMessageDirectionFilter<$PrismaModel>
  }

  export type NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[]
    notIn?: $Enums.MessageStatus[]
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCampaignTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[]
    notIn?: $Enums.CampaignType[]
    not?: NestedEnumCampaignTypeFilter<$PrismaModel> | $Enums.CampaignType
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[]
    notIn?: $Enums.CampaignStatus[]
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumCampaignTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[]
    notIn?: $Enums.CampaignType[]
    not?: NestedEnumCampaignTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignTypeFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[]
    notIn?: $Enums.CampaignStatus[]
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[]
    notIn?: $Enums.ActivityType[]
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[]
    notIn?: $Enums.ActivityType[]
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedEnumConfigTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfigType | EnumConfigTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConfigType[]
    notIn?: $Enums.ConfigType[]
    not?: NestedEnumConfigTypeFilter<$PrismaModel> | $Enums.ConfigType
  }

  export type NestedEnumConfigTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfigType | EnumConfigTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConfigType[]
    notIn?: $Enums.ConfigType[]
    not?: NestedEnumConfigTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConfigType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfigTypeFilter<$PrismaModel>
    _max?: NestedEnumConfigTypeFilter<$PrismaModel>
  }

  export type NestedEnumDripTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DripTriggerType | EnumDripTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DripTriggerType[]
    notIn?: $Enums.DripTriggerType[]
    not?: NestedEnumDripTriggerTypeFilter<$PrismaModel> | $Enums.DripTriggerType
  }

  export type NestedEnumDripTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DripTriggerType | EnumDripTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DripTriggerType[]
    notIn?: $Enums.DripTriggerType[]
    not?: NestedEnumDripTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.DripTriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDripTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumDripTriggerTypeFilter<$PrismaModel>
  }

  export type NestedEnumDripEnrollmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DripEnrollmentStatus | EnumDripEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DripEnrollmentStatus[]
    notIn?: $Enums.DripEnrollmentStatus[]
    not?: NestedEnumDripEnrollmentStatusFilter<$PrismaModel> | $Enums.DripEnrollmentStatus
  }

  export type NestedEnumDripEnrollmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DripEnrollmentStatus | EnumDripEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DripEnrollmentStatus[]
    notIn?: $Enums.DripEnrollmentStatus[]
    not?: NestedEnumDripEnrollmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DripEnrollmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDripEnrollmentStatusFilter<$PrismaModel>
    _max?: NestedEnumDripEnrollmentStatusFilter<$PrismaModel>
  }

  export type ConversationCreateWithoutUserInput = {
    id?: string
    isActive?: boolean
    unreadCount?: number
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: string
    contactId: string
    isActive?: boolean
    unreadCount?: number
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: ConversationCreateManyUserInput | ConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUserInput = {
    id?: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutMessagesInput
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    reactions?: ReactionCreateNestedManyWithoutMessageInput
    notes?: NoteCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id?: string
    contactId: string
    conversationId: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ReactionUncheckedCreateNestedManyWithoutMessageInput
    notes?: NoteUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: MessageCreateManyUserInput | MessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutUserInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutContactInput
    messages?: MessageCreateNestedManyWithoutContactInput
    tags?: TagOnContactCreateNestedManyWithoutContactInput
    notes?: NoteCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutUserInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
    messages?: MessageUncheckedCreateNestedManyWithoutContactInput
    tags?: TagOnContactUncheckedCreateNestedManyWithoutContactInput
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentUncheckedCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutUserInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactCreateManyUserInputEnvelope = {
    data: ContactCreateManyUserInput | ContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutUserInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    contacts?: TagOnContactCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    contacts?: TagOnContactUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutUserInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput>
  }

  export type TagCreateManyUserInputEnvelope = {
    data: TagCreateManyUserInput | TagCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SegmentCreateWithoutUserInput = {
    id?: string
    name: string
    criteria: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    criteria: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentCreateOrConnectWithoutUserInput = {
    where: SegmentWhereUniqueInput
    create: XOR<SegmentCreateWithoutUserInput, SegmentUncheckedCreateWithoutUserInput>
  }

  export type SegmentCreateManyUserInputEnvelope = {
    data: SegmentCreateManyUserInput | SegmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuickReplyCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    category?: string | null
    shortcut?: string | null
    isActive?: boolean
    usageCount?: number
    usageTodayCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuickReplyUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    category?: string | null
    shortcut?: string | null
    isActive?: boolean
    usageCount?: number
    usageTodayCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuickReplyCreateOrConnectWithoutUserInput = {
    where: QuickReplyWhereUniqueInput
    create: XOR<QuickReplyCreateWithoutUserInput, QuickReplyUncheckedCreateWithoutUserInput>
  }

  export type QuickReplyCreateManyUserInputEnvelope = {
    data: QuickReplyCreateManyUserInput | QuickReplyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AutomationCreateWithoutUserInput = {
    id?: string
    name: string
    trigger: string
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    trigger: string
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationCreateOrConnectWithoutUserInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput>
  }

  export type AutomationCreateManyUserInputEnvelope = {
    data: AutomationCreateManyUserInput | AutomationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: ContactCreateNestedOneWithoutNotesInput
    message?: MessageCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutUserInput = {
    id?: string
    contactId?: string | null
    messageId?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutUserInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
  }

  export type NoteCreateManyUserInputEnvelope = {
    data: NoteCreateManyUserInput | NoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutUserInput = {
    id?: string
    action: $Enums.ActivityType
    resourceType?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: $Enums.ActivityType
    resourceType?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DripCampaignCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: DripCampaignStepCreateNestedManyWithoutCampaignInput
    enrollments?: DripEnrollmentCreateNestedManyWithoutCampaignInput
    scheduled?: DripScheduledMessageCreateNestedManyWithoutCampaignInput
  }

  export type DripCampaignUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: DripCampaignStepUncheckedCreateNestedManyWithoutCampaignInput
    enrollments?: DripEnrollmentUncheckedCreateNestedManyWithoutCampaignInput
    scheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type DripCampaignCreateOrConnectWithoutUserInput = {
    where: DripCampaignWhereUniqueInput
    create: XOR<DripCampaignCreateWithoutUserInput, DripCampaignUncheckedCreateWithoutUserInput>
  }

  export type DripCampaignCreateManyUserInputEnvelope = {
    data: DripCampaignCreateManyUserInput | DripCampaignCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    contactId?: StringFilter<"Conversation"> | string
    isActive?: BoolFilter<"Conversation"> | boolean
    unreadCount?: IntFilter<"Conversation"> | number
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    metadata?: JsonNullableFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    userId?: StringFilter<"Message"> | string
    contactId?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    waMessageId?: StringNullableFilter<"Message"> | string | null
    content?: StringNullableFilter<"Message"> | string | null
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    direction?: EnumMessageDirectionFilter<"Message"> | $Enums.MessageDirection
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    mediaType?: StringNullableFilter<"Message"> | string | null
    mediaFileName?: StringNullableFilter<"Message"> | string | null
    quotedMessageId?: StringNullableFilter<"Message"> | string | null
    isGroupMessage?: BoolFilter<"Message"> | boolean
    groupId?: StringNullableFilter<"Message"> | string | null
    groupName?: StringNullableFilter<"Message"> | string | null
    isStatusUpdate?: BoolFilter<"Message"> | boolean
    isChannelMessage?: BoolFilter<"Message"> | boolean
    channelId?: StringNullableFilter<"Message"> | string | null
    senderName?: StringNullableFilter<"Message"> | string | null
    templateId?: StringNullableFilter<"Message"> | string | null
    quickReplyId?: StringNullableFilter<"Message"> | string | null
    tagIds?: JsonNullableFilter<"Message">
    metadata?: JsonNullableFilter<"Message">
    scheduledAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    sendAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
  }

  export type ContactUpdateManyWithWhereWithoutUserInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutUserInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    userId?: StringFilter<"Contact"> | string
    phoneNumber?: StringFilter<"Contact"> | string
    name?: StringNullableFilter<"Contact"> | string | null
    pushName?: StringNullableFilter<"Contact"> | string | null
    businessName?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    avatarUrl?: StringNullableFilter<"Contact"> | string | null
    profilePhotoUrl?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    department?: StringNullableFilter<"Contact"> | string | null
    contactType?: StringFilter<"Contact"> | string
    timezone?: StringNullableFilter<"Contact"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    lastActiveAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    engagementScore?: FloatFilter<"Contact"> | number
    engagementLevel?: StringFilter<"Contact"> | string
    messageCount?: IntFilter<"Contact"> | number
    totalInteractions?: IntFilter<"Contact"> | number
    isBlocked?: BoolFilter<"Contact"> | boolean
    isBusiness?: BoolFilter<"Contact"> | boolean
    isVerified?: BoolFilter<"Contact"> | boolean
    customFields?: JsonNullableFilter<"Contact">
    metadata?: JsonNullableFilter<"Contact">
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type TagUpsertWithWhereUniqueWithoutUserInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutUserInput, TagUncheckedUpdateWithoutUserInput>
    create: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput>
  }

  export type TagUpdateWithWhereUniqueWithoutUserInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutUserInput, TagUncheckedUpdateWithoutUserInput>
  }

  export type TagUpdateManyWithWhereWithoutUserInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutUserInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    userId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type SegmentUpsertWithWhereUniqueWithoutUserInput = {
    where: SegmentWhereUniqueInput
    update: XOR<SegmentUpdateWithoutUserInput, SegmentUncheckedUpdateWithoutUserInput>
    create: XOR<SegmentCreateWithoutUserInput, SegmentUncheckedCreateWithoutUserInput>
  }

  export type SegmentUpdateWithWhereUniqueWithoutUserInput = {
    where: SegmentWhereUniqueInput
    data: XOR<SegmentUpdateWithoutUserInput, SegmentUncheckedUpdateWithoutUserInput>
  }

  export type SegmentUpdateManyWithWhereWithoutUserInput = {
    where: SegmentScalarWhereInput
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyWithoutUserInput>
  }

  export type SegmentScalarWhereInput = {
    AND?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
    OR?: SegmentScalarWhereInput[]
    NOT?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
    id?: StringFilter<"Segment"> | string
    userId?: StringFilter<"Segment"> | string
    name?: StringFilter<"Segment"> | string
    criteria?: JsonFilter<"Segment">
    createdAt?: DateTimeFilter<"Segment"> | Date | string
    updatedAt?: DateTimeFilter<"Segment"> | Date | string
  }

  export type QuickReplyUpsertWithWhereUniqueWithoutUserInput = {
    where: QuickReplyWhereUniqueInput
    update: XOR<QuickReplyUpdateWithoutUserInput, QuickReplyUncheckedUpdateWithoutUserInput>
    create: XOR<QuickReplyCreateWithoutUserInput, QuickReplyUncheckedCreateWithoutUserInput>
  }

  export type QuickReplyUpdateWithWhereUniqueWithoutUserInput = {
    where: QuickReplyWhereUniqueInput
    data: XOR<QuickReplyUpdateWithoutUserInput, QuickReplyUncheckedUpdateWithoutUserInput>
  }

  export type QuickReplyUpdateManyWithWhereWithoutUserInput = {
    where: QuickReplyScalarWhereInput
    data: XOR<QuickReplyUpdateManyMutationInput, QuickReplyUncheckedUpdateManyWithoutUserInput>
  }

  export type QuickReplyScalarWhereInput = {
    AND?: QuickReplyScalarWhereInput | QuickReplyScalarWhereInput[]
    OR?: QuickReplyScalarWhereInput[]
    NOT?: QuickReplyScalarWhereInput | QuickReplyScalarWhereInput[]
    id?: StringFilter<"QuickReply"> | string
    userId?: StringFilter<"QuickReply"> | string
    title?: StringFilter<"QuickReply"> | string
    content?: StringFilter<"QuickReply"> | string
    category?: StringNullableFilter<"QuickReply"> | string | null
    shortcut?: StringNullableFilter<"QuickReply"> | string | null
    isActive?: BoolFilter<"QuickReply"> | boolean
    usageCount?: IntFilter<"QuickReply"> | number
    usageTodayCount?: IntFilter<"QuickReply"> | number
    createdAt?: DateTimeFilter<"QuickReply"> | Date | string
    updatedAt?: DateTimeFilter<"QuickReply"> | Date | string
  }

  export type AutomationUpsertWithWhereUniqueWithoutUserInput = {
    where: AutomationWhereUniqueInput
    update: XOR<AutomationUpdateWithoutUserInput, AutomationUncheckedUpdateWithoutUserInput>
    create: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput>
  }

  export type AutomationUpdateWithWhereUniqueWithoutUserInput = {
    where: AutomationWhereUniqueInput
    data: XOR<AutomationUpdateWithoutUserInput, AutomationUncheckedUpdateWithoutUserInput>
  }

  export type AutomationUpdateManyWithWhereWithoutUserInput = {
    where: AutomationScalarWhereInput
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyWithoutUserInput>
  }

  export type AutomationScalarWhereInput = {
    AND?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
    OR?: AutomationScalarWhereInput[]
    NOT?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
    id?: StringFilter<"Automation"> | string
    userId?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    trigger?: StringFilter<"Automation"> | string
    actions?: JsonFilter<"Automation">
    isActive?: BoolFilter<"Automation"> | boolean
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
  }

  export type NoteUpsertWithWhereUniqueWithoutUserInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutUserInput, NoteUncheckedUpdateWithoutUserInput>
    create: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutUserInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutUserInput, NoteUncheckedUpdateWithoutUserInput>
  }

  export type NoteUpdateManyWithWhereWithoutUserInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutUserInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: StringFilter<"Note"> | string
    userId?: StringFilter<"Note"> | string
    contactId?: StringNullableFilter<"Note"> | string | null
    messageId?: StringNullableFilter<"Note"> | string | null
    content?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringFilter<"ActivityLog"> | string
    action?: EnumActivityTypeFilter<"ActivityLog"> | $Enums.ActivityType
    resourceType?: StringNullableFilter<"ActivityLog"> | string | null
    resourceId?: StringNullableFilter<"ActivityLog"> | string | null
    details?: JsonNullableFilter<"ActivityLog">
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type DripCampaignUpsertWithWhereUniqueWithoutUserInput = {
    where: DripCampaignWhereUniqueInput
    update: XOR<DripCampaignUpdateWithoutUserInput, DripCampaignUncheckedUpdateWithoutUserInput>
    create: XOR<DripCampaignCreateWithoutUserInput, DripCampaignUncheckedCreateWithoutUserInput>
  }

  export type DripCampaignUpdateWithWhereUniqueWithoutUserInput = {
    where: DripCampaignWhereUniqueInput
    data: XOR<DripCampaignUpdateWithoutUserInput, DripCampaignUncheckedUpdateWithoutUserInput>
  }

  export type DripCampaignUpdateManyWithWhereWithoutUserInput = {
    where: DripCampaignScalarWhereInput
    data: XOR<DripCampaignUpdateManyMutationInput, DripCampaignUncheckedUpdateManyWithoutUserInput>
  }

  export type DripCampaignScalarWhereInput = {
    AND?: DripCampaignScalarWhereInput | DripCampaignScalarWhereInput[]
    OR?: DripCampaignScalarWhereInput[]
    NOT?: DripCampaignScalarWhereInput | DripCampaignScalarWhereInput[]
    id?: StringFilter<"DripCampaign"> | string
    userId?: StringFilter<"DripCampaign"> | string
    name?: StringFilter<"DripCampaign"> | string
    description?: StringNullableFilter<"DripCampaign"> | string | null
    triggerType?: EnumDripTriggerTypeFilter<"DripCampaign"> | $Enums.DripTriggerType
    triggerValue?: StringNullableFilter<"DripCampaign"> | string | null
    isActive?: BoolFilter<"DripCampaign"> | boolean
    createdAt?: DateTimeFilter<"DripCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"DripCampaign"> | Date | string
  }

  export type UserCreateWithoutContactsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    segments?: SegmentCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyCreateNestedManyWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContactsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    segments?: SegmentUncheckedCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyUncheckedCreateNestedManyWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
  }

  export type ConversationCreateWithoutContactInput = {
    id?: string
    isActive?: boolean
    unreadCount?: number
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutContactInput = {
    id?: string
    userId: string
    isActive?: boolean
    unreadCount?: number
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutContactInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput>
  }

  export type ConversationCreateManyContactInputEnvelope = {
    data: ConversationCreateManyContactInput | ConversationCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutContactInput = {
    id?: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMessagesInput
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    reactions?: ReactionCreateNestedManyWithoutMessageInput
    notes?: NoteCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutContactInput = {
    id?: string
    userId: string
    conversationId: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ReactionUncheckedCreateNestedManyWithoutMessageInput
    notes?: NoteUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutContactInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput>
  }

  export type MessageCreateManyContactInputEnvelope = {
    data: MessageCreateManyContactInput | MessageCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type TagOnContactCreateWithoutContactInput = {
    assignedAt?: Date | string
    tag: TagCreateNestedOneWithoutContactsInput
  }

  export type TagOnContactUncheckedCreateWithoutContactInput = {
    tagId: string
    assignedAt?: Date | string
  }

  export type TagOnContactCreateOrConnectWithoutContactInput = {
    where: TagOnContactWhereUniqueInput
    create: XOR<TagOnContactCreateWithoutContactInput, TagOnContactUncheckedCreateWithoutContactInput>
  }

  export type TagOnContactCreateManyContactInputEnvelope = {
    data: TagOnContactCreateManyContactInput | TagOnContactCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutContactInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotesInput
    message?: MessageCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutContactInput = {
    id?: string
    userId: string
    messageId?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutContactInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput>
  }

  export type NoteCreateManyContactInputEnvelope = {
    data: NoteCreateManyContactInput | NoteCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type DripEnrollmentCreateWithoutContactInput = {
    id?: string
    currentStep?: number
    status: $Enums.DripEnrollmentStatus
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    campaign: DripCampaignCreateNestedOneWithoutEnrollmentsInput
  }

  export type DripEnrollmentUncheckedCreateWithoutContactInput = {
    id?: string
    campaignId: string
    currentStep?: number
    status: $Enums.DripEnrollmentStatus
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type DripEnrollmentCreateOrConnectWithoutContactInput = {
    where: DripEnrollmentWhereUniqueInput
    create: XOR<DripEnrollmentCreateWithoutContactInput, DripEnrollmentUncheckedCreateWithoutContactInput>
  }

  export type DripEnrollmentCreateManyContactInputEnvelope = {
    data: DripEnrollmentCreateManyContactInput | DripEnrollmentCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type DripScheduledMessageCreateWithoutContactInput = {
    id?: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
    campaign: DripCampaignCreateNestedOneWithoutScheduledInput
    step: DripCampaignStepCreateNestedOneWithoutScheduledInput
  }

  export type DripScheduledMessageUncheckedCreateWithoutContactInput = {
    id?: string
    campaignId: string
    stepId: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DripScheduledMessageCreateOrConnectWithoutContactInput = {
    where: DripScheduledMessageWhereUniqueInput
    create: XOR<DripScheduledMessageCreateWithoutContactInput, DripScheduledMessageUncheckedCreateWithoutContactInput>
  }

  export type DripScheduledMessageCreateManyContactInputEnvelope = {
    data: DripScheduledMessageCreateManyContactInput | DripScheduledMessageCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutContactsInput = {
    update: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    segments?: SegmentUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUpdateManyWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUncheckedUpdateManyWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationUpsertWithWhereUniqueWithoutContactInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutContactInput, ConversationUncheckedUpdateWithoutContactInput>
    create: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutContactInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutContactInput, ConversationUncheckedUpdateWithoutContactInput>
  }

  export type ConversationUpdateManyWithWhereWithoutContactInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutContactInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutContactInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutContactInput, MessageUncheckedUpdateWithoutContactInput>
    create: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutContactInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutContactInput, MessageUncheckedUpdateWithoutContactInput>
  }

  export type MessageUpdateManyWithWhereWithoutContactInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutContactInput>
  }

  export type TagOnContactUpsertWithWhereUniqueWithoutContactInput = {
    where: TagOnContactWhereUniqueInput
    update: XOR<TagOnContactUpdateWithoutContactInput, TagOnContactUncheckedUpdateWithoutContactInput>
    create: XOR<TagOnContactCreateWithoutContactInput, TagOnContactUncheckedCreateWithoutContactInput>
  }

  export type TagOnContactUpdateWithWhereUniqueWithoutContactInput = {
    where: TagOnContactWhereUniqueInput
    data: XOR<TagOnContactUpdateWithoutContactInput, TagOnContactUncheckedUpdateWithoutContactInput>
  }

  export type TagOnContactUpdateManyWithWhereWithoutContactInput = {
    where: TagOnContactScalarWhereInput
    data: XOR<TagOnContactUpdateManyMutationInput, TagOnContactUncheckedUpdateManyWithoutContactInput>
  }

  export type TagOnContactScalarWhereInput = {
    AND?: TagOnContactScalarWhereInput | TagOnContactScalarWhereInput[]
    OR?: TagOnContactScalarWhereInput[]
    NOT?: TagOnContactScalarWhereInput | TagOnContactScalarWhereInput[]
    contactId?: StringFilter<"TagOnContact"> | string
    tagId?: StringFilter<"TagOnContact"> | string
    assignedAt?: DateTimeFilter<"TagOnContact"> | Date | string
  }

  export type NoteUpsertWithWhereUniqueWithoutContactInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutContactInput, NoteUncheckedUpdateWithoutContactInput>
    create: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutContactInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutContactInput, NoteUncheckedUpdateWithoutContactInput>
  }

  export type NoteUpdateManyWithWhereWithoutContactInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutContactInput>
  }

  export type DripEnrollmentUpsertWithWhereUniqueWithoutContactInput = {
    where: DripEnrollmentWhereUniqueInput
    update: XOR<DripEnrollmentUpdateWithoutContactInput, DripEnrollmentUncheckedUpdateWithoutContactInput>
    create: XOR<DripEnrollmentCreateWithoutContactInput, DripEnrollmentUncheckedCreateWithoutContactInput>
  }

  export type DripEnrollmentUpdateWithWhereUniqueWithoutContactInput = {
    where: DripEnrollmentWhereUniqueInput
    data: XOR<DripEnrollmentUpdateWithoutContactInput, DripEnrollmentUncheckedUpdateWithoutContactInput>
  }

  export type DripEnrollmentUpdateManyWithWhereWithoutContactInput = {
    where: DripEnrollmentScalarWhereInput
    data: XOR<DripEnrollmentUpdateManyMutationInput, DripEnrollmentUncheckedUpdateManyWithoutContactInput>
  }

  export type DripEnrollmentScalarWhereInput = {
    AND?: DripEnrollmentScalarWhereInput | DripEnrollmentScalarWhereInput[]
    OR?: DripEnrollmentScalarWhereInput[]
    NOT?: DripEnrollmentScalarWhereInput | DripEnrollmentScalarWhereInput[]
    id?: StringFilter<"DripEnrollment"> | string
    campaignId?: StringFilter<"DripEnrollment"> | string
    contactId?: StringFilter<"DripEnrollment"> | string
    currentStep?: IntFilter<"DripEnrollment"> | number
    status?: EnumDripEnrollmentStatusFilter<"DripEnrollment"> | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFilter<"DripEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"DripEnrollment"> | Date | string | null
  }

  export type DripScheduledMessageUpsertWithWhereUniqueWithoutContactInput = {
    where: DripScheduledMessageWhereUniqueInput
    update: XOR<DripScheduledMessageUpdateWithoutContactInput, DripScheduledMessageUncheckedUpdateWithoutContactInput>
    create: XOR<DripScheduledMessageCreateWithoutContactInput, DripScheduledMessageUncheckedCreateWithoutContactInput>
  }

  export type DripScheduledMessageUpdateWithWhereUniqueWithoutContactInput = {
    where: DripScheduledMessageWhereUniqueInput
    data: XOR<DripScheduledMessageUpdateWithoutContactInput, DripScheduledMessageUncheckedUpdateWithoutContactInput>
  }

  export type DripScheduledMessageUpdateManyWithWhereWithoutContactInput = {
    where: DripScheduledMessageScalarWhereInput
    data: XOR<DripScheduledMessageUpdateManyMutationInput, DripScheduledMessageUncheckedUpdateManyWithoutContactInput>
  }

  export type DripScheduledMessageScalarWhereInput = {
    AND?: DripScheduledMessageScalarWhereInput | DripScheduledMessageScalarWhereInput[]
    OR?: DripScheduledMessageScalarWhereInput[]
    NOT?: DripScheduledMessageScalarWhereInput | DripScheduledMessageScalarWhereInput[]
    id?: StringFilter<"DripScheduledMessage"> | string
    campaignId?: StringFilter<"DripScheduledMessage"> | string
    stepId?: StringFilter<"DripScheduledMessage"> | string
    contactId?: StringFilter<"DripScheduledMessage"> | string
    message?: StringFilter<"DripScheduledMessage"> | string
    mediaUrl?: StringNullableFilter<"DripScheduledMessage"> | string | null
    mediaType?: StringNullableFilter<"DripScheduledMessage"> | string | null
    scheduledFor?: DateTimeFilter<"DripScheduledMessage"> | Date | string
    status?: StringFilter<"DripScheduledMessage"> | string
    sentAt?: DateTimeNullableFilter<"DripScheduledMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"DripScheduledMessage"> | Date | string
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    messages?: MessageCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    segments?: SegmentCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyCreateNestedManyWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    segments?: SegmentUncheckedCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyUncheckedCreateNestedManyWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type ContactCreateWithoutConversationsInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContactsInput
    messages?: MessageCreateNestedManyWithoutContactInput
    tags?: TagOnContactCreateNestedManyWithoutContactInput
    notes?: NoteCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutConversationsInput = {
    id?: string
    userId: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutContactInput
    tags?: TagOnContactUncheckedCreateNestedManyWithoutContactInput
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentUncheckedCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutConversationsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMessagesInput
    contact: ContactCreateNestedOneWithoutMessagesInput
    reactions?: ReactionCreateNestedManyWithoutMessageInput
    notes?: NoteCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    userId: string
    contactId: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ReactionUncheckedCreateNestedManyWithoutMessageInput
    notes?: NoteUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    segments?: SegmentUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUpdateManyWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUncheckedUpdateManyWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContactUpsertWithoutConversationsInput = {
    update: XOR<ContactUpdateWithoutConversationsInput, ContactUncheckedUpdateWithoutConversationsInput>
    create: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutConversationsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutConversationsInput, ContactUncheckedUpdateWithoutConversationsInput>
  }

  export type ContactUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
    messages?: MessageUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUpdateManyWithoutContactNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUncheckedUpdateManyWithoutContactNestedInput
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUncheckedUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    segments?: SegmentCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyCreateNestedManyWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    segments?: SegmentUncheckedCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyUncheckedCreateNestedManyWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ContactCreateWithoutMessagesInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContactsInput
    conversations?: ConversationCreateNestedManyWithoutContactInput
    tags?: TagOnContactCreateNestedManyWithoutContactInput
    notes?: NoteCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
    tags?: TagOnContactUncheckedCreateNestedManyWithoutContactInput
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentUncheckedCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutMessagesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutMessagesInput, ContactUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    isActive?: boolean
    unreadCount?: number
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    contact: ContactCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    contactId: string
    isActive?: boolean
    unreadCount?: number
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ReactionCreateWithoutMessageInput = {
    id?: string
    emoji: string
    createdAt?: Date | string
  }

  export type ReactionUncheckedCreateWithoutMessageInput = {
    id?: string
    emoji: string
    createdAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutMessageInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput>
  }

  export type ReactionCreateManyMessageInputEnvelope = {
    data: ReactionCreateManyMessageInput | ReactionCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutMessageInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotesInput
    contact?: ContactCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    contactId?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutMessageInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutMessageInput, NoteUncheckedCreateWithoutMessageInput>
  }

  export type NoteCreateManyMessageInputEnvelope = {
    data: NoteCreateManyMessageInput | NoteCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    segments?: SegmentUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUpdateManyWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUncheckedUpdateManyWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContactUpsertWithoutMessagesInput = {
    update: XOR<ContactUpdateWithoutMessagesInput, ContactUncheckedUpdateWithoutMessagesInput>
    create: XOR<ContactCreateWithoutMessagesInput, ContactUncheckedCreateWithoutMessagesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutMessagesInput, ContactUncheckedUpdateWithoutMessagesInput>
  }

  export type ContactUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
    conversations?: ConversationUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUpdateManyWithoutContactNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUncheckedUpdateManyWithoutContactNestedInput
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUncheckedUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    contact?: ContactUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUpsertWithWhereUniqueWithoutMessageInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutMessageInput, ReactionUncheckedUpdateWithoutMessageInput>
    create: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutMessageInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutMessageInput, ReactionUncheckedUpdateWithoutMessageInput>
  }

  export type ReactionUpdateManyWithWhereWithoutMessageInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutMessageInput>
  }

  export type ReactionScalarWhereInput = {
    AND?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    OR?: ReactionScalarWhereInput[]
    NOT?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    id?: StringFilter<"Reaction"> | string
    messageId?: StringFilter<"Reaction"> | string
    emoji?: StringFilter<"Reaction"> | string
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
  }

  export type NoteUpsertWithWhereUniqueWithoutMessageInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutMessageInput, NoteUncheckedUpdateWithoutMessageInput>
    create: XOR<NoteCreateWithoutMessageInput, NoteUncheckedCreateWithoutMessageInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutMessageInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutMessageInput, NoteUncheckedUpdateWithoutMessageInput>
  }

  export type NoteUpdateManyWithWhereWithoutMessageInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageCreateWithoutReactionsInput = {
    id?: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMessagesInput
    contact: ContactCreateNestedOneWithoutMessagesInput
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    notes?: NoteCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutReactionsInput = {
    id?: string
    userId: string
    contactId: string
    conversationId: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: NoteUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutReactionsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
  }

  export type MessageUpsertWithoutReactionsInput = {
    update: XOR<MessageUpdateWithoutReactionsInput, MessageUncheckedUpdateWithoutReactionsInput>
    create: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutReactionsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutReactionsInput, MessageUncheckedUpdateWithoutReactionsInput>
  }

  export type MessageUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    contact?: ContactUpdateOneRequiredWithoutMessagesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    notes?: NoteUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NoteUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserCreateWithoutTagsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    segments?: SegmentCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyCreateNestedManyWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTagsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    segments?: SegmentUncheckedCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyUncheckedCreateNestedManyWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTagsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
  }

  export type TagOnContactCreateWithoutTagInput = {
    assignedAt?: Date | string
    contact: ContactCreateNestedOneWithoutTagsInput
  }

  export type TagOnContactUncheckedCreateWithoutTagInput = {
    contactId: string
    assignedAt?: Date | string
  }

  export type TagOnContactCreateOrConnectWithoutTagInput = {
    where: TagOnContactWhereUniqueInput
    create: XOR<TagOnContactCreateWithoutTagInput, TagOnContactUncheckedCreateWithoutTagInput>
  }

  export type TagOnContactCreateManyTagInputEnvelope = {
    data: TagOnContactCreateManyTagInput | TagOnContactCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTagsInput = {
    update: XOR<UserUpdateWithoutTagsInput, UserUncheckedUpdateWithoutTagsInput>
    create: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTagsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTagsInput, UserUncheckedUpdateWithoutTagsInput>
  }

  export type UserUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    segments?: SegmentUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUpdateManyWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUncheckedUpdateManyWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TagOnContactUpsertWithWhereUniqueWithoutTagInput = {
    where: TagOnContactWhereUniqueInput
    update: XOR<TagOnContactUpdateWithoutTagInput, TagOnContactUncheckedUpdateWithoutTagInput>
    create: XOR<TagOnContactCreateWithoutTagInput, TagOnContactUncheckedCreateWithoutTagInput>
  }

  export type TagOnContactUpdateWithWhereUniqueWithoutTagInput = {
    where: TagOnContactWhereUniqueInput
    data: XOR<TagOnContactUpdateWithoutTagInput, TagOnContactUncheckedUpdateWithoutTagInput>
  }

  export type TagOnContactUpdateManyWithWhereWithoutTagInput = {
    where: TagOnContactScalarWhereInput
    data: XOR<TagOnContactUpdateManyMutationInput, TagOnContactUncheckedUpdateManyWithoutTagInput>
  }

  export type ContactCreateWithoutTagsInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContactsInput
    conversations?: ConversationCreateNestedManyWithoutContactInput
    messages?: MessageCreateNestedManyWithoutContactInput
    notes?: NoteCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutTagsInput = {
    id?: string
    userId: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
    messages?: MessageUncheckedCreateNestedManyWithoutContactInput
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentUncheckedCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutTagsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTagsInput, ContactUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutContactsInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutContactsInput = {
    id?: string
    userId: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type TagCreateOrConnectWithoutContactsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutContactsInput, TagUncheckedCreateWithoutContactsInput>
  }

  export type ContactUpsertWithoutTagsInput = {
    update: XOR<ContactUpdateWithoutTagsInput, ContactUncheckedUpdateWithoutTagsInput>
    create: XOR<ContactCreateWithoutTagsInput, ContactUncheckedCreateWithoutTagsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutTagsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutTagsInput, ContactUncheckedUpdateWithoutTagsInput>
  }

  export type ContactUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
    conversations?: ConversationUpdateManyWithoutContactNestedInput
    messages?: MessageUpdateManyWithoutContactNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContactNestedInput
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUncheckedUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type TagUpsertWithoutContactsInput = {
    update: XOR<TagUpdateWithoutContactsInput, TagUncheckedUpdateWithoutContactsInput>
    create: XOR<TagCreateWithoutContactsInput, TagUncheckedCreateWithoutContactsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutContactsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutContactsInput, TagUncheckedUpdateWithoutContactsInput>
  }

  export type TagUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSegmentsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyCreateNestedManyWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSegmentsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyUncheckedCreateNestedManyWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSegmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSegmentsInput, UserUncheckedCreateWithoutSegmentsInput>
  }

  export type UserUpsertWithoutSegmentsInput = {
    update: XOR<UserUpdateWithoutSegmentsInput, UserUncheckedUpdateWithoutSegmentsInput>
    create: XOR<UserCreateWithoutSegmentsInput, UserUncheckedCreateWithoutSegmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSegmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSegmentsInput, UserUncheckedUpdateWithoutSegmentsInput>
  }

  export type UserUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUpdateManyWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUncheckedUpdateManyWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutQuickRepliesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    segments?: SegmentCreateNestedManyWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuickRepliesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    segments?: SegmentUncheckedCreateNestedManyWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuickRepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuickRepliesInput, UserUncheckedCreateWithoutQuickRepliesInput>
  }

  export type UserUpsertWithoutQuickRepliesInput = {
    update: XOR<UserUpdateWithoutQuickRepliesInput, UserUncheckedUpdateWithoutQuickRepliesInput>
    create: XOR<UserCreateWithoutQuickRepliesInput, UserUncheckedCreateWithoutQuickRepliesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuickRepliesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuickRepliesInput, UserUncheckedUpdateWithoutQuickRepliesInput>
  }

  export type UserUpdateWithoutQuickRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    segments?: SegmentUpdateManyWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuickRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAutomationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    segments?: SegmentCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAutomationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    segments?: SegmentUncheckedCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAutomationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAutomationsInput, UserUncheckedCreateWithoutAutomationsInput>
  }

  export type UserUpsertWithoutAutomationsInput = {
    update: XOR<UserUpdateWithoutAutomationsInput, UserUncheckedUpdateWithoutAutomationsInput>
    create: XOR<UserCreateWithoutAutomationsInput, UserUncheckedCreateWithoutAutomationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAutomationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAutomationsInput, UserUncheckedUpdateWithoutAutomationsInput>
  }

  export type UserUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    segments?: SegmentUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    segments?: SegmentCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyCreateNestedManyWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    segments?: SegmentUncheckedCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyUncheckedCreateNestedManyWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
  }

  export type ContactCreateWithoutNotesInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContactsInput
    conversations?: ConversationCreateNestedManyWithoutContactInput
    messages?: MessageCreateNestedManyWithoutContactInput
    tags?: TagOnContactCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutNotesInput = {
    id?: string
    userId: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
    messages?: MessageUncheckedCreateNestedManyWithoutContactInput
    tags?: TagOnContactUncheckedCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentUncheckedCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutNotesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutNotesInput, ContactUncheckedCreateWithoutNotesInput>
  }

  export type MessageCreateWithoutNotesInput = {
    id?: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMessagesInput
    contact: ContactCreateNestedOneWithoutMessagesInput
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    reactions?: ReactionCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutNotesInput = {
    id?: string
    userId: string
    contactId: string
    conversationId: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ReactionUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutNotesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutNotesInput, MessageUncheckedCreateWithoutNotesInput>
  }

  export type UserUpsertWithoutNotesInput = {
    update: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    segments?: SegmentUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUpdateManyWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUncheckedUpdateManyWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContactUpsertWithoutNotesInput = {
    update: XOR<ContactUpdateWithoutNotesInput, ContactUncheckedUpdateWithoutNotesInput>
    create: XOR<ContactCreateWithoutNotesInput, ContactUncheckedCreateWithoutNotesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutNotesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutNotesInput, ContactUncheckedUpdateWithoutNotesInput>
  }

  export type ContactUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
    conversations?: ConversationUpdateManyWithoutContactNestedInput
    messages?: MessageUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUncheckedUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUncheckedUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type MessageUpsertWithoutNotesInput = {
    update: XOR<MessageUpdateWithoutNotesInput, MessageUncheckedUpdateWithoutNotesInput>
    create: XOR<MessageCreateWithoutNotesInput, MessageUncheckedCreateWithoutNotesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutNotesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutNotesInput, MessageUncheckedUpdateWithoutNotesInput>
  }

  export type MessageUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    contact?: ContactUpdateOneRequiredWithoutMessagesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: ReactionUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ReactionUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    segments?: SegmentCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyCreateNestedManyWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    segments?: SegmentUncheckedCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyUncheckedCreateNestedManyWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    dripCampaigns?: DripCampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    segments?: SegmentUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUpdateManyWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUncheckedUpdateManyWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    dripCampaigns?: DripCampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDripCampaignsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    segments?: SegmentCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyCreateNestedManyWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDripCampaignsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    segments?: SegmentUncheckedCreateNestedManyWithoutUserInput
    quickReplies?: QuickReplyUncheckedCreateNestedManyWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDripCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDripCampaignsInput, UserUncheckedCreateWithoutDripCampaignsInput>
  }

  export type DripCampaignStepCreateWithoutCampaignInput = {
    id?: string
    sequence: number
    delayHours: number
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    createdAt?: Date | string
    scheduled?: DripScheduledMessageCreateNestedManyWithoutStepInput
  }

  export type DripCampaignStepUncheckedCreateWithoutCampaignInput = {
    id?: string
    sequence: number
    delayHours: number
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    createdAt?: Date | string
    scheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutStepInput
  }

  export type DripCampaignStepCreateOrConnectWithoutCampaignInput = {
    where: DripCampaignStepWhereUniqueInput
    create: XOR<DripCampaignStepCreateWithoutCampaignInput, DripCampaignStepUncheckedCreateWithoutCampaignInput>
  }

  export type DripCampaignStepCreateManyCampaignInputEnvelope = {
    data: DripCampaignStepCreateManyCampaignInput | DripCampaignStepCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type DripEnrollmentCreateWithoutCampaignInput = {
    id?: string
    currentStep?: number
    status: $Enums.DripEnrollmentStatus
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    contact: ContactCreateNestedOneWithoutDripEnrollmentsInput
  }

  export type DripEnrollmentUncheckedCreateWithoutCampaignInput = {
    id?: string
    contactId: string
    currentStep?: number
    status: $Enums.DripEnrollmentStatus
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type DripEnrollmentCreateOrConnectWithoutCampaignInput = {
    where: DripEnrollmentWhereUniqueInput
    create: XOR<DripEnrollmentCreateWithoutCampaignInput, DripEnrollmentUncheckedCreateWithoutCampaignInput>
  }

  export type DripEnrollmentCreateManyCampaignInputEnvelope = {
    data: DripEnrollmentCreateManyCampaignInput | DripEnrollmentCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type DripScheduledMessageCreateWithoutCampaignInput = {
    id?: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
    step: DripCampaignStepCreateNestedOneWithoutScheduledInput
    contact: ContactCreateNestedOneWithoutDripScheduledInput
  }

  export type DripScheduledMessageUncheckedCreateWithoutCampaignInput = {
    id?: string
    stepId: string
    contactId: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DripScheduledMessageCreateOrConnectWithoutCampaignInput = {
    where: DripScheduledMessageWhereUniqueInput
    create: XOR<DripScheduledMessageCreateWithoutCampaignInput, DripScheduledMessageUncheckedCreateWithoutCampaignInput>
  }

  export type DripScheduledMessageCreateManyCampaignInputEnvelope = {
    data: DripScheduledMessageCreateManyCampaignInput | DripScheduledMessageCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDripCampaignsInput = {
    update: XOR<UserUpdateWithoutDripCampaignsInput, UserUncheckedUpdateWithoutDripCampaignsInput>
    create: XOR<UserCreateWithoutDripCampaignsInput, UserUncheckedCreateWithoutDripCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDripCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDripCampaignsInput, UserUncheckedUpdateWithoutDripCampaignsInput>
  }

  export type UserUpdateWithoutDripCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    segments?: SegmentUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUpdateManyWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDripCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    segments?: SegmentUncheckedUpdateManyWithoutUserNestedInput
    quickReplies?: QuickReplyUncheckedUpdateManyWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DripCampaignStepUpsertWithWhereUniqueWithoutCampaignInput = {
    where: DripCampaignStepWhereUniqueInput
    update: XOR<DripCampaignStepUpdateWithoutCampaignInput, DripCampaignStepUncheckedUpdateWithoutCampaignInput>
    create: XOR<DripCampaignStepCreateWithoutCampaignInput, DripCampaignStepUncheckedCreateWithoutCampaignInput>
  }

  export type DripCampaignStepUpdateWithWhereUniqueWithoutCampaignInput = {
    where: DripCampaignStepWhereUniqueInput
    data: XOR<DripCampaignStepUpdateWithoutCampaignInput, DripCampaignStepUncheckedUpdateWithoutCampaignInput>
  }

  export type DripCampaignStepUpdateManyWithWhereWithoutCampaignInput = {
    where: DripCampaignStepScalarWhereInput
    data: XOR<DripCampaignStepUpdateManyMutationInput, DripCampaignStepUncheckedUpdateManyWithoutCampaignInput>
  }

  export type DripCampaignStepScalarWhereInput = {
    AND?: DripCampaignStepScalarWhereInput | DripCampaignStepScalarWhereInput[]
    OR?: DripCampaignStepScalarWhereInput[]
    NOT?: DripCampaignStepScalarWhereInput | DripCampaignStepScalarWhereInput[]
    id?: StringFilter<"DripCampaignStep"> | string
    campaignId?: StringFilter<"DripCampaignStep"> | string
    sequence?: IntFilter<"DripCampaignStep"> | number
    delayHours?: IntFilter<"DripCampaignStep"> | number
    message?: StringFilter<"DripCampaignStep"> | string
    mediaUrl?: StringNullableFilter<"DripCampaignStep"> | string | null
    mediaType?: StringNullableFilter<"DripCampaignStep"> | string | null
    createdAt?: DateTimeFilter<"DripCampaignStep"> | Date | string
  }

  export type DripEnrollmentUpsertWithWhereUniqueWithoutCampaignInput = {
    where: DripEnrollmentWhereUniqueInput
    update: XOR<DripEnrollmentUpdateWithoutCampaignInput, DripEnrollmentUncheckedUpdateWithoutCampaignInput>
    create: XOR<DripEnrollmentCreateWithoutCampaignInput, DripEnrollmentUncheckedCreateWithoutCampaignInput>
  }

  export type DripEnrollmentUpdateWithWhereUniqueWithoutCampaignInput = {
    where: DripEnrollmentWhereUniqueInput
    data: XOR<DripEnrollmentUpdateWithoutCampaignInput, DripEnrollmentUncheckedUpdateWithoutCampaignInput>
  }

  export type DripEnrollmentUpdateManyWithWhereWithoutCampaignInput = {
    where: DripEnrollmentScalarWhereInput
    data: XOR<DripEnrollmentUpdateManyMutationInput, DripEnrollmentUncheckedUpdateManyWithoutCampaignInput>
  }

  export type DripScheduledMessageUpsertWithWhereUniqueWithoutCampaignInput = {
    where: DripScheduledMessageWhereUniqueInput
    update: XOR<DripScheduledMessageUpdateWithoutCampaignInput, DripScheduledMessageUncheckedUpdateWithoutCampaignInput>
    create: XOR<DripScheduledMessageCreateWithoutCampaignInput, DripScheduledMessageUncheckedCreateWithoutCampaignInput>
  }

  export type DripScheduledMessageUpdateWithWhereUniqueWithoutCampaignInput = {
    where: DripScheduledMessageWhereUniqueInput
    data: XOR<DripScheduledMessageUpdateWithoutCampaignInput, DripScheduledMessageUncheckedUpdateWithoutCampaignInput>
  }

  export type DripScheduledMessageUpdateManyWithWhereWithoutCampaignInput = {
    where: DripScheduledMessageScalarWhereInput
    data: XOR<DripScheduledMessageUpdateManyMutationInput, DripScheduledMessageUncheckedUpdateManyWithoutCampaignInput>
  }

  export type DripCampaignCreateWithoutStepsInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDripCampaignsInput
    enrollments?: DripEnrollmentCreateNestedManyWithoutCampaignInput
    scheduled?: DripScheduledMessageCreateNestedManyWithoutCampaignInput
  }

  export type DripCampaignUncheckedCreateWithoutStepsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: DripEnrollmentUncheckedCreateNestedManyWithoutCampaignInput
    scheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type DripCampaignCreateOrConnectWithoutStepsInput = {
    where: DripCampaignWhereUniqueInput
    create: XOR<DripCampaignCreateWithoutStepsInput, DripCampaignUncheckedCreateWithoutStepsInput>
  }

  export type DripScheduledMessageCreateWithoutStepInput = {
    id?: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
    campaign: DripCampaignCreateNestedOneWithoutScheduledInput
    contact: ContactCreateNestedOneWithoutDripScheduledInput
  }

  export type DripScheduledMessageUncheckedCreateWithoutStepInput = {
    id?: string
    campaignId: string
    contactId: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DripScheduledMessageCreateOrConnectWithoutStepInput = {
    where: DripScheduledMessageWhereUniqueInput
    create: XOR<DripScheduledMessageCreateWithoutStepInput, DripScheduledMessageUncheckedCreateWithoutStepInput>
  }

  export type DripScheduledMessageCreateManyStepInputEnvelope = {
    data: DripScheduledMessageCreateManyStepInput | DripScheduledMessageCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type DripCampaignUpsertWithoutStepsInput = {
    update: XOR<DripCampaignUpdateWithoutStepsInput, DripCampaignUncheckedUpdateWithoutStepsInput>
    create: XOR<DripCampaignCreateWithoutStepsInput, DripCampaignUncheckedCreateWithoutStepsInput>
    where?: DripCampaignWhereInput
  }

  export type DripCampaignUpdateToOneWithWhereWithoutStepsInput = {
    where?: DripCampaignWhereInput
    data: XOR<DripCampaignUpdateWithoutStepsInput, DripCampaignUncheckedUpdateWithoutStepsInput>
  }

  export type DripCampaignUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDripCampaignsNestedInput
    enrollments?: DripEnrollmentUpdateManyWithoutCampaignNestedInput
    scheduled?: DripScheduledMessageUpdateManyWithoutCampaignNestedInput
  }

  export type DripCampaignUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: DripEnrollmentUncheckedUpdateManyWithoutCampaignNestedInput
    scheduled?: DripScheduledMessageUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type DripScheduledMessageUpsertWithWhereUniqueWithoutStepInput = {
    where: DripScheduledMessageWhereUniqueInput
    update: XOR<DripScheduledMessageUpdateWithoutStepInput, DripScheduledMessageUncheckedUpdateWithoutStepInput>
    create: XOR<DripScheduledMessageCreateWithoutStepInput, DripScheduledMessageUncheckedCreateWithoutStepInput>
  }

  export type DripScheduledMessageUpdateWithWhereUniqueWithoutStepInput = {
    where: DripScheduledMessageWhereUniqueInput
    data: XOR<DripScheduledMessageUpdateWithoutStepInput, DripScheduledMessageUncheckedUpdateWithoutStepInput>
  }

  export type DripScheduledMessageUpdateManyWithWhereWithoutStepInput = {
    where: DripScheduledMessageScalarWhereInput
    data: XOR<DripScheduledMessageUpdateManyMutationInput, DripScheduledMessageUncheckedUpdateManyWithoutStepInput>
  }

  export type DripCampaignCreateWithoutEnrollmentsInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDripCampaignsInput
    steps?: DripCampaignStepCreateNestedManyWithoutCampaignInput
    scheduled?: DripScheduledMessageCreateNestedManyWithoutCampaignInput
  }

  export type DripCampaignUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: DripCampaignStepUncheckedCreateNestedManyWithoutCampaignInput
    scheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type DripCampaignCreateOrConnectWithoutEnrollmentsInput = {
    where: DripCampaignWhereUniqueInput
    create: XOR<DripCampaignCreateWithoutEnrollmentsInput, DripCampaignUncheckedCreateWithoutEnrollmentsInput>
  }

  export type ContactCreateWithoutDripEnrollmentsInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContactsInput
    conversations?: ConversationCreateNestedManyWithoutContactInput
    messages?: MessageCreateNestedManyWithoutContactInput
    tags?: TagOnContactCreateNestedManyWithoutContactInput
    notes?: NoteCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutDripEnrollmentsInput = {
    id?: string
    userId: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
    messages?: MessageUncheckedCreateNestedManyWithoutContactInput
    tags?: TagOnContactUncheckedCreateNestedManyWithoutContactInput
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    dripScheduled?: DripScheduledMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutDripEnrollmentsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutDripEnrollmentsInput, ContactUncheckedCreateWithoutDripEnrollmentsInput>
  }

  export type DripCampaignUpsertWithoutEnrollmentsInput = {
    update: XOR<DripCampaignUpdateWithoutEnrollmentsInput, DripCampaignUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<DripCampaignCreateWithoutEnrollmentsInput, DripCampaignUncheckedCreateWithoutEnrollmentsInput>
    where?: DripCampaignWhereInput
  }

  export type DripCampaignUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: DripCampaignWhereInput
    data: XOR<DripCampaignUpdateWithoutEnrollmentsInput, DripCampaignUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type DripCampaignUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDripCampaignsNestedInput
    steps?: DripCampaignStepUpdateManyWithoutCampaignNestedInput
    scheduled?: DripScheduledMessageUpdateManyWithoutCampaignNestedInput
  }

  export type DripCampaignUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: DripCampaignStepUncheckedUpdateManyWithoutCampaignNestedInput
    scheduled?: DripScheduledMessageUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type ContactUpsertWithoutDripEnrollmentsInput = {
    update: XOR<ContactUpdateWithoutDripEnrollmentsInput, ContactUncheckedUpdateWithoutDripEnrollmentsInput>
    create: XOR<ContactCreateWithoutDripEnrollmentsInput, ContactUncheckedCreateWithoutDripEnrollmentsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutDripEnrollmentsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutDripEnrollmentsInput, ContactUncheckedUpdateWithoutDripEnrollmentsInput>
  }

  export type ContactUpdateWithoutDripEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
    conversations?: ConversationUpdateManyWithoutContactNestedInput
    messages?: MessageUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUpdateManyWithoutContactNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutDripEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUncheckedUpdateManyWithoutContactNestedInput
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type DripCampaignCreateWithoutScheduledInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDripCampaignsInput
    steps?: DripCampaignStepCreateNestedManyWithoutCampaignInput
    enrollments?: DripEnrollmentCreateNestedManyWithoutCampaignInput
  }

  export type DripCampaignUncheckedCreateWithoutScheduledInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: DripCampaignStepUncheckedCreateNestedManyWithoutCampaignInput
    enrollments?: DripEnrollmentUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type DripCampaignCreateOrConnectWithoutScheduledInput = {
    where: DripCampaignWhereUniqueInput
    create: XOR<DripCampaignCreateWithoutScheduledInput, DripCampaignUncheckedCreateWithoutScheduledInput>
  }

  export type DripCampaignStepCreateWithoutScheduledInput = {
    id?: string
    sequence: number
    delayHours: number
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    createdAt?: Date | string
    campaign: DripCampaignCreateNestedOneWithoutStepsInput
  }

  export type DripCampaignStepUncheckedCreateWithoutScheduledInput = {
    id?: string
    campaignId: string
    sequence: number
    delayHours: number
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    createdAt?: Date | string
  }

  export type DripCampaignStepCreateOrConnectWithoutScheduledInput = {
    where: DripCampaignStepWhereUniqueInput
    create: XOR<DripCampaignStepCreateWithoutScheduledInput, DripCampaignStepUncheckedCreateWithoutScheduledInput>
  }

  export type ContactCreateWithoutDripScheduledInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContactsInput
    conversations?: ConversationCreateNestedManyWithoutContactInput
    messages?: MessageCreateNestedManyWithoutContactInput
    tags?: TagOnContactCreateNestedManyWithoutContactInput
    notes?: NoteCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutDripScheduledInput = {
    id?: string
    userId: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
    messages?: MessageUncheckedCreateNestedManyWithoutContactInput
    tags?: TagOnContactUncheckedCreateNestedManyWithoutContactInput
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    dripEnrollments?: DripEnrollmentUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutDripScheduledInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutDripScheduledInput, ContactUncheckedCreateWithoutDripScheduledInput>
  }

  export type DripCampaignUpsertWithoutScheduledInput = {
    update: XOR<DripCampaignUpdateWithoutScheduledInput, DripCampaignUncheckedUpdateWithoutScheduledInput>
    create: XOR<DripCampaignCreateWithoutScheduledInput, DripCampaignUncheckedCreateWithoutScheduledInput>
    where?: DripCampaignWhereInput
  }

  export type DripCampaignUpdateToOneWithWhereWithoutScheduledInput = {
    where?: DripCampaignWhereInput
    data: XOR<DripCampaignUpdateWithoutScheduledInput, DripCampaignUncheckedUpdateWithoutScheduledInput>
  }

  export type DripCampaignUpdateWithoutScheduledInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDripCampaignsNestedInput
    steps?: DripCampaignStepUpdateManyWithoutCampaignNestedInput
    enrollments?: DripEnrollmentUpdateManyWithoutCampaignNestedInput
  }

  export type DripCampaignUncheckedUpdateWithoutScheduledInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: DripCampaignStepUncheckedUpdateManyWithoutCampaignNestedInput
    enrollments?: DripEnrollmentUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type DripCampaignStepUpsertWithoutScheduledInput = {
    update: XOR<DripCampaignStepUpdateWithoutScheduledInput, DripCampaignStepUncheckedUpdateWithoutScheduledInput>
    create: XOR<DripCampaignStepCreateWithoutScheduledInput, DripCampaignStepUncheckedCreateWithoutScheduledInput>
    where?: DripCampaignStepWhereInput
  }

  export type DripCampaignStepUpdateToOneWithWhereWithoutScheduledInput = {
    where?: DripCampaignStepWhereInput
    data: XOR<DripCampaignStepUpdateWithoutScheduledInput, DripCampaignStepUncheckedUpdateWithoutScheduledInput>
  }

  export type DripCampaignStepUpdateWithoutScheduledInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: DripCampaignUpdateOneRequiredWithoutStepsNestedInput
  }

  export type DripCampaignStepUncheckedUpdateWithoutScheduledInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpsertWithoutDripScheduledInput = {
    update: XOR<ContactUpdateWithoutDripScheduledInput, ContactUncheckedUpdateWithoutDripScheduledInput>
    create: XOR<ContactCreateWithoutDripScheduledInput, ContactUncheckedCreateWithoutDripScheduledInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutDripScheduledInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutDripScheduledInput, ContactUncheckedUpdateWithoutDripScheduledInput>
  }

  export type ContactUpdateWithoutDripScheduledInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
    conversations?: ConversationUpdateManyWithoutContactNestedInput
    messages?: MessageUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUpdateManyWithoutContactNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutDripScheduledInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUncheckedUpdateManyWithoutContactNestedInput
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ConversationCreateManyUserInput = {
    id?: string
    contactId: string
    isActive?: boolean
    unreadCount?: number
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyUserInput = {
    id?: string
    contactId: string
    conversationId: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyUserInput = {
    id?: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    businessName?: string | null
    email?: string | null
    avatarUrl?: string | null
    profilePhotoUrl?: string | null
    company?: string | null
    department?: string | null
    contactType?: string
    timezone?: string | null
    lastMessageAt?: Date | string | null
    lastActiveAt?: Date | string | null
    engagementScore?: number
    engagementLevel?: string
    messageCount?: number
    totalInteractions?: number
    isBlocked?: boolean
    isBusiness?: boolean
    isVerified?: boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateManyUserInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type SegmentCreateManyUserInput = {
    id?: string
    name: string
    criteria: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuickReplyCreateManyUserInput = {
    id?: string
    title: string
    content: string
    category?: string | null
    shortcut?: string | null
    isActive?: boolean
    usageCount?: number
    usageTodayCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationCreateManyUserInput = {
    id?: string
    name: string
    trigger: string
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateManyUserInput = {
    id?: string
    contactId?: string | null
    messageId?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityLogCreateManyUserInput = {
    id?: string
    action: $Enums.ActivityType
    resourceType?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type DripCampaignCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.DripTriggerType
    triggerValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutMessagesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: ReactionUpdateManyWithoutMessageNestedInput
    notes?: NoteUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ReactionUncheckedUpdateManyWithoutMessageNestedInput
    notes?: NoteUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutContactNestedInput
    messages?: MessageUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUpdateManyWithoutContactNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContactNestedInput
    tags?: TagOnContactUncheckedUpdateManyWithoutContactNestedInput
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    dripEnrollments?: DripEnrollmentUncheckedUpdateManyWithoutContactNestedInput
    dripScheduled?: DripScheduledMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementScore?: FloatFieldUpdateOperationsInput | number
    engagementLevel?: StringFieldUpdateOperationsInput | string
    messageCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isBusiness?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    customFields?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: TagOnContactUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: TagOnContactUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickReplyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortcut?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    usageTodayCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickReplyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortcut?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    usageTodayCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickReplyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortcut?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    usageTodayCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneWithoutNotesNestedInput
    message?: MessageUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripCampaignUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: DripCampaignStepUpdateManyWithoutCampaignNestedInput
    enrollments?: DripEnrollmentUpdateManyWithoutCampaignNestedInput
    scheduled?: DripScheduledMessageUpdateManyWithoutCampaignNestedInput
  }

  export type DripCampaignUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: DripCampaignStepUncheckedUpdateManyWithoutCampaignNestedInput
    enrollments?: DripEnrollmentUncheckedUpdateManyWithoutCampaignNestedInput
    scheduled?: DripScheduledMessageUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type DripCampaignUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumDripTriggerTypeFieldUpdateOperationsInput | $Enums.DripTriggerType
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateManyContactInput = {
    id?: string
    userId: string
    isActive?: boolean
    unreadCount?: number
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyContactInput = {
    id?: string
    userId: string
    conversationId: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagOnContactCreateManyContactInput = {
    tagId: string
    assignedAt?: Date | string
  }

  export type NoteCreateManyContactInput = {
    id?: string
    userId: string
    messageId?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DripEnrollmentCreateManyContactInput = {
    id?: string
    campaignId: string
    currentStep?: number
    status: $Enums.DripEnrollmentStatus
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type DripScheduledMessageCreateManyContactInput = {
    id?: string
    campaignId: string
    stepId: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConversationUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: ReactionUpdateManyWithoutMessageNestedInput
    notes?: NoteUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ReactionUncheckedUpdateManyWithoutMessageNestedInput
    notes?: NoteUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagOnContactUpdateWithoutContactInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutContactsNestedInput
  }

  export type TagOnContactUncheckedUpdateWithoutContactInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagOnContactUncheckedUpdateManyWithoutContactInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotesNestedInput
    message?: MessageUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripEnrollmentUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumDripEnrollmentStatusFieldUpdateOperationsInput | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: DripCampaignUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type DripEnrollmentUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumDripEnrollmentStatusFieldUpdateOperationsInput | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DripEnrollmentUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumDripEnrollmentStatusFieldUpdateOperationsInput | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DripScheduledMessageUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: DripCampaignUpdateOneRequiredWithoutScheduledNestedInput
    step?: DripCampaignStepUpdateOneRequiredWithoutScheduledNestedInput
  }

  export type DripScheduledMessageUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripScheduledMessageUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    userId: string
    contactId: string
    waMessageId?: string | null
    content?: string | null
    messageType?: $Enums.MessageType
    direction?: $Enums.MessageDirection
    status?: $Enums.MessageStatus
    mediaUrl?: string | null
    mediaType?: string | null
    mediaFileName?: string | null
    quotedMessageId?: string | null
    isGroupMessage?: boolean
    groupId?: string | null
    groupName?: string | null
    isStatusUpdate?: boolean
    isChannelMessage?: boolean
    channelId?: string | null
    senderName?: string | null
    templateId?: string | null
    quickReplyId?: string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sendAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    contact?: ContactUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: ReactionUpdateManyWithoutMessageNestedInput
    notes?: NoteUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ReactionUncheckedUpdateManyWithoutMessageNestedInput
    notes?: NoteUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    waMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    direction?: EnumMessageDirectionFieldUpdateOperationsInput | $Enums.MessageDirection
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaFileName?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroupMessage?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    isStatusUpdate?: BoolFieldUpdateOperationsInput | boolean
    isChannelMessage?: BoolFieldUpdateOperationsInput | boolean
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    quickReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    tagIds?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionCreateManyMessageInput = {
    id?: string
    emoji: string
    createdAt?: Date | string
  }

  export type NoteCreateManyMessageInput = {
    id?: string
    userId: string
    contactId?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReactionUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotesNestedInput
    contact?: ContactUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagOnContactCreateManyTagInput = {
    contactId: string
    assignedAt?: Date | string
  }

  export type TagOnContactUpdateWithoutTagInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagOnContactUncheckedUpdateWithoutTagInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagOnContactUncheckedUpdateManyWithoutTagInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripCampaignStepCreateManyCampaignInput = {
    id?: string
    sequence: number
    delayHours: number
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    createdAt?: Date | string
  }

  export type DripEnrollmentCreateManyCampaignInput = {
    id?: string
    contactId: string
    currentStep?: number
    status: $Enums.DripEnrollmentStatus
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type DripScheduledMessageCreateManyCampaignInput = {
    id?: string
    stepId: string
    contactId: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DripCampaignStepUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled?: DripScheduledMessageUpdateManyWithoutStepNestedInput
  }

  export type DripCampaignStepUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled?: DripScheduledMessageUncheckedUpdateManyWithoutStepNestedInput
  }

  export type DripCampaignStepUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    delayHours?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripEnrollmentUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumDripEnrollmentStatusFieldUpdateOperationsInput | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contact?: ContactUpdateOneRequiredWithoutDripEnrollmentsNestedInput
  }

  export type DripEnrollmentUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumDripEnrollmentStatusFieldUpdateOperationsInput | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DripEnrollmentUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumDripEnrollmentStatusFieldUpdateOperationsInput | $Enums.DripEnrollmentStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DripScheduledMessageUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    step?: DripCampaignStepUpdateOneRequiredWithoutScheduledNestedInput
    contact?: ContactUpdateOneRequiredWithoutDripScheduledNestedInput
  }

  export type DripScheduledMessageUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripScheduledMessageUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripScheduledMessageCreateManyStepInput = {
    id?: string
    campaignId: string
    contactId: string
    message: string
    mediaUrl?: string | null
    mediaType?: string | null
    scheduledFor: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DripScheduledMessageUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: DripCampaignUpdateOneRequiredWithoutScheduledNestedInput
    contact?: ContactUpdateOneRequiredWithoutDripScheduledNestedInput
  }

  export type DripScheduledMessageUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DripScheduledMessageUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactCountOutputTypeDefaultArgs instead
     */
    export type ContactCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationCountOutputTypeDefaultArgs instead
     */
    export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DripCampaignCountOutputTypeDefaultArgs instead
     */
    export type DripCampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DripCampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DripCampaignStepCountOutputTypeDefaultArgs instead
     */
    export type DripCampaignStepCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DripCampaignStepCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationDefaultArgs instead
     */
    export type ConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReactionDefaultArgs instead
     */
    export type ReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagOnContactDefaultArgs instead
     */
    export type TagOnContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagOnContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SegmentDefaultArgs instead
     */
    export type SegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SegmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuickReplyDefaultArgs instead
     */
    export type QuickReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuickReplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageTemplateDefaultArgs instead
     */
    export type MessageTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutomationDefaultArgs instead
     */
    export type AutomationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutoReplyDefaultArgs instead
     */
    export type AutoReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutoReplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoteDefaultArgs instead
     */
    export type NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityLogDefaultArgs instead
     */
    export type ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppConfigDefaultArgs instead
     */
    export type AppConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DripCampaignDefaultArgs instead
     */
    export type DripCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DripCampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DripCampaignStepDefaultArgs instead
     */
    export type DripCampaignStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DripCampaignStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DripEnrollmentDefaultArgs instead
     */
    export type DripEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DripEnrollmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DripScheduledMessageDefaultArgs instead
     */
    export type DripScheduledMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DripScheduledMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookLogDefaultArgs instead
     */
    export type WebhookLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}